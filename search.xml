<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Docker的架构介绍及部署实战</title>
    <url>/%E4%BA%91%E8%AE%A1%E7%AE%97/Docker%E7%9A%84%E6%9E%B6%E6%9E%84%E4%BB%8B%E7%BB%8D%E5%8F%8A%E9%83%A8%E7%BD%B2%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<h1 id="一-Docker架构分析"><a href="#一-Docker架构分析" class="headerlink" title="一.Docker架构分析"></a>一.Docker架构分析</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如下图所示，Docker采用的是 Client/Server 架构。客户端向服务器发送请求，服务器负责构建、运行和分发容器。</span><br><span class="line"></span><br><span class="line">　　客户端和服务器可以运行在同一个 Host 上，客户端也可以通过socket或 REST API与远程的服务器通信。</span><br><span class="line">　　</span><br><span class="line">　　推荐阅读:</span><br><span class="line">	https://docs.docker.com/get-started/overview/</span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/WEBa01bc568b09ac5222e8645fb75df6d01?method=download&shareKey=49155e3956c3635a15254339ce2332a7" alt="img"></p>
<h2 id="1-Client"><a href="#1-Client" class="headerlink" title="1.Client"></a>1.Client</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">　　Docker客户端，最常用的Docker客户端是docker命令。通过docker我们可以方便地在Host上构建和运行容器。</span><br><span class="line">　　    </span><br><span class="line">　　docker支持很多操作(docker命令行工具)，用户也可以通过REST API与服务器通信。</span><br><span class="line">　　    </span><br><span class="line">　　Client和Docker daemon通信可使用https/http协议进行通信，为了安全起见，默认使用的就是https协议。</span><br></pre></td></tr></table></figure>



<h2 id="2-Docker-Host"><a href="#2-Docker-Host" class="headerlink" title="2.Docker-Host"></a>2.Docker-Host</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Docker daemon： 　</span><br><span class="line">　　　　Docker daemon是服务器组件，即Docker守护进程服务器，以Linux后台服务的方式运行。</span><br><span class="line">　　　　Docker daemon运行在Docker host上，负责创建、运行、监控容器，构建、存储镜像。默认配置下，Docker daemon只能响应来自本地Host的客户端请求。如果要允许远程客户端请求，需要在配置文件中打开TCP监听（支持IPV4和IPV6）。</span><br><span class="line">       </span><br><span class="line">　　Containers： 　　</span><br><span class="line">　　　　Docker容器，用于加载Docker镜像。换句话说，Docker容器就是Docker镜像的运行实例。我们知道镜像(Image)是只读的，在启动一个Container时，其实就是基于Image来新建一个专用的可写仓供用户使用。</span><br><span class="line">       </span><br><span class="line">　　Image： 　　</span><br><span class="line">　　　　可将Docker镜像看成只读模板(它类似于虚拟机使用的ISO镜像文件)，通过它可以创建Docker容器。例如某个镜像可能包含一个Ubuntu操作系统、一个Apache HTTP Server以及用户开发的Web应用。</span><br><span class="line">　　　　镜像有多种生成方法：</span><br><span class="line">　　　　　　(1)可以从无到有开始创建镜像；</span><br><span class="line">　　　　　　(2)也可以下载并使用别人创建好的现成的镜像</span><br><span class="line">　　　　　　(3)还可以在现有镜像上创建新的镜像</span><br><span class="line">　　　　　　(4)我们可以将镜像的内容和创建步骤描述在一个文本文件中，这个文件被称作Dockerfile，通过执行docker build &lt;docker-file&gt;命令可以构建出Docker镜像。</span><br><span class="line">　　　　公开的镜像仓库有很多种，如下所示: </span><br><span class="line">　　　　　　Docker官方镜像地址：</span><br><span class="line">　　　　　　　　https://hub.docker.com/。</span><br><span class="line">　　　　　　阿里的docker镜像地址：</span><br><span class="line">　　　　　　　　https://mirrors.aliyun.com/docker-ce/linux/</span><br><span class="line">　　　　　　清华大学docker镜像地址：</span><br><span class="line">　　　　　　 https://mirrors.tuna.tsinghua.edu.cn/docker-ce/</span><br><span class="line"></span><br><span class="line">　　温馨提示:</span><br><span class="line">　　　　生产环境中，我们通常在公司内部部署有私有镜像仓库。如使用Harbor，Docker Registry等等。在后续的文章我们会逐一对其进行讲解。</span><br></pre></td></tr></table></figure>



<h2 id="3-Registry"><a href="#3-Registry" class="headerlink" title="3.Registry"></a>3.Registry</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我们去构建镜像时，镜像做好之后应该有一个统一存放位置，我们称之为Docker仓库，Registry是存放Docker镜像的仓库（官方默认仓库在&quot;https://hub.docker.com&quot;），Registry分私有和公有两种。</span><br><span class="line"></span><br><span class="line">Images和Registry之间默认使用的时https协议，当然如果你非要指定为http协议也是可以的。</span><br><span class="line"></span><br><span class="line">启动容器时，docker daemon会试图从本地获取相关的镜像；本地镜像不存在时，其将从Registry中下载该镜像并保存到本地。　　</span><br><span class="line"></span><br><span class="line">Registry用于保存docker镜像，包括镜像的层次结构和元数据。用户可自建Registry，也可使用官方的Docker Hub。　　</span><br><span class="line"></span><br><span class="line">Docker Registry中的镜像通常由开发人员制作，而后推送至&quot;公共&quot;或&quot;私有&quot;Registry上保存，供其它人员使用，例如&quot;部署&quot;到生产环境。</span><br><span class="line"></span><br><span class="line">Docker Registry可分为以下几类:　　　　</span><br><span class="line">　　　　Sponsor Registry:</span><br><span class="line">　　　　　　第三方的registry，供客户端和Docker社区使用。　　　　</span><br><span class="line">　　　　Mirror Registry:</span><br><span class="line">　　　　　　第三方的registry，只让客户使用。　　　　</span><br><span class="line">　　　　Vendor Registry:</span><br><span class="line">　　　　　　由发布Docker镜像的供应商提供的registry。　　　　</span><br><span class="line">　　　　Private Registry:</span><br><span class="line">　　　　　　通过设有防火墙和额外的安全层的私有实体提供的registry。　　</span><br><span class="line"></span><br><span class="line">Registry包括Repository和Index，详细说明如下：　　　　</span><br><span class="line">	Repository:　　　　　　</span><br><span class="line">		由某特定的docker镜像的所有迭代版本组成的镜像仓库；</span><br><span class="line">		一个Registry中可以存在多个Repository：　　　　　　　　</span><br><span class="line">		Repository可分为&quot;顶层仓库&quot;和&quot;用户仓库&quot;；　　　　　　　　</span><br><span class="line">		用户仓库名称格式为&quot;用户名/仓库名&quot;。　　　　　　</span><br><span class="line">		每个仓库可以包含多个Tag(标签)，每个标签对应一个镜像；　　　　</span><br><span class="line">	Index：　　　　　　</span><br><span class="line">		维护用户账户，镜像的校验以及公共命名空间的信息；　　　　　　</span><br><span class="line">		相当于为Registry提供了一个完成用户认证等功能的检索接口。</span><br></pre></td></tr></table></figure>



<h2 id="4-镜像名称判断"><a href="#4-镜像名称判断" class="headerlink" title="4.镜像名称判断"></a>4.镜像名称判断</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">官方仓库:</span><br><span class="line">	官方镜像:</span><br><span class="line">       	nginx:1.20.1</span><br><span class="line">       用户上传镜像:</span><br><span class="line">       	jasonyin2020/oldboyedu_birds:v1</span><br><span class="line">       	</span><br><span class="line">第三方仓库:</span><br><span class="line">	用户上传镜像:</span><br><span class="line">		tuv7rqqq.mirror.aliyuncs.com/library/nginx:latest</span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/WEBa2dca432a23a34bf51e0cb222e0b10a9?method=download&shareKey=2771ec0ea3561d364fb9c4f25cdc0c4e" alt="image-20210609221448005"></p>
<h2 id="5-docker、containerd的关系"><a href="#5-docker、containerd的关系" class="headerlink" title="5.docker、containerd的关系"></a>5.docker、containerd的关系</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">为了防止docker一家独大，docker当年的实现被拆分出了几个标准化的模块，标准化的目的是模块是可被其他实现替换的，不由任何一个厂商控制。</span><br><span class="line"></span><br><span class="line">docker由docker-client,dockerd,containerd,docker-shim,runc组成，所以containerd是docker的基础组件之一，下面是从containerd引过来的一张图。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">推荐阅读:</span><br><span class="line">	https://containerd.io/</span><br><span class="line">	https://cloud.tencent.com/document/product/457/35747</span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/WEBc326e984db898a397b4bf7f6344bc087?method=download&shareKey=1d02f5bdfca71f0f817a5597b3ab67be" alt="image-20210624151140220"></p>
<h1 id="二-部署docker环境"><a href="#二-部署docker环境" class="headerlink" title="二.部署docker环境"></a>二.部署docker环境</h1><h2 id="1-关闭并禁用防火墙"><a href="#1-关闭并禁用防火墙" class="headerlink" title="1.关闭并禁用防火墙"></a>1.关闭并禁用防火墙</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@docker201.oldboyedu.com ~]# systemctl stop firewalld</span><br><span class="line">[root@docker201.oldboyedu.com ~]# </span><br><span class="line">[root@docker201.oldboyedu.com ~]# systemctl disable firewalld</span><br><span class="line">Removed symlink /etc/systemd/system/multi-user.target.wants/firewalld.service.</span><br><span class="line">Removed symlink /etc/systemd/system/dbus-org.fedoraproject.FirewallD1.service.</span><br><span class="line">[root@docker201.oldboyedu.com ~]# </span><br></pre></td></tr></table></figure>



<h2 id="2-停用并禁用selinux"><a href="#2-停用并禁用selinux" class="headerlink" title="2.停用并禁用selinux"></a>2.停用并禁用selinux</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@docker201.oldboyedu.com ~]# getenforce </span><br><span class="line">Enforcing</span><br><span class="line">[root@docker201.oldboyedu.com ~]# </span><br><span class="line">[root@docker201.oldboyedu.com ~]# setenforce 0</span><br><span class="line">[root@docker201.oldboyedu.com ~]# </span><br><span class="line">[root@docker201.oldboyedu.com ~]# grep ^SELINUX= /etc/selinux/config</span><br><span class="line">SELINUX=enforcing</span><br><span class="line">[root@docker201.oldboyedu.com ~]# </span><br><span class="line">[root@docker201.oldboyedu.com ~]# sed -ri s&#x27;#(SELINUX=)enforcing#\1disabled#&#x27; /etc/selinux/config</span><br><span class="line">[root@docker201.oldboyedu.com ~]# </span><br><span class="line">[root@docker201.oldboyedu.com ~]# grep ^SELINUX= /etc/selinux/config</span><br><span class="line">SELINUX=disabled</span><br><span class="line">[root@docker201.oldboyedu.com ~]# </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="3-卸载docker较旧的依赖项-如果您的操作系统是刚刚安装完成的状态，或者当前服务器没有安装过docker环境，则可以跳过该步骤"><a href="#3-卸载docker较旧的依赖项-如果您的操作系统是刚刚安装完成的状态，或者当前服务器没有安装过docker环境，则可以跳过该步骤" class="headerlink" title="3.卸载docker较旧的依赖项(如果您的操作系统是刚刚安装完成的状态，或者当前服务器没有安装过docker环境，则可以跳过该步骤)"></a>3.卸载docker较旧的依赖项(如果您的操作系统是刚刚安装完成的状态，或者当前服务器没有安装过docker环境，则可以跳过该步骤)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum -y remove docker docker-client docker-client-latest docker-common docker-lastest docker-lastest-logrotate docker-logrotate  docker-engine</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">温馨提示:</span><br><span class="line">　　(1)现在将Docker Engine软件包称为docker-ce，较旧的Docker Engine版本称为docker或docker-engine。如果已安装这些程序，请卸载它们以及相关的依赖项，因为新老docker版本并不相互兼容哟;</span><br><span class="line">　　(2)如果您在之前没有安装过docker环境，则无需做当前步骤，如果您非要做该步骤，可能会出现如下图所示的情况，属于正常现象！</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/WEB11f8ff602a8566ed36e000515ede16b1?method=download&shareKey=68879421244c1cfe332ac2553111b81f" alt="image-20210608230633881"></p>
<h2 id="4-Docker-engine常见的安装方法概述"><a href="#4-Docker-engine常见的安装方法概述" class="headerlink" title="4.Docker engine常见的安装方法概述"></a>4.Docker engine常见的安装方法概述</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">您可以根据需要以不同的方式安装Docker Engine：</span><br><span class="line">　　　　(1)大多数用户会 设置Docker的存储库并从中进行安装，以简化安装和升级任务。这是推荐的方法。</span><br><span class="line">　　　　(2)一些用户下载并手动安装RPM软件包，并完全手动管理升级。这在诸如在无法访问互联网的空白系统上安装Docker的情况下非常有用。</span><br><span class="line">　　　　(3)在测试和开发环境中，一些用户选择使用自动便利脚本来安装Docker。　　</span><br><span class="line">　　　　</span><br><span class="line">　　　　温馨提示:　　　　</span><br><span class="line">　　　　	本篇博客是基于存储库(需要配置软件源)的方式进行安装，即在新主机上首次安装Docker Engine之前，需要设置Docker存储库。之后，您可以从存储库安装和更新Docker。</span><br></pre></td></tr></table></figure>



<h2 id="5-切换国内的软件源-本案例切换的是阿里源，当然，您也可以考虑使用其它的公网软件源哟"><a href="#5-切换国内的软件源-本案例切换的是阿里源，当然，您也可以考虑使用其它的公网软件源哟" class="headerlink" title="5.切换国内的软件源(本案例切换的是阿里源，当然，您也可以考虑使用其它的公网软件源哟)"></a>5.切换国内的软件源(本案例切换的是阿里源，当然，您也可以考虑使用其它的公网软件源哟)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(1)备份CentOS官网的软件源</span><br><span class="line">mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup</span><br><span class="line"></span><br><span class="line">(2)下载阿里云的软件源</span><br><span class="line">curl -o /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-7.repo </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(3)非阿里云ESC产品推荐操作该步骤</span><br><span class="line">sed -i -e &#x27;/mirrors.cloud.aliyuncs.com/d&#x27; -e &#x27;/mirrors.aliyuncs.com/d&#x27; /etc/yum.repos.d/CentOS-Base.repo</span><br><span class="line"></span><br><span class="line">(4)生成本地缓存</span><br><span class="line">yum makecache</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">温馨提示:</span><br><span class="line">　　上述的sed命令是可选操作，因为非阿里云ECS用户会出现&quot;Could not resolve host: mirrors.cloud.aliyuncs.com; Unknown error&quot;信息，不影响使用。</span><br><span class="line"></span><br><span class="line">参考链接: 　　</span><br><span class="line">　　https://developer.aliyun.com/mirror/centos</span><br></pre></td></tr></table></figure>



<h2 id="6-配置docker-ce的软件源-也称为”存储库”"><a href="#6-配置docker-ce的软件源-也称为”存储库”" class="headerlink" title="6.配置docker-ce的软件源(也称为”存储库”)"></a>6.配置docker-ce的软件源(也称为”存储库”)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(1)添加docker-ce的软件源</span><br><span class="line">	yum -y install yum-utils</span><br><span class="line">	yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line">	</span><br><span class="line">(2)官方软件源默认启用了最新的软件，您可以通过编辑软件源的方式获取各个版本的软件包。例如官方并没有将测试版本的软件源置为可用，您可以通过以下方式开启。同理可以开启各种测试版本等。</span><br><span class="line">	yum-config-manager --enable docker-ce-test  # 可选操作，若不启用并不影响安装docker-ce。</span><br><span class="line">	yum-config-manager --enable docker-ce-nightly  # 可选操作</span><br><span class="line"></span><br><span class="line">(3)如果您启用了多个Docker存储库，则在未在yum installor yum update命令中指定版本的情况下进行安装或更新将始终安装可能的最高版本，这可能不适合您的稳定性需求，这个时候我们也可以来禁用最新的软件源哟~</span><br><span class="line">	yum-config-manager --disable docker-ce-test</span><br><span class="line">	yum-config-manager --disable docker-ce-nightly</span><br><span class="line">	</span><br><span class="line">参考链接:</span><br><span class="line">　　https://developer.aliyun.com/mirror/docker-ce</span><br><span class="line">　　https://docs.docker.com/engine/install/centos/</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="7-安装Docker-Engine和容器"><a href="#7-安装Docker-Engine和容器" class="headerlink" title="7.安装Docker Engine和容器"></a>7.安装Docker Engine和容器</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(1)若不指定安装的docker版本，则默认安装最新版本的Docker Engine和容器</span><br><span class="line">	yum -y install docker-ce docker-ce-cli containerd.io</span><br><span class="line"></span><br><span class="line">(2)要安装特定版本的Docker Engine，请在存储库中列出可用版本，然后选择并安装。返回的列表取决于启用的存储库，并且特定于您的CentOS版本（.el7此示例中的后缀表示）</span><br><span class="line">	yum list docker-ce --showduplicates | sort -r</span><br><span class="line">	</span><br><span class="line">(3)通过其完全合格的软件包名称安装特定版本，该软件包名称是软件包名称（docker-ce）加上版本字符串（第二列），从第一个冒号（:）一直到第一个连字符，并用连字符（-）分隔。其语法格式如下所示。</span><br><span class="line">	yum install docker-ce-&lt;VERSION_STRING&gt; docker-ce-cli-&lt;VERSION_STRING&gt; containerd.io  # 安装特定docker版本的语法格式，下面有对应的案例哟~</span><br><span class="line">	yum install docker-ce-20.10.7 docker-ce-cli-20.10.7 containerd.io</span><br><span class="line">	</span><br><span class="line">温馨提示:</span><br><span class="line">	(1)此处我安装了指定的版本，我们可以将&quot;/etc/yum.conf&quot;的&quot;keepcache&quot;进行缓存即可。</span><br><span class="line">	(2)将rpm包进行打包下发到其他节点</span><br><span class="line">        [root@docker201.oldboyedu.com ~]# mkdir docker_rpm_20.10</span><br><span class="line">        [root@docker201.oldboyedu.com ~]# </span><br><span class="line">        [root@docker201.oldboyedu.com ~]# find /var/cache/yum/ -type f -name &quot;*.rpm&quot; | xargs mv -t docker_rpm_20.10</span><br><span class="line">        [root@docker201.oldboyedu.com ~]# </span><br><span class="line">        [root@docker201.oldboyedu.com ~]# </span><br><span class="line">        [root@docker201.oldboyedu.com ~]# tar zcf docker_rpm_20.10.tar.gz docker_rpm_20.10</span><br><span class="line">        [root@docker201.oldboyedu.com ~]# </span><br><span class="line">        [root@docker201.oldboyedu.com ~]# ll -h</span><br><span class="line">        总用量 109M</span><br><span class="line">        drwxr-xr-x. 2 root root 4.0K 6月   9 21:00 docker_rpm_20.10</span><br><span class="line">        -rw-r--r--. 1 root root 109M 6月   9 21:01 docker_rpm_20.10.tar.gz</span><br><span class="line">        [root@docker201.oldboyedu.com ~]# </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="8-启动docker守护进程并设置开机自启动"><a href="#8-启动docker守护进程并设置开机自启动" class="headerlink" title="8.启动docker守护进程并设置开机自启动"></a>8.启动docker守护进程并设置开机自启动</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@docker201.oldboyedu.com ~]# systemctl start docker</span><br><span class="line">[root@docker201.oldboyedu.com ~]# </span><br><span class="line">[root@docker201.oldboyedu.com ~]# systemctl enable docker</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="9-查看docker的概要信息"><a href="#9-查看docker的概要信息" class="headerlink" title="9.查看docker的概要信息"></a>9.查看docker的概要信息</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@docker201.oldboyedu.com ~]# docker info</span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/WEBf6c3528b72d292911894bbc9870fef5d?method=download&shareKey=99086b4d84fdddd4d37f77212b7bb952" alt="image-20210609004903141"></p>
<h2 id="10-修改docker-engine的默认Registry，建议使用国内的镜像仓库，国外的源网络会延迟较大"><a href="#10-修改docker-engine的默认Registry，建议使用国内的镜像仓库，国外的源网络会延迟较大" class="headerlink" title="10.修改docker engine的默认Registry，建议使用国内的镜像仓库，国外的源网络会延迟较大"></a>10.修改docker engine的默认Registry，建议使用国内的镜像仓库，国外的源网络会延迟较大</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@docker201.oldboyedu.com ~]# tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;</span><br><span class="line">&gt; &#123;</span><br><span class="line">&gt; &quot;registry-mirrors&quot;: [&quot;https://tuv7rqqq.mirror.aliyuncs.com&quot;]</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; EOF</span><br><span class="line">&#123;</span><br><span class="line">&quot;registry-mirrors&quot;: [&quot;https://tuv7rqqq.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">[root@docker201.oldboyedu.com ~]# </span><br><span class="line">[root@docker201.oldboyedu.com ~]# </span><br><span class="line">[root@docker201.oldboyedu.com ~]# cat /etc/docker/daemon.json </span><br><span class="line">&#123;</span><br><span class="line">&quot;registry-mirrors&quot;: [&quot;https://tuv7rqqq.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">[root@docker201.oldboyedu.com ~]# </span><br><span class="line">[root@docker201.oldboyedu.com ~]# systemctl daemon-reload</span><br><span class="line">[root@docker201.oldboyedu.com ~]# </span><br><span class="line">[root@docker201.oldboyedu.com ~]# systemctl restart docker</span><br><span class="line">[root@docker201.oldboyedu.com ~]# </span><br><span class="line"></span><br><span class="line">参考链接:</span><br><span class="line">　　https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/WEB6bcc5a2697f963c65c8465b964cd5496?method=download&shareKey=7945584776dbc4cc4e10f100ef5444da" alt="image-20210609005632041"></p>
<h1 id="三-dockers命令自动补全-新手必备"><a href="#三-dockers命令自动补全-新手必备" class="headerlink" title="三.dockers命令自动补全(新手必备)"></a>三.dockers命令自动补全(新手必备)</h1><h2 id="1-为啥能自动补全"><a href="#1-为啥能自动补全" class="headerlink" title="1.为啥能自动补全"></a>1.为啥能自动补全</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Linux系统许多命令都会提供该命令自身的命令补齐脚本，在安装命令时会自动安装自动补齐脚本，如果有的话，该机制在Linux中被称为bash-complete。</span><br><span class="line"></span><br><span class="line">如下图所示，在/usr/share/bash-completion/completions/ 目录下有许多命令自动补齐的脚本，我们已经安装了docker环境。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/WEBa972a0a843128890cc870365f1efd248?method=download&shareKey=d9c896e47d73771c6647529a8d88a43b" alt="image-20210609230730489"></p>
<h2 id="2-安装相关依赖包"><a href="#2-安装相关依赖包" class="headerlink" title="2.安装相关依赖包"></a>2.安装相关依赖包</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum -y install bash-completion</span><br><span class="line"></span><br><span class="line">source /usr/share/bash-completion/bash_completion</span><br></pre></td></tr></table></figure>



<h2 id="3-验证补全功能"><a href="#3-验证补全功能" class="headerlink" title="3.验证补全功能"></a>3.验证补全功能</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如下图所示，当我们输入子命令不知道该如何是好的时候，就可以连续按两下&quot;tab&quot;键即可。</span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/WEBc6c43750a805917820329fbe2a0c2785?method=download&shareKey=2e409065dd18acfc18c2bdd84f424aa1" alt="img">)</p>
]]></content>
      <categories>
        <category>云计算</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>LVS负载均衡</title>
    <url>/Linux%E9%9B%86%E7%BE%A4%E6%9E%B6%E6%9E%84/LVS%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
    <content><![CDATA[<h1 id="LVS负载均衡"><a href="#LVS负载均衡" class="headerlink" title="LVS负载均衡"></a>LVS负载均衡</h1><h2 id="集群架构的概念"><a href="#集群架构的概念" class="headerlink" title="集群架构的概念"></a>集群架构的概念</h2><blockquote>
<p>集群就是一组相互独立的服务器，通过高速的网络组成一个服务器系统，每个集群节点都是运行其自己进程的一个独立服务器。对网络用户来讲，网站后端就是一个单一的系统，协同起来向用户提供系统资源，系统服务。</p>
</blockquote>
<span id="more"></span>

<h2 id="为什么使用集群架构"><a href="#为什么使用集群架构" class="headerlink" title="为什么使用集群架构"></a>为什么使用集群架构</h2><p><strong><font color='blue'> 1）集群的特点</font></strong></p>
<ul>
<li><p>高性能：</p>
<p>需要很强的运算处理能力比如天气预报，核试验等。这就不是几台服务器能够搞定的。这需要上千台一起来完成这个工作的。</p>
</li>
<li><p>经济有效性：</p>
<p>通常一套系统集群架构，只需要几台或数十台服务器主机即可，与动则上百万的专用超级服务器具有更高的性价比。</p>
</li>
<li><p>可伸缩性：</p>
<p>当服务器负载压力增长的时候，系统能够扩展来满足需求，且不降低服务质量。</p>
</li>
<li><p>高可用性：</p>
<p> 尽管部分硬件和软件发生故障，整个系统的服务必须是7*24小时运行的。</p>
</li>
</ul>
<p><strong><font color='blue'>2） 集群的优势</font></strong></p>
<ul>
<li><p>透明性：</p>
<p>如果一部分服务器宕机了业务不受影响，一般耦合度没有那么高，依赖关系没有那么高。比如NFS服务器宕机了其他就挂载不了了，这样依赖性太强。</p>
</li>
<li><p>高性能：</p>
<p>访问量增加，能够轻松扩展。</p>
</li>
<li><p>可管理型</p>
<p>整个系统可能在物理上很大，但很容易管理。</p>
</li>
<li><p>可编程性</p>
<p>在集群系统上，容易开发应用程序，门户网站会要求这个。</p>
</li>
</ul>
<p><strong><font color='blue'>2） 集群分类及不同的特点</font></strong></p>
<p>计算机集群架构按照功能和结构一般分成以下几类：</p>
<ol>
<li>负载均衡集群（Loadbalancingclusters）简称LBC</li>
<li> 高可用性集群（High-availabilityclusters）简称HAC</li>
<li> 高性能计算集群（High-perfomanceclusters）简称HPC</li>
<li> 网格计算（Gridcomputing）</li>
</ol>
<h2 id="负载均衡集群介绍"><a href="#负载均衡集群介绍" class="headerlink" title="负载均衡集群介绍"></a>负载均衡集群介绍</h2><p>负载均衡集群, 是一种将网络上的访问流量分布于各个节点，以降低服务器压力，更好的向客户端提供服务的一种方式。</p>
<p><strong><font color='blue'>负载均衡集群的作用：</font></strong></p>
<table><tr><td bgcolor=Beige>提供一种廉价、有效、透明的方法，来扩展网络设备和服务器的负载带宽、增加吞吐量，加强网络数据处理能力、提高网络的灵活性和可用性。</td></tr></table>

<p>简单来说,也就是:</p>
<blockquote>
<p>把单台计算机无法承受的大规模的并发访问或数据流量分担到多台节点设备上分别处理，减少用户等待响应的时间，提升用户体验。</p>
<p>单个重负载的运算分担到多台节点设备上做并行处理，每个节点设备处理结束后，将结果汇总，返回给用户，系统处理能力得到大幅度提高。</p>
<p>7*24小时的服务保证，任意一个或多个设备节点设备宕机，不能影响到业务。在负载均衡集群中，所有计算机节点都应该提供相同的服务，集群负载均衡获取所有对该服务的如站请求。</p>
</blockquote>
<p><strong><font color='blue'>常用的负载分为：</font></strong></p>
<ul>
<li>开源软件负载均衡：<strong>Nginx, LVS, Haproxy</strong> (<strong>Nginx</strong>和<strong>Haproxy</strong>通常做七层负载均衡, <strong>LVS</strong>做四层负载均衡. 但是<strong>Nginx</strong>也可以通过<strong>stream</strong>模块做四层负载均衡, <strong>Haproxy</strong>也可以做四层负载均衡 ) ;</li>
<li> 商业的硬件负载均衡: 设备F5、Netscale 。</li>
</ul>
<p><strong><font color='blue'>简单理解一下软件负载均衡:</font></strong></p>
<p>1） 所谓分层的负载均衡，都是以网络的模型来说的。四层就是基于IP和端口的负载均衡，七层就是基于URL等应用信息的负载均衡。所以简单的说四层负载均衡就是通过IP和端口接收请求再分发至真实的服务器，七层是通过URL或主机名接收请求，然后分发至真实的服务器。</p>
<p>2） 而七层的实现也是在四层的基础上是实现的，没有四层就不可能有七层。在第七层上可以做许多事情，比如可以根据七层的浏览器类别区分是手机还是PC，将WEB服务器分为2组，手机登陆专门的移动端网站。</p>
<p>3）对客户端来说，客户端好像是访问的同一台主机。其实为了有更好的用户体验，从智能DNS入手，根据客户端IP来源将域名解析到距离客户端最近的一台服务器或者访问最快速的一台服务器，但这些内容客户端都是感觉不到的，客户端感觉到的只能是访问网站很快。</p>
<p>​                      <img src="https://note.youdao.com/yws/api/personal/file/WEB4c1173b965fcc891e53e399791803f06?method=download&shareKey=8e16d58edd3de26fa824958e8cbf1b2d" alt="avatar">   </p>
<p>负载均衡的原理很简单，就是当客户端发起请求时，请求直接发给Director  Server（调度器），这时会根据设定的调度算法，将请求按照算法的规定智能的分发到真正的后台服务器。以达到将压力均摊。但是我们知道，http的连接时无状态的，假设这样一个场景，我登录某宝买东西，当我看上某款商品时，我将它加入购物车，但是我刷新了一下页面，这时由于负载均衡的原因，调度器又选了新的一台服务器为我提供服务，我刚才的购物车内容全都不见了，这样就会有十分差的用户体验。所以就还需要一个存储共享，这样就保证了用户请求的数据是一样的。所以LVS负载均衡分为三层架构(也就是LVS负载均衡主要组成部分)：</p>
<p><font color='purple'><strong>第一层</strong>：</font>&lt;负载调度器（load balancer/ Director），它是整个集群的总代理，它在有两个网卡，一个网卡面对访问网站的客户端，一个网卡面对整个集群的内部。负责将客户端的请求发送到一组服务器上执行，而客户也认为服务是来自这台主的。举个生动的例子，集群是个公司，负载调度器就是在外接揽生意，将接揽到的生意分发给后台的真正干活的真正的主机们。当然需要将活按照一定的算法分发下去，让大家都公平的干活。<br>      <font color='purple'> <strong>第二层</strong>：</font>服务器池（server pool/ Realserver），是一组真正执行客户请求的服务器，可以当做WEB服务器。就是上面例子中的小员工。<br>        <font color='purple'><strong>第三层</strong></font>：共享存储（shared storage），它为服务器池提供一个共享的存储区，这样很容易使得服务器池拥有相同的内容，提供相同的服务。一个公司得有一个后台账目吧，这才能协调。不然客户把钱付给了A，而换B接待客户，因为没有相同的账目。B说客户没付钱，那这样就不是客户体验度的问题了。</p>
<h2 id="LVS负载均衡-1"><a href="#LVS负载均衡-1" class="headerlink" title="LVS负载均衡"></a>LVS负载均衡</h2><h3 id="IPVS（LVS）发展史"><a href="#IPVS（LVS）发展史" class="headerlink" title="IPVS（LVS）发展史"></a>IPVS（LVS）发展史</h3><p>在linux2.2内核时，IPVS就已经以内核补丁的形式出现</p>
<p>从2.4。24版本以后IPVS已经成为linux内核官方标准内核的一部分</p>
<h3 id="LVS工作原理"><a href="#LVS工作原理" class="headerlink" title="LVS工作原理"></a>LVS工作原理</h3><p>LVS负载均衡调度技术是在linux内核中实现的，我们使用配置LVS时，不是直接配置内核中的IPVS，而是通过IPVS的管理工具IPVSADM来管理配置</p>
<p>LVS集群负载均衡器接受所有入站客户端的请求，并根据算法来决定由哪个集群的节点来处理请求</p>
<h3 id="LVS相关术语介绍"><a href="#LVS相关术语介绍" class="headerlink" title="LVS相关术语介绍"></a>LVS相关术语介绍</h3><ul>
<li>虚拟IP地址（VIP）  </li>
</ul>
<p>​       用于向客户端提供服务的IP地址（配置于负载均衡器上）</p>
<ul>
<li><p>真实的IP地址（RIP） </p>
<p>集群中节点服务器的IP地址</p>
</li>
<li><p>负载均衡器IP地址（DIP）</p>
<p>负载均衡器的IP地址，物理网卡上的IP，用与同外网连接的地址</p>
</li>
<li><p>客户端主机IP地址（CIP）</p>
<p> 终端请求用户的主机IP地址</p>
</li>
</ul>
<h2 id="LVS几种工作模式的介绍"><a href="#LVS几种工作模式的介绍" class="headerlink" title="LVS几种工作模式的介绍"></a>LVS几种工作模式的介绍</h2><h3 id="NAT网络地址转换模式（VS-NAT）"><a href="#NAT网络地址转换模式（VS-NAT）" class="headerlink" title="NAT网络地址转换模式（VS/NAT）"></a>NAT网络地址转换模式（VS/NAT）</h3><p> 通过网络地址转换，调度器LB重写请求报文的目标地址，根据算法将请求分配给后端的真实主机服务器，真实服务器响应处理报文后返回给调度器LB，经过LB的报文源地址被重写，再返回给请求的客户端用户。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB03f9c89dbb5637c2350f56cc00857e51?method=download&shareKey=bff8b56b7053b600ad043bd381fba50a" alt="avatar"></p>
<p><em><strong><font color='red'>过程详解：</font></strong></em></p>
<blockquote>
<p>1：客户端请求CIP（192.168.16.15:80)目标的地址是VIP(10.0.0.3:80);</p>
<p>2：数据经过LB，目的地址将被LB改写成后端服务器其中一个主机地址（RIP 172.168.1.7:80）</p>
<p>3：服务器接收到数据请求后返回应答信息（源地址：172.168.1.7:80，目的地址：10.0.0.3:80，因此处的网关地址需指向LB）给LB</p>
<p>4：LB需将源数据地址改写成VIP地址（10.0.0.3:80，但实际的源地址是RIP1的地址）</p>
<p>5：LB将数据返回给请求的客户端用户，完成整个流程的访问,因此WEB访问量很大的时候，LB就会有很大的负载压力，一般支持10-20台节点，但是这种模式支持IP和端口的转换功能，即192.168.16.15:80—-&gt;10.0.0.3:80—-&gt;172.168.1.7:80</p>
</blockquote>
<h3 id="DR模式（Direct-Routing）直接路由模式"><a href="#DR模式（Direct-Routing）直接路由模式" class="headerlink" title="DR模式（Direct Routing）直接路由模式"></a>DR模式（Direct Routing）直接路由模式</h3><p>DR模式也就是用直接路由技术实现虚拟服务器。它的连接调度和管理与VS/NAT和VS/TUN中的一样，但它的报文转发方法又有不同，VS/DR通过改写请求报文的MAC地址，将请求发送到Real Server，而Real  Server将响应直接返回给客户，免去了VS/TUN中的IP隧道开销。这种方式是三种负载调度机制中性能最高最好的，但是必须要求Director  Server与Real Server都有一块网卡连在同一物理网段上。</p>
<p>Director和RealServer必需在物理上有一个网卡通过不间断的局域网相连。  RealServer上绑定的VIP配置在各自Non-ARP的网络设备上(如lo或tunl),Director的VIP地址对外可见，而RealServer的VIP对外是不可见的。RealServer的地址即可以是内部地址，也可以是真实地址。</p>
<p>DR模式是通过改写请求报文的目标MAC地址，将请求发给真实服务器的，而真实服务器响应后的处理结果直接返回给客户端用户。同TUN模式一样，DR模式可以极大的提高集群系统的伸缩性。而且DR模式没有IP隧道的开销，对集群中的真实服务器也没有必要必须支持IP隧道协议的要求。但是要求调度器LB与真实服务器RS都有一块网卡连接到同一物理网段上，必须在同一个局域网环境。</p>
<p><strong>DR模式是互联网使用比较多的一种模式</strong>，DR模式原理图如下：</p>
<p>​                        <img src="https://note.youdao.com/yws/api/personal/file/WEB9d1c7fcee56cc40f9758bad3319261ab?method=download&shareKey=9643baccbc0de23b0f1459d5e96d3e28" alt="avatar"></p>
<p><strong>DR模式以上原理过程简述：</strong><br>VS/DR模式的工作流程图如上图所示，它的连接调度和管理与NAT和TUN中的一样，它的报文转发方法和前两种不同。DR模式将报文直接路由给目标真实服务器。在DR模式中，调度器根据各个真实服务器的负载情况，连接数多少等，动态地选择一台服务器，不修改目标IP地址和目标端口，也不封装IP报文，而是将请求报文的数据帧的目标MAC地址改为真实服务器的MAC地址。然后再将修改的数据帧在服务器组的局域网上发送。因为数据帧的MAC地址是真实服务器的MAC地址，并且又在同一个局域网。那么根据局域网的通讯原理，真实复位是一定能够收到由LB发出的数据包。真实服务器接收到请求数据包的时候，解开IP包头查看到的目标IP是VIP。（此时只有自己的IP符合目标IP才会接收进来，所以我们需要在本地的回环借口上面配置VIP。</p>
<p>另外:  由于网络接口都会进行ARP广播响应，但集群的其他机器都有这个VIP的lo接口，都响应就会冲突。所以我们需要把真实服务器的lo接口的ARP响应关闭掉。）然后真实服务器做成请求响应，之后根据自己的路由信息将这个响应数据包发送回给客户，并且源IP地址还是VIP。</p>
<p>其实整个DR模式都是停留在第二层的数据链路层, 直接修改MAC。实现报文的转发。再看下面的DR模式图:</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBb0dd5b7ea5d8acddec5896a570c900ad?method=download&shareKey=3ae24eb26c6d5ce0657f77cf841ab314" alt="img"></p>
<blockquote>
<p>1） 当用户请求到达Director Server，此时请求的数据报文会先到内核空间的PREROUTING链。 此时报文的源IP为CIP，目标IP为VIP;</p>
<p>2）PREROUTING检查发现数据包的目标IP是本机，将数据包送至INPUT链;</p>
<p>3）   IPVS比对数据包请求的服务是否为集群服务，若是，将请求报文中的源MAC地址修改为DIP的MAC地址，将目标MAC地址修改RIP的MAC地址，然后将数据包发至POSTROUTING链。 此时的源IP和目的IP均未修改，仅修改了源MAC地址为DIP的MAC地址，目标MAC地址为RIP的MAC地址;</p>
<p>4）由于DS和RS在同一个网络中，所以是通过二层来传输。POSTROUTING链检查目标MAC地址为RIP的MAC地址，那么此时数据包将会发至Real Server;</p>
<p>5）响应报文最终送达至客户端;</p>
</blockquote>
<p><strong>注：LB只能改写目的MAC地址，因此它不能改变请求报文的目的端口端口，LVS只支持unix和linux，但集群节点服务器可以是win系统，此种模式配置相当麻烦</strong></p>
<blockquote>
<p>1 在前端路由器做静态地址路由绑定，将对于VIP的地址仅路由 到Director Server<br>\2arptables：在arp的层次上实现在ARP解析时做防火墙规则，过滤RS响应ARP请求。修改RS上内核参数（arp_ignore和arp_announce）将RS上的VIP配置在网卡接口的别名上，并限制其不能响应对VIP地址解析请求。<br>3)RS可以使用私有地址；但也可以使用公网地址，此时可以直接通过互联网连入RS以实现配置、监控等；<br>4)RS的网关一定不能指向DIP；<br>5)RS跟Dirctory要在同一物理网络内（不能由路由器分隔）；<br>6)请求报文经过Directory，但响应报文一定不经过Director</p>
</blockquote>
<p>LVS的调度算法决定了如何在集群节点之间分配负载压力（访问请求）</p>
<p><strong>调度算法：</strong></p>
<p><strong>rr</strong>轮循调度：将请求依次分配给集群的节点，这种算法适用于各个节点处理能力基本相同的情况下</p>
<p><strong>wrr</strong>加权轮循调度：根据节点的权重来分配，权重较高的优先分配</p>
<p><strong>wlc</strong>加权最小连接数调度：按权重和连接数的数量来分配</p>
<p><strong>lc</strong>最小连接数调度：按连接数的数量来分配</p>
<p><strong>实际生产环境LVS调度算法选型</strong></p>
<p>一般网络服务，如HTTP、MAIL、MYSQL常用的调度算法有：rr、wlc、wrr</p>
<script src='https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/mouse_snow.min.js'></script>

]]></content>
      <categories>
        <category>Linux集群架构</category>
      </categories>
      <tags>
        <tag>LVS</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux基础命令</title>
    <url>/Linux%E5%9F%BA%E7%A1%80/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="Linux基础命令"><a href="#Linux基础命令" class="headerlink" title="Linux基础命令"></a>Linux基础命令</h1><p>Linux系统的基础命令可以说是数不胜数，所以我们分为以下几个分类去总结。</p>
<h2 id="系统目录结构"><a href="#系统目录结构" class="headerlink" title="系统目录结构"></a>系统目录结构</h2><p>⼏乎所有的计算机操作系统都是⽤⽬录结构组织⽂件。具体来说就是在⼀个⽬录中存放⼦⽬录和⽂件, ⽽在⼦⽬录中⼜会进⼀步存放⼦⽬录和⽂件，以此类推形成⼀个树状的⽂件结构，由于其结构很像⼀棵树的分⽀, 所以该结构⼜被称为“⽬录树”。Linux系统中也沿⽤了这种⽂件结构, 所有⽬录和⽂件都在 “根⽬录”下, ⽬录名为”/“。FHS（⽂件系统层次标准）定义了在根⽬录下的主要⽬录以及每个⽬录应该存放什么⽂件。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBf9d7b9b67a753782c35f78bfa90965de?method=download&shareKey=37a1114867c1dcb78edae25e163a8754" alt="img"></p>
<table>
<thead>
<tr>
<th>目录名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>/etc</td>
<td>系统重要配置文件，以及常用服务配置文件</td>
</tr>
<tr>
<td>/var</td>
<td>存放系统引导启动时产生的可变文件，文件通常动态改变，例如：缓存目录，日志文件</td>
</tr>
<tr>
<td>/run</td>
<td>系统启动后,    运⾏的程序产⽣的运⾏时数据，包括进程的pid⽂件,锁⽂件等</td>
</tr>
<tr>
<td>/home</td>
<td>普通⽤户的主⽬录，普通⽤户的家⽬录默认为/HOME/USERNAME</td>
</tr>
<tr>
<td>/root</td>
<td>超级管理员的主⽬录,    普通⽤户⽆权操作</td>
</tr>
<tr>
<td>/tmp</td>
<td>存放临时⽂件,    ⼀般存放超过10天以上都会⾃动删除,可以更改删除临时⽂件的期限</td>
</tr>
<tr>
<td>/boot</td>
<td>存放系统引导时候需要的⽂件</td>
</tr>
<tr>
<td>/dev</td>
<td>存放设备⽂件</td>
</tr>
<tr>
<td>/usr</td>
<td>安装的软件,    共享库</td>
</tr>
<tr>
<td>/usr/bin</td>
<td>⽤户命令⽬录</td>
</tr>
<tr>
<td>/usr/sbin</td>
<td>管理员命令⽬录</td>
</tr>
<tr>
<td>/usr/local</td>
<td>本地⾃定义安装的软件</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">##注意： </span></span><br><span class="line"><span class="comment">#在Linux7系统中, /bin, /sbin, /lib,	/lib64都以软链接的形式链接到/usr/⽬录下,例如:</span></span><br><span class="line">/bin --&gt; /usr/bin</span><br><span class="line">/sbin --&gt; /usr/sbin</span><br><span class="line">lib --&gt; usr/lib</span><br><span class="line">lib64 --&gt; usr/lib64</span><br></pre></td></tr></table></figure>

<h2 id="文件路径定位"><a href="#文件路径定位" class="headerlink" title="文件路径定位"></a>文件路径定位</h2><p>路径的作⽤:定位⽂件具体位置信息</p>
<p>你要在那⾥创建什么⽂件?</p>
<p>你要将什么⽂件复制到什么地⽅?</p>
<p>你要删除的⽂件在什么地⽅?</p>
<h3 id="特殊目录：-和"><a href="#特殊目录：-和" class="headerlink" title="特殊目录：(.)和(..)"></a>特殊目录：(.)和(..)</h3><p>在每个⽬录下, 都会固定存在两个特殊⽬录, 分别是⼀个点(.)和两个(..)的⽬录。⼀个点代表当的是当前⽬录, 两个点代表的是当前⽬录的上层⽬录。注意: 在Linux下所有以点开始的⽂件都是”隐藏⽂件”, 对于这类⽂件, 只使⽤命令 <em>ls    -l</em> 是看不到的, 必须要使⽤ <em>ls    -la</em> 才可以看到,如下所示:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@dennis.com /opt]$ ls -a</span><br><span class="line">.  ..</span><br></pre></td></tr></table></figure>

<h3 id="绝对路径"><a href="#绝对路径" class="headerlink" title="绝对路径"></a>绝对路径</h3><p>Linux系统采⽤了⽬录树的⽂件组织结构, 在Linux下每个⽬录或⽂件都可以从根⽬录处开始寻找,⽐如: /usr/bin ⽬录。这种从根⽬录开始的全路径被称为”绝对路径”, 绝对路径⼀定是以 “/” 开头的。</p>
<p>如何确认当前所在的⽬录, 可以使⽤ pwd 命令查看:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@dennis.com /]$ <span class="built_in">cd</span> tmp/</span><br><span class="line">[root@dennis.com /tmp]$ <span class="built_in">pwd</span></span><br><span class="line">/tmp</span><br></pre></td></tr></table></figure>

<h3 id="相对路径"><a href="#相对路径" class="headerlink" title="相对路径"></a>相对路径</h3><p>相对路径, 关键点在于当前在什么路径下。假设当前⽬录在 /usr/local 下, 那么它的上层⽬录(/usr⽬录)可以⽤ ../ 表示, ⽽` /usr/local 的下层⽬录(src)则可以⽤ ./src 表示。所谓的(.)和(..)⽬录实际上也是属于相对路径</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@dennis.com /tmp]$ <span class="built_in">cd</span> /opt/</span><br><span class="line">[root@dennis.com /opt]$ ls -la</span><br><span class="line">total 8</span><br><span class="line">drwxr-xr-x.  2 root root 4096 Apr 11  2018 .</span><br><span class="line">dr-xr-xr-x. 21 root root 4096 Jul 27 20:23 ..</span><br><span class="line"></span><br><span class="line"><span class="comment">#进⼊当前⽬录</span></span><br><span class="line">[root@dennis.com /opt]$ <span class="built_in">cd</span> .</span><br><span class="line">/<span class="comment">#显示当前⽬录</span></span><br><span class="line">[root@dennis.com /opt]$ <span class="built_in">pwd</span></span><br><span class="line">/opt</span><br><span class="line"></span><br><span class="line"><span class="comment">#进⼊当前⽬录的上层⽬录</span></span><br><span class="line">[root@dennis.com /opt]$ <span class="built_in">cd</span> ..</span><br><span class="line"><span class="comment">#进⼊上层⽬录,也就是/⽬录</span></span><br><span class="line">[root@dennis.com /]$ <span class="built_in">pwd</span></span><br><span class="line">/</span><br><span class="line">[root@dennis.com /]$ </span><br></pre></td></tr></table></figure>

<h3 id="cd-命令常见用法"><a href="#cd-命令常见用法" class="headerlink" title="cd 命令常见用法"></a><em>cd</em> 命令常见用法</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.	表示⽤户所处的当前⽬录</span><br><span class="line">..	表示上级⽬录;</span><br><span class="line">~	表示当前⽤户⾃⼰的家⽬录</span><br><span class="line"></span><br><span class="line">cd -	#切换上次所在⽬录</span><br><span class="line">cd ~	#切换当前用户家目录</span><br><span class="line">cd      #切换当前用户家目录</span><br><span class="line">cd .    #代表当前⽬录,⼀般在拷⻉、移动等情况下使⽤</span><br><span class="line">cd ..	#切换⾄当前⽬录的上级⽬录</span><br></pre></td></tr></table></figure>

<h2 id="目录管理命令"><a href="#目录管理命令" class="headerlink" title="目录管理命令"></a>目录管理命令</h2><h3 id="目录创建命令mkdir"><a href="#目录创建命令mkdir" class="headerlink" title="目录创建命令mkdir"></a>目录创建命令<em>mkdir</em></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#	mkdir dir1</span></span><br><span class="line"><span class="comment">#	mkdir /dir1	/home/xuliangwei/dir2</span></span><br><span class="line"><span class="comment">#	mkdir &#123;dir4,dir5&#125; -v</span></span><br><span class="line"><span class="comment">#	mkdir /dir6/dir6-1 -pv</span></span><br></pre></td></tr></table></figure>

<h3 id="以树状显示目录结构命令tree"><a href="#以树状显示目录结构命令tree" class="headerlink" title="以树状显示目录结构命令tree"></a>以树状显示目录结构命令<em>tree</em></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-L: 显示目录树的层级</span><br><span class="line"></span><br><span class="line"><span class="comment">#显示当前目录下的结构</span></span><br><span class="line">tree</span><br><span class="line"></span><br><span class="line"><span class="comment">#显示一级目录</span></span><br><span class="line">tree -L 1</span><br></pre></td></tr></table></figure>

<h2 id="文件管理命令"><a href="#文件管理命令" class="headerlink" title="文件管理命令"></a>文件管理命令</h2><p>Linux ⼀切皆为⽂件, 在对 Linux 进⾏配置时, 很⼤程度上就是处理⽂件的过程, 所以掌握⽂件的相关操作是⾮常有必要的。下⾯我们介绍如何对⽂件进⾏, 创建、删除、移动、重命名, 以及查看⽂件内容, ⾄于如何编辑⽂件, 在后⾯具体介绍编辑器的时候在做详细阐述。</p>
<h3 id="文件创建命令touch"><a href="#文件创建命令touch" class="headerlink" title="文件创建命令touch"></a>文件创建命令<em>touch</em></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">touch	filename</span><br><span class="line">touch	filename_1	filename_2</span><br><span class="line">touch	/home/xuliangwei/file5	file6</span><br><span class="line">touch	file&#123;1..10&#125;</span><br><span class="line">touch	file&#123;a,b,c&#125;</span><br><span class="line">touch	file&#123;a..z&#125;</span><br></pre></td></tr></table></figure>

<h3 id="文件时间stat"><a href="#文件时间stat" class="headerlink" title="文件时间stat"></a>文件时间<em>stat</em></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@dennis.com /]$ <span class="built_in">stat</span> /etc/passwd</span><br><span class="line">  File: ‘/etc/passwd’</span><br><span class="line">  Size: 1166      	Blocks: 8          IO Block: 4096   regular file</span><br><span class="line">Device: fd01h/64769d	Inode: 920061      Links: 1</span><br><span class="line">Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)</span><br><span class="line">Access: 2021-07-31 00:30:01.842102166 +0800</span><br><span class="line">Modify: 2021-07-13 00:20:38.628719887 +0800</span><br><span class="line">Change: 2021-07-13 00:20:38.629719911 +0800</span><br><span class="line"> Birth: -</span><br><span class="line"></span><br><span class="line">访问时间:atime，查看内容</span><br><span class="line">修改时间:mtime，修改内容</span><br><span class="line">改变时间:ctime，⽂件属性，⽐如权限</span><br><span class="line">删除时间:dtime，⽂件被删除的时间</span><br></pre></td></tr></table></figure>

<h3 id="⽂件⽬录复制命令-cp"><a href="#⽂件⽬录复制命令-cp" class="headerlink" title="⽂件⽬录复制命令 cp"></a>⽂件⽬录复制命令 <em>cp</em></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cp [OPTION]... [-T]	SOURCE DEST</span><br><span class="line">cp [OPTION]... SOURCE... DIRECTORY</span><br><span class="line">cp [OPTION]... -t DIRECTORY SOURCE...</span><br><span class="line"></span><br><span class="line">//将name⽂件复制⾄/tmp⽬录中</span><br><span class="line"><span class="comment"># cp name /tmp/name_copy</span></span><br><span class="line">//如果复制过想保持原⽂件名,不修改名称</span><br><span class="line"><span class="comment"># cp name /tmp/name</span></span><br><span class="line">//如果复制过想保持原来的属性, -p保持原⽂件或⽬录的属性</span><br><span class="line"><span class="comment"># cp -p name /tmp/name_p</span></span><br><span class="line">//复制⽬录只需要使⽤-r参数,递归复制</span><br><span class="line"><span class="comment"># mkdir name_name</span></span><br><span class="line"><span class="comment"># cp -r name_name/ /tmp/name_tmp</span></span><br><span class="line">//将多个⽂件拷⻉同⼀个⽬录</span><br><span class="line"><span class="comment"># cp -rv /etc/hosts /etc/hostname /tmp</span></span><br><span class="line"><span class="comment"># cp -rv /etc/hosts /etc/hostname ./</span></span><br><span class="line"></span><br><span class="line">//</span><br><span class="line"><span class="comment"># cp -rv /etc/hosts /etc/hosts.bak</span></span><br><span class="line"><span class="comment"># cp -rv /etc/&#123;hosts,hosts.bak&#125;</span></span><br><span class="line"><span class="comment"># cp -rv /etc/hosts&#123;,-org&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="⽂件⽬录移动命令-mv"><a href="#⽂件⽬录移动命令-mv" class="headerlink" title="⽂件⽬录移动命令 mv"></a>⽂件⽬录移动命令 <em>mv</em></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mv [OPTION]... [-T]	SOURCE DEST</span><br><span class="line">mv [OPTION]... SOURCE... DIRECTORY</span><br><span class="line">mv [OPTION]... -t DIRECTORY SOURCE...</span><br><span class="line"></span><br><span class="line">//移动⽂件⾄tmp⽬录</span><br><span class="line"><span class="comment"># mv file /tmp/</span></span><br><span class="line"></span><br><span class="line">//移动⽂件⾄tmp⽬录并修改名称为file_test</span><br><span class="line"><span class="comment"># mv file /tmp/file_test</span></span><br><span class="line"></span><br><span class="line">//移动⽬录⾄/tmp⽬录下</span><br><span class="line"><span class="comment"># mv dir/ /tmp/</span></span><br><span class="line"></span><br><span class="line">//移动多个⽂件或多个⽬录⾄同⼀个⽬录</span><br><span class="line"><span class="comment"># touch file&#123;1..3&#125;</span></span><br><span class="line"><span class="comment"># mv file1 file2 file3 /opt/</span></span><br><span class="line"><span class="comment"># mkdir dir&#123;1..3&#125;</span></span><br><span class="line"><span class="comment"># mv dir1/ dir2/ dir3/ /opt</span></span><br></pre></td></tr></table></figure>

<h3 id="文件目录删除命令rm"><a href="#文件目录删除命令rm" class="headerlink" title="文件目录删除命令rm"></a>文件目录删除命令<em>rm</em></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rm OPTION]... FILE...</span><br><span class="line">-r 递归</span><br><span class="line">-f 强制删除</span><br><span class="line">-v 详细过程</span><br><span class="line"></span><br><span class="line"><span class="comment">#删除⽂件,默认会提醒是否删除⽂件</span></span><br><span class="line">rm anan</span><br><span class="line"></span><br><span class="line"><span class="comment">#强制删除⽂件,不提醒</span></span><br><span class="line">rm anan -f</span><br><span class="line"></span><br><span class="line"><span class="comment">#强制删除目录，会提醒</span></span><br><span class="line">rm -r dir/</span><br><span class="line"></span><br><span class="line"><span class="comment">#强制删除目录，不提醒</span></span><br><span class="line">rm -rf dir/</span><br><span class="line"></span><br><span class="line"><span class="comment">#示例</span></span><br><span class="line">mkdir /home/dir10</span><br><span class="line">touch /home/dir10/&#123;file2,file3,.file4&#125;</span><br><span class="line">rm -rf /home/dir10/* <span class="comment">#不包括隐藏⽂件</span></span><br><span class="line">ls /home/dir10/	-a</span><br><span class="line">.	..	.file4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//示例2</span><br><span class="line">touch file&#123;1..10&#125;</span><br><span class="line">touch &#123;1..10&#125;.pdf</span><br><span class="line">rm -rf file*	</span><br><span class="line">rm -rf *.pdf</span><br></pre></td></tr></table></figure>

<h3 id="文件查看命令"><a href="#文件查看命令" class="headerlink" title="文件查看命令"></a>文件查看命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat	 //查看⽂件内容</span><br><span class="line">示例：cat /etc/passwd</span><br><span class="line">示例：cat -n /etc/passwd <span class="comment">#-n参数⾏号</span></span><br><span class="line">示例：cat &gt;&gt; aa.txt &lt;&lt;<span class="string">EOF #追加数据</span></span><br><span class="line"><span class="string">         &gt;&gt; test</span></span><br><span class="line"><span class="string">		 &gt;&gt; EOF</span></span><br><span class="line"></span><br><span class="line">head <span class="comment">#查看⽂件头部内容，默认前⼗⾏</span></span><br><span class="line">示例：head	/etc/passwd				</span><br><span class="line">示例：head	-n5 /etc/passwd  <span class="comment">#-n参数指定查看头⼏⾏</span></span><br><span class="line"></span><br><span class="line">tail <span class="comment">#查看⽂件尾部内容，默认最后⼗⾏</span></span><br><span class="line">示例：tail	/etc/passwd				</span><br><span class="line">示例：tail	-f /var/<span class="built_in">log</span>/messages  <span class="comment">#-f参数跟随尾部输出⽽变化</span></span><br><span class="line"></span><br><span class="line">more <span class="comment">#按空格可翻⻚查看⽂件内容，按q可推出</span></span><br><span class="line">示例：more	/etc/passwd</span><br><span class="line">less //和more类似</span><br><span class="line">示例：less	/etc/passwd</span><br></pre></td></tr></table></figure>

<h3 id="文件下载命令"><a href="#文件下载命令" class="headerlink" title="文件下载命令"></a>文件下载命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget /<span class="comment">#⽂件下载</span></span><br><span class="line">-O <span class="comment">#指定下载地址,更改名称		</span></span><br><span class="line">-T <span class="comment">#超时时间</span></span><br><span class="line">-q <span class="comment">#安静下载(关闭wget输出)</span></span><br><span class="line">--spider <span class="comment">#⽹络爬⾍		</span></span><br><span class="line">示例：wget	http://www.baidu.com</span><br><span class="line">curl <span class="comment">#⽂件下载</span></span><br><span class="line">示例：curl -o http://www.baidu.com</span><br><span class="line">yum	install lrzsz</span><br><span class="line">rz <span class="comment">#⽂件上传</span></span><br><span class="line">sz <span class="comment">#⽂件下载</span></span><br><span class="line">示例：sz filename</span><br></pre></td></tr></table></figure>

<h3 id="命令查找命令"><a href="#命令查找命令" class="headerlink" title="命令查找命令"></a>命令查找命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">locate	<span class="comment">#查找⽂件或者⽬录</span></span><br><span class="line">示例：locate /etc/sh <span class="comment">#搜索etc⽬录下所有以sh开头的⽂件</span></span><br><span class="line">示例：locate -i /etc/sh <span class="comment">#搜索etc⽬录下，所有以sh开头的⽂件，忽略⼤⼩写</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">which</span> <span class="comment">#查找系统PATH变量⽬录下的命令(绝对路径)</span></span><br><span class="line">示例：<span class="built_in">which</span> ls</span><br><span class="line"></span><br><span class="line">whereis	<span class="comment">#查找⽂件索引数据库下的命令、源⽂件、man⽂件。⾮PATH变量查找，所以查找的⾯⽐which要⼴ -b, -m</span></span><br><span class="line">示例：whereis ls</span><br><span class="line">示例：whereis -b ls</span><br></pre></td></tr></table></figure>

<h2 id="字符处理命令"><a href="#字符处理命令" class="headerlink" title="字符处理命令"></a>字符处理命令</h2><h3 id="使用sort排序"><a href="#使用sort排序" class="headerlink" title="使用sort排序"></a>使用<em>sort</em>排序</h3><p>很多情况下需要对无序的数据排序，这是需要用到sort排序了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sort [OPTION]... [FILE]...</span><br><span class="line">-r：倒序</span><br><span class="line">-n：按数字排序</span><br><span class="line">-t：指定分隔符(默认空格)</span><br><span class="line">-k：指定第⼏列, 指定⼏列⼏字符（指定1.1, 3.1, 3.3）</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#演示soft的⽤法, ⾸先创建⼀个⽂件:</span></span><br><span class="line">[root@dennis.com ~]<span class="comment"># cat &gt;&gt; sort.txt &lt;&lt;EOF</span></span><br><span class="line">b:3</span><br><span class="line">c:2</span><br><span class="line">a:4</span><br><span class="line">e:5</span><br><span class="line">d:1</span><br><span class="line">f:11</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment">#下⾯对输出的内容进⾏排序:</span></span><br><span class="line">[root@dennis.com ~]<span class="comment"># sort sort.txt</span></span><br><span class="line">a:4</span><br><span class="line">b:3</span><br><span class="line">c:2</span><br><span class="line">d:1</span><br><span class="line">e:5</span><br><span class="line">f:11</span><br><span class="line"></span><br><span class="line"><span class="comment">#可观察到,	sort⽂件具有⼀个特点,第⼀个字符是字⺟,第三个字符是数字,中间是⽤冒号隔开。</span></span><br><span class="line"><span class="comment">#这样我们可以使⽤-t指定分隔符,	使⽤-k指定⽤于排序的列了。</span></span><br><span class="line">[root@dennis.com ~]<span class="comment"># sort -t &quot;:&quot; -k2 sort.txt</span></span><br><span class="line">d:1</span><br><span class="line">f:11 <span class="comment">#第⼆⾏为什么是11？不应该按照顺序排列？</span></span><br><span class="line">c:2</span><br><span class="line">b:3</span><br><span class="line">a:4</span><br><span class="line">e:5</span><br><span class="line"></span><br><span class="line"><span class="comment">#按照排序的⽅式,	只会看到第⼀个字符,11的第⼀个字符是1,	按照字符来排序确实⽐2⼩。</span></span><br><span class="line"><span class="comment">#如果想要按照数字的⽅式进⾏排序, 需要使⽤-n参数。</span></span><br><span class="line">[root@dennis.com ~]<span class="comment"># sort -t &quot;:&quot; -n -k2 sort.txt</span></span><br><span class="line">d:1</span><br><span class="line">c:2</span><br><span class="line">b:3</span><br><span class="line">a:4</span><br><span class="line">e:5</span><br><span class="line">f:11</span><br><span class="line"></span><br><span class="line"><span class="comment">#测试案例,对下⾯内容进⾏排序</span></span><br><span class="line">192.168.3.1 00:0F:AF:81:19:1F</span><br><span class="line">192.168.3.2 00:0F:AF:85:6C:25</span><br><span class="line">192.168.3.3 00:0F:AF:85:70:42</span><br><span class="line">192.168.2.20 00:0F:AF:85:55:DE</span><br><span class="line">192.168.2.21 00:0F:AF:85:6C:09</span><br><span class="line">192.168.2.22 00:0F:AF:85:5C:41</span><br><span class="line">192.168.0.151 00:0F:AF:85:6C:F6</span><br><span class="line">192.168.0.152 00:0F:AF:83:1F:65</span><br><span class="line">192.168.0.153 00:0F:AF:85:70:03</span><br><span class="line">192.168.1.10 00:30:15:A2:3B:B6</span><br><span class="line">192.168.1.11 00:30:15:A3:23:B7</span><br><span class="line">192.168.1.12 00:30:15:A2:3A:A1</span><br><span class="line">192.168.1.1 00:0F:AF:81:19:1F</span><br><span class="line">192.168.2.2 00:0F:AF:85:6C:25</span><br><span class="line">192.168.3.3 00:0F:AF:85:70:42</span><br><span class="line">192.168.2.20 00:0F:AF:85:55:DE</span><br><span class="line">192.168.1.21 00:0F:AF:85:6C:09</span><br><span class="line">192.168.2.22 00:0F:AF:85:5C:41</span><br><span class="line">192.168.0.151 00:0F:AF:85:6C:F6</span><br><span class="line">192.168.1.152 00:0F:AF:83:1F:65</span><br><span class="line">192.168.0.153 00:0F:AF:85:70:03</span><br><span class="line">192.168.3.10 00:30:15:A2:3B:B6</span><br><span class="line">192.168.1.11 00:30:15:A3:23:B7</span><br><span class="line">192.168.3.12 00:30:15:A2:3A:A1</span><br><span class="line"><span class="comment">#针对第三列的第⼀个字符,第四列的第⼀个字符到第三个字符排序才是正确</span></span><br><span class="line">[root@dennis.com ]<span class="comment"># sor -t. -k3.1,3.1nr -k4.1,4.3nr test.txt使⽤uniq删除重复内容</span></span><br></pre></td></tr></table></figure>

<h3 id="使用uniq删除重复内容"><a href="#使用uniq删除重复内容" class="headerlink" title="使用uniq删除重复内容"></a>使用<em>uniq</em>删除重复内容</h3><p>如果⽂件中有多⾏完全相同的内容, 当前是希望能删除重复的⾏，同时还可以统计出完全相同的行出现的总次数, 那么就可以使⽤ uniq 命令解决这个问题(但是必须配合 sort 使⽤)。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">uniq [OPTION]... [INPUT [OUTPUT]]</span><br><span class="line">-c 计算重复的⾏</span><br><span class="line"></span><br><span class="line">//演示uniq的⽤法,⾸先创建⼀个⽂件:</span><br><span class="line">[root@dennis.com~]<span class="comment">#	cat	uniq.txt</span></span><br><span class="line">abc</span><br><span class="line">123</span><br><span class="line">abc</span><br><span class="line">123</span><br><span class="line">//uniq需要和sort⼀起使⽤, 先使⽤sort排序,让重复内容连续在⼀起</span><br><span class="line">[root@dennis.com~]<span class="comment">#	cat	uniq.txt | sort</span></span><br><span class="line">123</span><br><span class="line">123</span><br><span class="line">abc</span><br><span class="line">abc</span><br><span class="line">//使⽤uniq去除相邻重复的⾏</span><br><span class="line">[root@dennis.com ~]<span class="comment"># cat uniq.txt | sort | uniq</span></span><br><span class="line">123</span><br><span class="line">abc</span><br><span class="line">//使⽤-c参数,能统计出⽂件中每⾏内容重复的次数</span><br><span class="line">[root@dennis.com ~]<span class="comment"># cat uniq.txt | sort | uniq	-c</span></span><br><span class="line">2 123</span><br><span class="line">2 abc</span><br></pre></td></tr></table></figure>

<h3 id="使用cut命令截取某一个字段"><a href="#使用cut命令截取某一个字段" class="headerlink" title="使用cut命令截取某一个字段"></a>使用cut命令截取某一个字段</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cut	OPTION... [FILE]...</span><br><span class="line">-d：指定分隔符</span><br><span class="line">-f：数字,取第⼏列 –f3,6三列和6列</span><br><span class="line">-c：按字符取(空格也算)</span><br><span class="line"></span><br><span class="line">//测试数据,	过滤出⽂件⾥ xuliangwei以及552408925</span><br><span class="line"><span class="comment">#echo “Im xuliangwei, is QQ 552408925” &gt; xuliangwei.com</span></span><br><span class="line"></span><br><span class="line">//实践思路</span><br><span class="line">sed <span class="string">&#x27;s#,# #g&#x27;</span> xuliangwei.txt | cut -d <span class="string">&quot; &quot;</span> -f2,6</span><br><span class="line">sed <span class="string">&#x27;s#,# #g&#x27;</span> xuliangwei.txt | awk -F <span class="string">&quot; &quot;</span> <span class="string">&#x27;&#123;print $2 &quot; &quot; $5&#125;&#x27;</span></span><br><span class="line">awk -F <span class="string">&#x27;[, ]+&#x27;</span> <span class="string">&#x27;&#123;print $2,$5&#125;&#x27;</span> xuliangwei.txt	</span><br><span class="line">awk <span class="string">&#x27;&#123;print $2 $5&#125;&#x27;</span> xuliangwei.txt | awk -F	<span class="string">&quot;,&quot;</span>	<span class="string">&#x27;&#123;print $1&quot;	&quot;$2&#125;&#x27;</span></span><br><span class="line">awk -F <span class="string">&quot;[, ]&quot;</span> <span class="string">&#x27;&#123;print $2 &quot; &quot; $6&#125;&#x27;</span>	xuliangwei.txt	</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">此类问题是运维⼯作中最常⻅的问题。可以演变成分析⽇志，查看TCP各个状态连接数，查看单IP接数排名等</span><br><span class="line">[root@dennis.com]<span class="comment">#	cat	web.log</span></span><br><span class="line">http://www.xuliangwei.com/index.html</span><br><span class="line">http://www.xuliangwei.com/1.html</span><br><span class="line">http://post.xuliangwei.com/index.html</span><br><span class="line">http://mp3.xuliangwei.com/index.html</span><br><span class="line">http://www.xuliangwei.com/3.html</span><br><span class="line">http://post.xuliangwei.com/2.html</span><br><span class="line"></span><br><span class="line">[root@dennis.com ]<span class="comment">#	awk -F &#x27;/&#x27; &#x27;&#123;print $3&#125;&#x27; web.log | sort -rn | uniq –c</span></span><br><span class="line">3 www.xuliangwei.comxuliangwei.com</span><br><span class="line">2 post.xuliangwei.comxuliangwei.com</span><br><span class="line">1 mp3.xuliangwei.comxuliangwei.com</span><br><span class="line"></span><br><span class="line">[root@dennis.com ]<span class="comment">#	cut	-d / -f3 web.log | sort -rn | uniq –c</span></span><br><span class="line">3 www.xuliangwei.comxuliangwei.com</span><br><span class="line">2 post.xuliangwei.comxuliangwei.com</span><br><span class="line">1 mp3.xuliangwei.comxuliang</span><br></pre></td></tr></table></figure>

<h3 id="使用wc统计"><a href="#使用wc统计" class="headerlink" title="使用wc统计"></a>使用wc统计</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wc - <span class="built_in">print</span> newline,	word, and byte counts <span class="keyword">for</span> each file显示⽂件的⾏、单词与字节统计信息</span><br><span class="line"></span><br><span class="line"><span class="comment">#统计fstab有多少⾏</span></span><br><span class="line">[root@dennis.com ~]<span class="comment"># wc -l /etc/fstab</span></span><br><span class="line">15 /etc/fstab</span><br><span class="line"></span><br><span class="line"><span class="comment">#显示/etc/services	⽂件⾏号</span></span><br><span class="line">[root@dennis.com ~]<span class="comment"># wc -l /etc/services	</span></span><br><span class="line">10774 /etc/services</span><br><span class="line"></span><br><span class="line"><span class="comment">#扩展⽅法</span></span><br><span class="line">[root@dennis.com ~]<span class="comment"># grep -n &quot;.&quot; /etc/services | tail -1</span></span><br><span class="line">[root@dennis.com ~]<span class="comment"># awk &#x27;&#123;print NR	$0&#125;&#x27; /etc/services | tail -1</span></span><br><span class="line">[root@dennis.com ~]<span class="comment"># cat -n /etc/services | tail -1</span></span><br><span class="line">[root@dennis.com ~]<span class="comment"># sed &#x27;=&#x27; /etc/services | tail -2</span></span><br></pre></td></tr></table></figure>







































<script src='https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/mouse_snow.min.js'></script>

]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
      <tags>
        <tag>命令</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux用户管理</title>
    <url>/Linux%E5%9F%BA%E7%A1%80/Linux%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h1><span id="more"></span>

<hr>
<h2 id="1-用户和用户组的概念"><a href="#1-用户和用户组的概念" class="headerlink" title="1 用户和用户组的概念"></a>1 用户和用户组的概念</h2><ol>
<li><strong>用户概念：</strong></li>
</ol>
<p>在linux中一切都是文件（文件夹和硬件设备是特殊的文件)，如果有可能尽量使用文本文件。文本文件是人和机器能理解的文件，也成为人和机器进行交流的最好途径。由于所有的配置文件都是文本，所以你只需要一个最简单的编辑器就可以修改。由于修改文本文件如此简单，所以Linux系统本身肯定要加以规范。这就引出了用户(组)和权限这2个概念。而这2个概念的引入，完美的保证了Linux的安全性，同时没有添加复杂性。由于一切皆为文件。所以Linux引入了3个文件来管理用户（组）， /etc/passwd存放用户信息，/etc/shadow存放用户密码信息，/etc/group存放组信息，然后在文件系统中的每个文件的文件头里面添加了用户和文件之间的关系信息。</p>
<ol start="2">
<li><p><strong>用户、组、文件有三种关系：</strong></p>
<ul>
<li><p>用户和文件的关系只有2种：拥有和不拥有。</p>
</li>
<li><p>组合文件的关系只有2种：拥有和不拥有。</p>
</li>
<li><p>组和用户的关系只有2种：属于和不属于。</p>
</li>
</ul>
</li>
<li><p><strong>将这三种关系叠加，用户和文件的最终关系可以归纳为3类：</strong></p>
<ul>
<li><p>用户拥有该文件。</p>
</li>
<li><p>用户属于哪个组，某个组拥有该文件（既用户通过属于某个组拥有该文件）。</p>
</li>
<li><p>用户不拥有该文件。</p>
</li>
</ul>
</li>
<li><p><strong>用户分类：</strong></p>
</li>
</ol>
<table>
<thead>
<tr>
<th>用户分类</th>
<th>作用</th>
<th>特定</th>
</tr>
</thead>
<tbody><tr>
<td>超级用户root (uid == 0)</td>
<td>管理维护整个系统</td>
<td>最高管理权限</td>
</tr>
<tr>
<td>普通用户(uid &gt;= 1000)</td>
<td>只能查看和管理自己的一亩三分地</td>
<td>管理特定服务,为了安全</td>
</tr>
<tr>
<td>程序用户(uid&gt;200 &amp;&amp; uid&lt;1000)</td>
<td>让Linux下面服务正常运行所需要</td>
<td>为了服务正常运行所需要并不需要登录到系统设置密码切换密、切换用户</td>
</tr>
</tbody></table>
<ol start="5">
<li><strong>用户组概念</strong>：</li>
</ol>
<p>每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同Linux 系统对用户组的规定有所不同，如Linux下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。</p>
<ol start="6">
<li><strong>用户组的分类:</strong><ul>
<li>默认组： 创建与用户组同名的组；</li>
</ul>
</li>
</ol>
<ul>
<li>基本组：主要的组；    -g 指定；<ul>
<li>附加组：额外指定的组；    -G 指定；</li>
</ul>
</li>
</ul>
<hr>
<h2 id="2-用户和用户组信息的查看"><a href="#2-用户和用户组信息的查看" class="headerlink" title="2. 用户和用户组信息的查看"></a>2. 用户和用户组信息的查看</h2><table>
<thead>
<tr>
<th>用户分类</th>
<th>作用</th>
<th>特定</th>
</tr>
</thead>
<tbody><tr>
<td>超级用户root (uid == 0)</td>
<td>管理维护整个系统</td>
<td>最高管理权限</td>
</tr>
<tr>
<td>普通用户(uid &gt;= 1000)</td>
<td>只能查看和管理自己的一亩三分地</td>
<td>管理特定服务,为了安全</td>
</tr>
<tr>
<td>程序用户(uid&gt;200 &amp;&amp; uid&lt;1000)</td>
<td>让Linux下面服务正常运行所需要</td>
<td>为了服务正常运行所需要并不需要登录到系统设置密码切换密、切换用户</td>
</tr>
</tbody></table>
<ol>
<li><strong>查看用户信息命令：<em>cat /etc/passwd</em></strong></li>
</ol>
<ul>
<li><p>/etc/passwd;  用户信息;</p>
</li>
<li><p>root:X:0:0:root:/root:/bin/bash  以冒号为分隔符;</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">字段1：用户名  --&gt; root</span><br><span class="line">字段2：密码占位符  --&gt; x （这里都是用x代替）</span><br><span class="line">字段3：uid，用户id  --&gt; 0</span><br><span class="line">字段4：gid ，组id --&gt; 0</span><br><span class="line">字段5：用户描述信息  --&gt; root</span><br><span class="line">字段6：家目录  --&gt;  /root</span><br><span class="line">字段7：登录 shell（用户登陆shell ，当为/bin/bash表示可以登陆，/sbin/nologin表示不被授权登陆）</span><br></pre></td></tr></table></figure>

<p><font color='red'>注：</font>一般来说，只有 root 用户的 uid 是为0的。如果黑客把一个普通用户的 uid 修改为0的话，那么他只要以普通用户的用户名和密码登录，系统就会自动切换到root用户。所以，系统加固的时候一定要过滤出有哪些用户的UID为0</p>
<ol start="2">
<li><strong>查看用户密码信息命令：<em>cat/etc/shadow</em></strong></li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/etc/shadow;  密码信息;</span><br><span class="line">bin:*:18353:0:99999:7:::</span><br><span class="line">字段1：用户名</span><br><span class="line">字段2：通过sha-512加密(二次加密，在经过第一次加密后，第二次加入随机数再次加密)的密码</span><br><span class="line">字段3：最后一次修改密码距离1970年1月1日的天数间隔</span><br><span class="line">字段4：密码最短有效期</span><br><span class="line">字段5：密码最长有效期</span><br><span class="line">字段6：密码过期前几天进行警告</span><br><span class="line">字段7：账户过期后，被锁定的天数</span><br><span class="line">字段8：账号失效时间距离1970年1月1日的天数间隔</span><br><span class="line">字段9：未分配功能</span><br><span class="line"></span><br><span class="line">ps: 字段2是用户的密码位，如果是 * 表示该用户禁用，!! 表示用户密码未初始化，如果为空，表示空密码的</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>查看用户组信息的命令：<em>cat/etc/group</em></strong></li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">组信息的显示有四个字段:</span><br><span class="line">字段1：组名称 --&gt; root</span><br><span class="line">字段2：组密码占位符  --&gt; x</span><br><span class="line">字段3：gid --&gt; 0</span><br><span class="line">字段4：组成员</span><br></pre></td></tr></table></figure>

<p><font color='red'>ps</font>:一个用户只能有一个主要组，最多可以有31个附加组。主要组是用户创建文件时默认的所有组，附加组主要用于权限管理。不论用户属于哪个组，用户都能拥有该组的权限。</p>
<p><font color='blue'><strong>特殊组wheel</strong></font>：在Linux中有一个特殊组<font color='red'>wheel</font>，wheel组就类似于一个管理员的组。在linux中，即使我们有系统管理员root的权限，也不推荐用root用户登录。一般情况下用普通用户登录就可以了，在需要root权限执行一些操作时，再su登录成为root用户。但是，任何人只要知道了root用户的密码，就都可以通过su命令来登录为root用户–这无疑为系统带来了安全隐患。所以，将普通用户加入到wheel组中，被加入的这个普通用户就成了管理员组内的用户了，然后可以修改配置文件使得只有wheel组内的用户可以切换到root用户。</p>
<hr>
<h2 id="3-用户和用户组的管理"><a href="#3-用户和用户组的管理" class="headerlink" title="3. 用户和用户组的管理"></a>3. 用户和用户组的管理</h2><h3 id="3-1用户的创建、删除和修改"><a href="#3-1用户的创建、删除和修改" class="headerlink" title="3.1用户的创建、删除和修改"></a>3.1用户的创建、删除和修改</h3><p><strong><font color='blue'>新建用户系统会做这三件事:</font></strong></p>
<ol>
<li>新建用户时，系统会将 /etc/skel 中的目录及文件拷贝到新建用户的家目录中。</li>
<li>在 /var/spool/mail 中，新建用户名的邮箱 。</li>
<li>在 /etc下的 passwd 、shadow 、group文件中，增加用户信息</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">whoami #我是谁</span><br><span class="line">useradd #创建用户</span><br><span class="line">		-u:	指定UID;</span><br><span class="line">		-c: 指定注释;</span><br><span class="line">		-s: 指定登录shell类型; /bin/bash  /sbin/nologin;</span><br><span class="line">		-G: 指定附加组;</span><br><span class="line">		-a: 追加;</span><br><span class="line">		-g: 指定基本组;</span><br><span class="line">		-r: 指定为系统用户 (UID 201-999)</span><br><span class="line">		-M: 不创建用户的家目录;</span><br><span class="line">		-d：指定其家目录；</span><br><span class="line">usermod: #修改用户;选项参照useradd</span><br><span class="line">userdel: </span><br><span class="line">		 1.#删除用户</span><br><span class="line">			-r: 同时删除用户以及用户家目录;</span><br><span class="line">		 2.# 有进程正在使用该用户,所以无法删除; 只有进程退出后;用户没有被占用,才可以处理;</span><br><span class="line">			kill -9 [要干掉的进程ID]</span><br><span class="line">			userdel username</span><br><span class="line">		 3.# 不加 -r 参数，只删除 passwd、shadow 和 group 文件中的用户信息，/home 目录下的文件不删除，/var/spool/mail/ 下的文件不删除</span><br><span class="line">		   # 加 -r 参数，删除 passwd、shadow 和 group 文件中的用户信息，同时删除用户的家目录和邮箱		   	</span><br><span class="line">			userdel -r username</span><br></pre></td></tr></table></figure>

<p>以下这条命令直接生成一个具有root权限的用户：venus，密码为：123qwe 。前提是这条命令的执行需要root权限。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">useradd -p `openssl passwd -1 -salt &#x27;user&#x27; 123qwe` -u 0 -o -g root  -G root -s /bin/bash -d /home/user venus</span><br></pre></td></tr></table></figure>

<p><font color='red'>注</font>：用户创建时，默认的属性（比如UID，GID，是否创建家目录，创建邮箱等）都是通过/etc/login.defs文件控制的，修改此文件的属性，会影响以后创建的所有用户。也可以创建用户时指定参数修改，这样只对当前创建用户有效</p>
<p><strong><font color='blue'>删除用户：</font></strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">userdel  -r  james  #删除用户一定记得加 -r 参数 ！！</span><br></pre></td></tr></table></figure>

<ol>
<li>不加 -r 参数，只删除 passwd、shadow 和 group 文件中的用户信息，/home 目录下的文件不删除，/var/spool/mail/ 下的文件不删除。</li>
<li>加 -r 参数，删除 passwd、shadow 和 group 文件中的用户信息，同时删除用户的家目录和邮箱。</li>
</ol>
<p><strong><font color='blue'>修改用户属性：</font></strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">usermod   参数   james</span><br><span class="line"></span><br><span class="line">-s 修改用户的登陆shell   usermod -s /sbin/nologin james </span><br><span class="line">-L 账户锁定  (可以通过 passwd -S  账户名 查看账户的状态)</span><br><span class="line">-U 解锁账户</span><br><span class="line">-g  修改账户所在组   例：将bob所在组改成james：usermod  -g  james   bob   </span><br><span class="line">-G  给账户添加附加组  例：给bob添加一个附加组john：usermod  -G  john  bob；从附加组john中删除用户bob：gpasswd -d  bob  john</span><br><span class="line">-a  默认情况下，当用户已经存在附加组时，再添加附加组则会把之前的附加组给替换了，加 -a 参数，则不替换原来的附加组，意味着该用户可以有多个附加组。</span><br></pre></td></tr></table></figure>

<p><strong><font color='blue'>锁定和解锁用户：</font></strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">锁定用户：usermod -L www    或   passwd -l www</span><br><span class="line">解锁用户：usermod -U www   或   passwd -u www</span><br><span class="line">查看用户状态：passwd -S www</span><br><span class="line"></span><br><span class="line">注：虽然 usermod 和 passwd 这两个命令都可以锁定和解锁用户，但是还是有区别的。区别之一就是passwd命令操作完后会有提示。还有一个区别就是 passwd 的权限比 usermod 大，使用 usermod 锁定的用户可以用 passwd 来解锁，但是使用 passwd 锁定的用户不能用 usermod 来解锁</span><br></pre></td></tr></table></figure>

<h3 id="3-2-用户密码修改"><a href="#3-2-用户密码修改" class="headerlink" title="3.2 用户密码修改"></a>3.2 用户密码修改</h3><ul>
<li><p>修改命令使用passwd来实现：</p>
<p>1.超级管理员:</p>
<pre><code>        1.1) 随意修改任何人的密码;
        1.2) 密码强度可以随意;
</code></pre>
<p>2.普通用户执行:</p>
<pre><code>        2.1) 仅修改自己的密码,不可以修改其他人;
        2.2) 密码强度必须满足8个字符及以上;
</code></pre>
<p>3.passwd使用方法:</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1.交互式修改密码：</span><br><span class="line">	passwd username</span><br><span class="line">2.非交互式修改密码：</span><br><span class="line">	echo &quot;passwd&quot; | passwd --stdin username</span><br><span class="line">	Changing password for user jack.</span><br><span class="line">	passwd: all authentication tokens updated successfully.	</span><br><span class="line">如果想要设置强度较高的密码需要安装 </span><br><span class="line"><span class="meta">	#</span><span class="bash">yum install -y expect</span> </span><br><span class="line"><span class="meta">			#</span><span class="bash"> -l 长度</span></span><br><span class="line"><span class="meta">			#</span><span class="bash"> -d 数字</span></span><br><span class="line"><span class="meta">			#</span><span class="bash"> -c 小写</span></span><br><span class="line"><span class="meta">			#</span><span class="bash"> -C 大写</span></span><br><span class="line"><span class="meta">			#</span><span class="bash"> -s 特殊字符</span></span><br><span class="line">			mkpasswd -l 10 -d 3 -c 3 -C 3 -s 1</span><br><span class="line">			Y44ssjSG0,</span><br><span class="line">	echo &quot;$(mkpasswd -l 10 -d 3 -c 3 -C 3 -s 1)&quot; | tee ok.txt | passwd --stdin tom</span><br><span class="line">	Changing password for user jack.</span><br><span class="line">	passwd: all authentication tokens updated successfully.</span><br><span class="line">	[root@tom /]# cat ok.txt </span><br><span class="line">1hNOp*H63y</span><br><span class="line"><span class="meta">	#</span><span class="bash">tee -a //追加</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">生成密码的方法</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">方法1</span> </span><br><span class="line"> mkpasswd -l 16  #16位密码</span><br><span class="line"><span class="meta"> </span></span><br><span class="line"><span class="meta"> #</span><span class="bash">方法2</span></span><br><span class="line"> echo  $RANDOM|md5sum |head -c16</span><br><span class="line"> RANDOM 系统变量(环境变量) 生成随机数字 </span><br><span class="line"><span class="meta"> </span></span><br><span class="line"><span class="meta"> #</span><span class="bash">方法3 date</span> </span><br><span class="line"> date +%N |md5sum  |head -c16</span><br><span class="line"><span class="meta"> </span></span><br><span class="line"><span class="meta"> #</span><span class="bash">方法4  了解</span></span><br><span class="line"> [root@oldboyedu ~]# echo  123  |tr 123 abc</span><br><span class="line">abc</span><br><span class="line">[root@oldboyedu ~]# </span><br><span class="line">[root@oldboyedu ~]# echo  123123  |tr 123 abc</span><br><span class="line">abcabc</span><br><span class="line">[root@oldboyedu ~]# echo  112233  |tr 123 abc</span><br><span class="line">aabbcc</span><br><span class="line">[root@oldboyedu ~]# #1对1的替换 </span><br><span class="line">[root@oldboyedu ~]# #tr 替换  </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">tr 生成随机字符 (删除)</span></span><br><span class="line">-d 删除</span><br><span class="line">-c 取反</span><br><span class="line">tr -cd  &#x27;0-9&#x27;  &lt;/dev/urandom |head -c16</span><br><span class="line">tr -cd  &#x27;a-zA-Z0-9&#x27;  &lt;/dev/urandom |head -c16</span><br></pre></td></tr></table></figure>

<p>注：借助chage指令，可以修改用户的密码策略，也可通过编辑 /etc/shadow (不建议)</p>
<p>​        比如：chage  -l  bob，查看用户bob的密码策略</p>
<p>​       chage -M 90 bob，将用户bob的密码有效期修改为90天</p>
<p>​        脚本实现修改用户的密码策略</p>
<ul>
<li><font color='red'><strong>练习：</strong></font></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1.#批量创建10个用户oldboy01..oldboy10,并设置123456为密码(不能用循环等语句,如for,while等)</span><br><span class="line">echo oldboy&#123;01..10&#125;|xargs -n1|sed -r &#x27;s#(.*)#useradd \1; echo 123456|passwd --stdin \1#g&#x27;|bash</span><br><span class="line"></span><br><span class="line">2.#批量创建10个用户oldboy01..oldboy10,并设置随机8为密码(不能用循环等语句,如for,while等)</span><br><span class="line">echo oldboy&#123;11..20&#125; |xargs -n1|sed -r &#x27;s#(.*)#useradd \1;p=`mkpasswd -l 8`;echo $p|passwd --stdin \1;echo \1 $p&gt;&gt;/root/pass.txt#g&#x27; |bash</span><br></pre></td></tr></table></figure>

<h3 id="3-3用户组管理"><a href="#3-3用户组管理" class="headerlink" title="3.3用户组管理"></a>3.3用户组管理</h3><p><strong><font color='blue'>添加组：</font></strong> groupadd www</p>
<ol>
<li> -g, –gid                      为新组使用 GID，例 groupadd -g 2000 xie  创建新组xie，并且gid设置为2000</li>
<li> -K, –key                    不使用 /etc/login.defs 中的默认值</li>
<li> -o, –non-unique      允许创建有重复 GID 的组</li>
<li> -p, –password         为新组使用此加密过的密码</li>
<li> -r, –system               创建一个系统账户</li>
</ol>
<p><strong><font color='blue'>删除组：</font></strong> groupdel www</p>
<p> -r , –remove                    删除主目录和邮件池</p>
<p><strong><font color='blue'>修改组的属性： </font></strong> groupmod www</p>
<p> -g, –gid GID                    将组 ID 改为 GID<br>         -n, –new-name             改名为 NEW_GROUP<br>         -o, –non-unique           允许使用重复的 GID</p>
<p><strong><font color='blue'>修改组中的用户：groupmems： </font></strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">groupmems   -a  john  -g  www    将用户john加到www组中</span><br><span class="line">groupmems   -d  john  -g  www    将用户john从xie组中移除 或 gpasswd -d  john  www</span><br></pre></td></tr></table></figure>











]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
      <tags>
        <tag>用户</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux系统Bash初识</title>
    <url>/Linux%E5%9F%BA%E7%A1%80/Linux%E7%B3%BB%E7%BB%9FBash%E5%88%9D%E8%AF%86%E5%88%AB/</url>
    <content><![CDATA[<h2 id="Linux系统终端"><a href="#Linux系统终端" class="headerlink" title="Linux系统终端"></a>Linux系统终端</h2><p>服务器终端切换：Ctrl + Alt +F1 … F6</p>
<p>虚拟机终端切换： Ctrl + Shift + Alt + F1 … F6</p>
<p>虚拟终端由<em>mingetty</em>程序生成</p>
<span id="more"></span>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//物理机执行为本地终端</span><br><span class="line">[root@dennis.com ~]$ tty</span><br><span class="line">/dev/tty1</span><br><span class="line"></span><br><span class="line">//通过网路使用模拟终端远程连接Linux, 日常运维中就是这种方式</span><br><span class="line">[root@dennis.com ~]$ tty</span><br><span class="line">/dev/pts/0</span><br></pre></td></tr></table></figure>

<h2 id="Linux系统Bash系统管理"><a href="#Linux系统Bash系统管理" class="headerlink" title="Linux系统Bash系统管理"></a>Linux系统Bash系统管理</h2><p>​                                              <img src="https://img1.baidu.com/it/u=404627178,1930063483&fm=15&fmt=auto&gp=0.jpg" alt="img" style="zoom: 50%;" /></p>
<p>简单的说, Shell是系统的⽤户界⾯，提供了⽤户与内核进⾏交互操作的⼀种接⼝。它接收⽤户输</p>
<p>⼊的命令并把它送⼊内核去执⾏。</p>
<p>​                                                <img src="https://images2017.cnblogs.com/blog/1222491/201801/1222491-20180128195658115-361387611.png" alt="img" style="zoom:50%;" /></p>
<p>实际上Shell是⼀个命令解释器，它解释由⽤户输⼊的命令并且把它们送到内核。</p>
<blockquote>
<p>BASH Shell: 是⼀个为GNU计划编写的Unix shell, 是许多Linux发⾏版的默认Shell</p>
<p>C Shell: 是SUN公司Shell的BSD版本。</p>
<p>Z Shell: 它集成了bash、ksh的重要特性，同时⼜增加了⾃⼰独有的特性。</p>
<p>还有许多传统UNIX上⽤的Shell，例如tcsh、csh、ash、bsh、ksh等, Shell Script⼤致都类</p>
<p>同，当您学会⼀种Shell以后，其它的Shell很快就上⼿, ⼤多数的时候, ⼀个Shell脚本 通常可</p>
<p>以在很多种Shell上使⽤。</p>
</blockquote>
<p>查看当前使用的shell</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@dennis.com ~]$ <span class="built_in">echo</span> <span class="variable">$SHELL</span></span><br><span class="line">/bin/bash</span><br></pre></td></tr></table></figure>

<p>查看 Linux 可⽤的 shell</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@dennis.com ~]$ cat /etc/shells </span><br><span class="line">/bin/sh</span><br><span class="line">/bin/bash</span><br><span class="line">/usr/bin/sh</span><br><span class="line">/usr/bin/bash</span><br><span class="line">/sbin/nologin</span><br></pre></td></tr></table></figure>

<p>Bash Shell 提示符</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$PS1</span></span><br><span class="line">[\[\e[34;1m\]\u@\[\e[0m\]\[\e[32;1m\]\H\[\e[0m\] \[\e[31;1m\]\w\[\e[0m\]]\\$</span><br><span class="line"></span><br><span class="line">[root@dennis.com ~]$ date</span><br><span class="line">Sun Jul 25 21:53:32 CST 2021</span><br></pre></td></tr></table></figure>

<h2 id="基础命令语法结构"><a href="#基础命令语法结构" class="headerlink" title="基础命令语法结构"></a>基础命令语法结构</h2><ul>
<li><p>命令 选型 参数：</p>
<ul>
<li>命令：命令主题功能；</li>
<li>选项：用来调节命令的输出；</li>
<li>参数； 对应要操作的文件或目录。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//等待⽤户输⼊,执⾏命令,	$	=	普通⽤户,	<span class="comment">#	=	root⽤户(超级管理员)</span></span><br><span class="line">[student@desktop0	~]$</span><br><span class="line"></span><br><span class="line">//bash	Shell	执⾏命令</span><br><span class="line">//命令		选项		参数</span><br><span class="line"><span class="built_in">command</span>	[-options]	[arguments]</span><br><span class="line">[root@dennis.com ~]$ ls				<span class="comment">#命令</span></span><br><span class="line">[root@dennis.com ~]$ ls	-a			<span class="comment">#命令+选项</span></span><br><span class="line">[root@dennis.com ~]$ ls	-a	/tmp/	<span class="comment">#命令+选项+参数</span></span><br><span class="line"></span><br><span class="line">命令:	命令的主体</span><br><span class="line">				⼀个命令有多个选项,	多个选项可以合并在⼀起</span><br><span class="line">选项:	⽤于调节命令的具体功能</span><br><span class="line">				以	“-”引导短格式选项（单个字符），例如“-l”</span><br><span class="line">				以“--”引导⻓格式选项（多个字符），例如“--color”</span><br><span class="line">				多个短格式选项可以写在⼀起，只⽤⼀个“-”引导，例如“-al”</span><br><span class="line">参数:	命令操作的对象，如⽂件、⽬录名等</span><br><span class="line"><span class="comment">#	命令必须开头， 选项和参数位置可以发⽣变化</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Bash特性-自带功能"><a href="#Bash特性-自带功能" class="headerlink" title="Bash特性-自带功能"></a>Bash特性-自带功能</h2><ol>
<li><p>命令补全</p>
<ul>
<li>命令补全；</li>
<li>路径补全；</li>
<li><font color='red'>注意</font>: 当tab一下不行,就两下,如果两下不行,就说明路径不对,或输入的命令不对;</li>
</ul>
<p><strong>tab</strong>键以实现命令补全, 路径补全和命令实现⽅式⼀致, ⼯作中我们经常⽤到 tab 补全, 减少执⾏命令以及路径出错率。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//查看ip时忘记具体了命令</span><br><span class="line">[root@dennis.com ~]$ ifcon</span><br><span class="line">//按下tab键会⾃动补全</span><br><span class="line">[root@dennis.com ~]$ ifconfig</span><br><span class="line"></span><br><span class="line">//按⼀下tab键没有反应,	按两下tab键列出所有<span class="keyword">if</span>开头的命令</span><br><span class="line">[root@dennis.com ~]$ <span class="keyword">if</span></span><br><span class="line"><span class="keyword">if</span>         ifcfg      ifconfig   ifdown     ifenslave  ifnames    ifstat     iftop      ifup</span><br><span class="line"></span><br><span class="line">//linux路径较深,	经常使⽤tab键进⾏补全,	如果路径出错是没有办法补全</span><br><span class="line">[root@dennis.com ~]$ ls	/etc/sysconfig/network-scripts/</span><br></pre></td></tr></table></figure></li>
<li><p>快捷键</p>
<p>快捷键可以帮助我们提升工作效率。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Ctrl	+	A				//光标跳转⾄正在输⼊的命令⾏的⾸部</span><br><span class="line">Ctrl	+	E				//光标跳转⾄正在输⼊的命令⾏的尾部</span><br><span class="line">Ctrl	+	C				//终⽌前台运⾏的程序</span><br><span class="line">Ctrl	+	D				//在shell中，ctrl-d表示推出当前shell。</span><br><span class="line">Ctrl	+	Z				//将任务暂停，挂⾄后台</span><br><span class="line">Ctrl	+	L				//清屏，和clear命令等效。</span><br><span class="line">Ctrl	+	K				//删除从光标到⾏末的所有字符</span><br><span class="line">Ctrl	+	U				//删除从光标到⾏⾸的所有字符</span><br><span class="line">Ctrl	+	R				//搜索历史命令,	利⽤关键字</span><br><span class="line">//在命令⾏前加⾯加	<span class="string">&quot;#&quot;</span>	则该命令不会被执⾏</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>让我先来看看linux中常用的一些简单命令：</p>
<h3 id="History命令"><a href="#History命令" class="headerlink" title="History命令"></a>History命令</h3><p>history 查看系统命令历史, 追溯之前发⽣情况</p>
<blockquote>
<p>命令选项</p>
<p>-w 保存命令历史到历史⽂件</p>
<p>-c 清空命令历史记录, 不会清空⽂件</p>
<p>-d 删除命令历史的第 N 条⾏</p>
</blockquote>
<p>history 命令历史相关快捷键</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//使⽤双	!!	可执⾏上⼀条命令</span><br><span class="line">[root@dennis.com ~]$ ls</span><br><span class="line">hello.txt</span><br><span class="line">[root@dennis.com ~]$ !!</span><br><span class="line">ls</span><br><span class="line">hello.txt</span><br><span class="line"></span><br><span class="line">//输⼊!6,	执⾏<span class="built_in">history</span>命令历史中第 6 ⾏命令</span><br><span class="line">[root@dennis.com ~]$ !6</span><br><span class="line">ls</span><br><span class="line">hello.txt</span><br><span class="line"></span><br><span class="line">//使⽤!cat,	调⽤<span class="built_in">history</span>命令历史最近⼀次执⾏过的cat命令</span><br><span class="line">[root@dennis.com ~]$ cat /etc/sysconfig/network-scripts/ifcfg-eth0</span><br><span class="line">[root@dennis.com ~]$ !cat</span><br><span class="line">cat	/etc/sysconfig/network-scripts/ifcfg-eth0</span><br><span class="line"></span><br><span class="line">[root@dennis.com ~]$ ls	/etc/passwd</span><br><span class="line">//调⽤上⼀条命令的最后参数或选项,	按下ESC松开,	然后按下 <span class="string">&quot;.&quot;</span></span><br><span class="line">[root@dennis.com ~]$ cat</span><br><span class="line">[root@dennis.com ~]$ cat	/etc/passwd</span><br><span class="line">//第⼆种⽅式,	输⼊!$</span><br><span class="line">[root@dennis.com ~]$ ls	!$</span><br><span class="line">ls	/etc/passwd</span><br><span class="line">/etc/passwd</span><br></pre></td></tr></table></figure>

<h3 id="Alias命令别名"><a href="#Alias命令别名" class="headerlink" title="Alias命令别名"></a>Alias命令别名</h3><p>命令别名将⽤户经常使⽤的复杂命令简单化, 可以⽤ “alias    别名名称=命令” 命令创建属于⾃⼰的</p>
<p>命令别名, 若要取消⼀个命令别名，则是⽤ unalias    别名名称 命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//1.定义临时别名,	if1为查看eth0⽹卡别名</span><br><span class="line">[root@dennis.com ~]$ <span class="built_in">alias</span> if0=<span class="string">&#x27;ifconfig eth0&#x27;</span></span><br><span class="line">[root@dennis.com ~]$ if0</span><br><span class="line">eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.25.183.186  netmask 255.255.240.0  broadcast 172.25.191.255</span><br><span class="line"></span><br><span class="line">//如果定义命令本身,	会执⾏什么?</span><br><span class="line">[root@dennis.com ~]$ <span class="built_in">alias</span>	ifconfig=<span class="string">&#x27;ifconfig	eth0&#x27;</span></span><br><span class="line">//绝对路径执⾏,	调⽤命令本身</span><br><span class="line">[root@dennis.com ~]$ /sbin/ifconfig</span><br><span class="line">//通过\转义字符,	调⽤命令本身</span><br><span class="line">[root@dennis.com ~]$ \ifconfig</span><br><span class="line"></span><br><span class="line">//2.定义系统永久⽣效别名,	将命令别名添加⾄当前⽤户环境配置⽂件</span><br><span class="line">[root@dennis.com ~]$ <span class="built_in">echo</span> <span class="string">&quot;alias ifconfig=&#x27;ifconfig	eth0&#x27;&quot;</span>	&gt;&gt;	~/.bashrc</span><br><span class="line"></span><br><span class="line">//3.取消临时别名</span><br><span class="line">[root@dennis.com ~]$ <span class="built_in">unalias</span> ifconfig	</span><br></pre></td></tr></table></figure>

<h2 id="Bash特性-命令流程"><a href="#Bash特性-命令流程" class="headerlink" title="Bash特性:命令流程"></a>Bash特性:命令流程</h2><p>当我们执⾏⼀个命令, 整个命令执⾏流程如下:</p>
<ol>
<li><p>判断命令是否通过绝对路径执⾏</p>
</li>
<li><p>判断命令是否存在别名</p>
</li>
<li><p>判断⽤户输⼊的是内部命令还是外部命令</p>
</li>
<li><p>内部命令直接执⾏, 外部命令检测是否存在缓存</p>
</li>
<li><p>检测 PATH 路径, 有执⾏, ⽆报错</p>
</li>
</ol>
<blockquote>
<p>内部命令: shell程序⾃带的命令。</p>
<p>外部命令: 在系统PATH变量的某个路径下的可执⾏程序。</p>
</blockquote>
<p>使⽤ type 命令检测⽤户输⼊的命令属于内部命令还是外部命令&gt;。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//<span class="built_in">cd</span>命令属于shell内部命令</span><br><span class="line">[root@dennis.com ~]$ <span class="built_in">type</span> -a <span class="built_in">cd</span></span><br><span class="line"><span class="built_in">cd</span> is a shell <span class="built_in">builtin</span></span><br><span class="line"><span class="built_in">cd</span> is /usr/bin/<span class="built_in">cd</span></span><br><span class="line"></span><br><span class="line">//ping属于外部命令,	同时会打印当前命令路径</span><br><span class="line">[root@dennis.com ~]$ <span class="built_in">type</span> -a ping</span><br><span class="line">ping is /usr/bin/ping</span><br></pre></td></tr></table></figure>

<p>PATH 变量定义的路径, 作⽤是告诉 Bash 执⾏的外部命令存放的位置， Bash 会在这些路径中进⾏逐个扫描</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//<span class="built_in">echo</span>所⻅即所得</span><br><span class="line">[root@dennis.com ~]$ <span class="built_in">echo</span> <span class="string">&quot;123&quot;</span></span><br><span class="line">123</span><br><span class="line">[root@dennis.com ~]$ <span class="built_in">echo</span> -e <span class="string">&quot;123 \n456&quot;</span></span><br><span class="line">123 </span><br><span class="line">456</span><br><span class="line"></span><br><span class="line">//打印当前环境变量⽬录</span><br><span class="line">[root@dennis.com ~]$ <span class="built_in">echo</span> <span class="variable">$PATH</span></span><br><span class="line">/app/node/bin:/usr/<span class="built_in">local</span>/sbin:/usr/<span class="built_in">local</span>/bin:/usr/sbin:/usr/bin:/root/bin</span><br><span class="line"></span><br><span class="line">//PATH由多个路径组成，每个路径值之间⽤冒号间隔，对这些路径的增加和删除操作都将影响到Bash解释器对Linux命令的查找。</span><br><span class="line"></span><br><span class="line">//修改PATH变量</span><br><span class="line">[root@dennis.com ~]$ PATH=/soft/bin:<span class="variable">$PATH</span></span><br><span class="line">//写⼊/etc/profile配置⽂件永久⽣效</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export	PATH=/soft/bin:$PATH&#x27;</span>	&gt;&gt;	/etc/profile</span><br></pre></td></tr></table></figure>

<p>事实上执⾏过的外部命令都会保存在内存缓存中, 当再次执⾏相同的命令, 会通过缓存调取执⾏,也就意味着不会搜索 PATH 路径。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@dennis.com ~]$ <span class="built_in">hash</span></span><br><span class="line">hits	<span class="built_in">command</span></span><br><span class="line">   1	/usr/sbin/ifconfig</span><br><span class="line">   2	/usr/bin/cat</span><br><span class="line">   </span><br><span class="line">//已缓存命令,如果移动位置会导致⽆法找到该命令</span><br><span class="line">[root@dennis.com ~]$	mv	/sbin/ifconfig	/bin/</span><br><span class="line">[root@dennis.com ~]$	ifconfig</span><br><span class="line">-bash:	/sbin/ifconfig:	No	such	file	or	</span><br><span class="line"></span><br><span class="line">//删除缓存过的ifconfig命令,	即可执⾏[root@xuliangwei	~]<span class="comment">#	hash	-d	ifconfig</span></span><br><span class="line">[root@dennis.com ~]$ ifconfig</span><br><span class="line"></span><br><span class="line">//当然可以清空缓存表</span><br><span class="line">[root@dennis.com ~]$ <span class="built_in">hash</span> -r</span><br><span class="line">[root@dennis.com ~]$ <span class="built_in">hash</span> -d ifconfig</span><br><span class="line">[root@dennis.com ~]$ ifconfig</span><br><span class="line"></span><br><span class="line">//当然可以清空缓存表</span><br><span class="line">[root@dennis.com ~]$ <span class="built_in">hash</span> -r</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//命令缓存<span class="built_in">hash</span>需要注意如下情况:</span><br><span class="line">1.如果执⾏外部命令1次就会对该命令进⾏缓存</span><br><span class="line">2.如果将命令移动了位置</span><br><span class="line">				a.使⽤绝对路径执⾏</span><br><span class="line">				b.删除<span class="built_in">hash</span>表的缓存指令</span><br></pre></td></tr></table></figure>

<p>总结, 当我们执⾏了⼀个 ping 命令之后, 整个命令执⾏的流程步骤如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1.检查执⾏的是否是绝对路径执⾏</span><br><span class="line">2.检查该ping命令是否存在别名</span><br><span class="line">3.检查该ping命令是内部命令还是外部命令</span><br><span class="line">4.如果是内部指令直接执⾏, 如果是外部命令</span><br><span class="line">5.检测该命令是否有缓存,如果没有,查找PATH变量</span><br><span class="line">6.检查PATH路径直到查找到该命令然后执⾏</span><br><span class="line">7.如果没有找到该命令则返回错误。<span class="built_in">command</span> not found</span><br></pre></td></tr></table></figure>

<h2 id="Bash特性：路径展开"><a href="#Bash特性：路径展开" class="headerlink" title="Bash特性：路径展开"></a>Bash特性：路径展开</h2><p>Linux    Shell 下路径展开⽤花括号包括, 逗号分隔, 这样花括号⾥的内容会被展开形成列表。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@dennis.com ~]$ mkdir /tmp/zz/a/b /tmp/a/b -pv</span><br><span class="line">mkdir: created directory ‘/tmp/zz’</span><br><span class="line">mkdir: created directory ‘/tmp/zz/a’</span><br><span class="line">mkdir: created directory ‘/tmp/zz/a/b’</span><br><span class="line">mkdir: created directory ‘/tmp/a’</span><br><span class="line">mkdir: created directory ‘/tmp/a/b’</span><br><span class="line"></span><br><span class="line">//删除⽬录</span><br><span class="line">[root@dennis.com ~]$	rm	-rf	/tmp/&#123;zz,yy&#125;</span><br><span class="line">//通过路径展开⽅式创建⽬录</span><br><span class="line">[root@dennis.com ~]$	mkdir	/tmp/&#123;zz,yy&#125;/a/b	-pv</span><br><span class="line">mkdir:	created	directory	`/tmp/zz<span class="string">&#x27;</span></span><br><span class="line"><span class="string">mkdir:	created	directory	`/tmp/zz/a&#x27;</span></span><br><span class="line">mkdir:	created	directory	`/tmp/zz/a/b<span class="string">&#x27;</span></span><br><span class="line"><span class="string">mkdir:	created	directory	`/tmp/yy</span></span><br></pre></td></tr></table></figure>

<h2 id="Bash特性：转义字符"><a href="#Bash特性：转义字符" class="headerlink" title="Bash特性：转义字符"></a>Bash特性：转义字符</h2><p>Shell解释器提供了⾮常丰富的转义字符, 来实现字符处理以及命令替换。</p>
<p><font color='purple'><strong>四类常用转义字符</strong></font>：</p>
<ul>
<li>反斜杠（\）：使反斜杠后⾯的⼀个变量变为字符串。</li>
<li>单引号（’’）：转义其中所有的变量为单纯的字符串。</li>
<li>双引号（””）：保留其中的变量属性，不进⾏转义处理。</li>
<li>反引号（``）：把其中的命令执⾏后返回结果。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@dennis.com /]$ <span class="built_in">echo</span> <span class="string">&quot;shoping is <span class="variable">$500</span>&quot;</span></span><br><span class="line">shoping is 00</span><br><span class="line">[root@dennis.com /]$ <span class="built_in">echo</span> <span class="string">&quot;shoping is \$500&quot;</span></span><br><span class="line">shoping is <span class="variable">$500</span></span><br><span class="line"></span><br><span class="line">//转义其中特殊字符为普通字符串</span><br><span class="line">[root@dennis.com /]$ <span class="built_in">echo</span> <span class="string">&#x27;shoping is $500&#x27;</span></span><br><span class="line">shoping is <span class="variable">$500</span></span><br><span class="line"></span><br><span class="line">//使⽤$()实现命令替换</span><br><span class="line">[root@dennis.com ~]$ <span class="built_in">echo</span> <span class="string">&quot;The Directory is <span class="subst">$(pwd)</span>&quot;</span></span><br><span class="line">The Directory is /root</span><br><span class="line"></span><br><span class="line">//使⽤``实现命令替换</span><br><span class="line">[root@dennis.com ~]$ <span class="built_in">echo</span> <span class="string">&quot;The Directory is `pwd`&quot;</span></span><br><span class="line">The	Directory is /root</span><br><span class="line"></span><br><span class="line">//转义其中所有的变量为单纯的字符串</span><br><span class="line"></span><br><span class="line">[root@dennis.com ~]$ touch file-`date +%F-%H-%S`</span><br><span class="line">[root@dennis.com ~]$ ls</span><br><span class="line">file-2021-03-26-09-47</span><br><span class="line"></span><br><span class="line">[root@dennis.com ~]$ touch <span class="string">&#x27;file-`date +%F-%H-%S`&#x27;</span></span><br><span class="line">[root@dennis.com ~]$ ls</span><br><span class="line">file-2021-07-26-09-47  file-`date +%F-%H-%S`</span><br></pre></td></tr></table></figure>

<p>Bash特性：获取帮助</p>
<p>1.通过man命令获取帮助</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">⼿册的常⻅级别:	1(普通⽤户命令⼿册)	,	5(配置⽂件⼿册),	8(管理员命令⼿册) g	:	回到⼿册的顶部</span><br><span class="line">G	:	去到⽂档的底部</span><br><span class="line">/	:	输⼊要搜索的关键字,进⾏⽂档搜索</span><br><span class="line">q:	退出⽂档</span><br><span class="line">回⻋:	往下滚动⼀⾏</span><br><span class="line">空格键:	往下翻⼀⻚</span><br><span class="line">man	-a	passwd</span><br><span class="line">man		5	passwd</span><br><span class="line">man		1	passwd</span><br><span class="line">man	-k	passw		找到所有的包含passwd关键字的⼿册并且列出来</span><br></pre></td></tr></table></figure>

<p>2.通过 info 或 pinfo 获得帮助</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">⾸⻚寻找Textinfo⽂档,如果没有,强制打开对应的Man⽂档</span><br><span class="line">				与vi⻛格类似,快捷键:</span><br><span class="line">								空格:翻⻚</span><br><span class="line">								HOME:	返回⻚⾯顶部</span><br><span class="line">								END:返回⻚⾯底部</span><br><span class="line">								上箭头:	光标上移动⼀⾏</span><br><span class="line">								下箭头:	光标下移动以⾏</span><br><span class="line">								左箭头:	返回上⼀章节</span><br><span class="line">								右箭头:	浏览光标所在章节</span><br><span class="line">								d:	回到⼿册⾸⻚</span><br><span class="line">								q:	退出⼿册</span><br><span class="line">				</span><br><span class="line">强制打开指定级别的man⽂档</span><br><span class="line">$	pinfo	-m	5	passwd</span><br></pre></td></tr></table></figure>













































<script src='https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/mouse_snow.min.js'></script>

]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
      <tags>
        <tag>Bash</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux系统压缩打包</title>
    <url>/Linux%E5%9F%BA%E7%A1%80/Linux%E7%B3%BB%E7%BB%9F%E5%8E%8B%E7%BC%A9%E6%89%93%E5%8C%85/</url>
    <content><![CDATA[<p><code>windows</code> 下我们接触最多的压缩⽂件就是 .rar 格式, 但 Linux 有⾃⼰所特有的压缩⼯具。如果希望<code>windows</code>和<code>Linux</code>互相能使⽤的压缩⼯具, 建议 .zip 格式。</p>
<p>压缩的好处主要有：</p>
<ul>
<li>节省磁盘空间占用率</li>
<li>节省网络传输带宽的消耗</li>
<li>网络传输更加快捷</li>
</ul>
<h2 id="tar命令"><a href="#tar命令" class="headerlink" title="tar命令"></a>tar命令</h2><p>在 Linux 操作系统中默认自带两个原始的压缩工具分别是 <code>gzip</code> 和 <code>bzip2</code>, 但是它们都有先天的缺陷，<font color='orange'>不能打包压缩文件, 每个文件都会生成一个单独的压缩包</font>, 并且压缩之后不会保留原文件， 这是一件叔能忍婶也不能忍的事情。</p>
<p>Linux 中自带一个打包工具，叫做 <code>tar</code>, 默认情况下该工具是不能进行压缩操作的，在这种情况下 <code>tar</code> 和 <code>gzip</code>, <code>bzip2</code> 就联姻了，各自发挥各自的优势，Linux 下最强大的打包压缩工具至此诞生。</p>
<p>我们在使用 tar 进行压缩和解压缩的时候，只需要指定相对用的参数，在其内部就会调用对应的压缩工具 <code>gzip</code> 或者 <code>bzip2</code> 完成指定的操作。</p>
<h3 id="压缩-tar-gz-tar-bz2-tgz"><a href="#压缩-tar-gz-tar-bz2-tgz" class="headerlink" title="压缩 (.tar.gz .tar.bz2 .tgz)"></a>压缩 (.tar.gz .tar.bz2 .tgz)</h3><blockquote>
<p>如果使用 <code>tar</code> 完成文件压缩，涉及的参数如下，在使用过程中参数没有先后顺序:</p>
</blockquote>
<ul>
<li><code>c</code>: 创建压缩文件</li>
<li><code>z</code>: 使用 <code>gzip</code> 的方式进行文件压缩</li>
<li><code>j</code>: 使用 <code>bzip2</code> 的方式进行文件压缩</li>
<li><code>v</code>: 压缩过程中显示压缩信息，可以省略不写</li>
<li><code>f</code>: 指定压缩包的名字</li>
</ul>
<blockquote>
<p>一般认为 <code>.tgz</code> 文件就等同于 <code>.tar.gz</code> 文件，因此它们的压缩方式是相同的。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 语法: </span></span><br><span class="line">$ tar 参数 生成的压缩包的名字 要压缩的文件(文件或者目录)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 备注: 关于生成的压缩包的名字, 建议使用标准后缀, 方便识别:</span></span><br><span class="line">	- 压缩使用 gzip 方式,  标准后缀格式为: .tar.gz</span><br><span class="line">	- 压缩使用 bzip2 方式, 标准后缀格式为: .tar.bz2	</span><br></pre></td></tr></table></figure>

<blockquote>
<p>举例：使用 <code>gzip</code> 的方式进行文件压缩</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看目录内容</span></span><br><span class="line">[root@VM-8-14-centos ~/luffy]<span class="comment"># ls</span></span><br><span class="line">get  onepiece.txt  robin.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 压缩目录中所有文件, 如果要压缩某几个文件, 直接指定文件名即可</span></span><br><span class="line">[root@VM-8-14-centos ~/luffy]<span class="comment"># tar zcvf all.tar.gz *</span></span><br><span class="line">get/                     <span class="comment"># ....... 压缩信息</span></span><br><span class="line">get/link.lnk             <span class="comment"># ....... 压缩信息</span></span><br><span class="line">get/onepiece/            <span class="comment"># ....... 压缩信息</span></span><br><span class="line">get/onepiece/haha.txt</span><br><span class="line">get/link.txt</span><br><span class="line">onepiece.txt</span><br><span class="line">robin.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看目录文件, 多了一个压缩文件 all.tar.gz</span></span><br><span class="line">[root@VM-8-14-centos ~/luffy]<span class="comment"># ls</span></span><br><span class="line">all.tar.gz  get  onepiece.txt  robin.txt</span><br></pre></td></tr></table></figure>

<blockquote>
<p>举例：使用 <code>bzip2</code> 的方式进行文件压缩</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看目录内容</span></span><br><span class="line">[root@VM-8-14-centos ~/luffy]<span class="comment"># ls</span></span><br><span class="line">all.tar.gz  get  onepiece.txt  robin.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 压缩目录中除 all.tar.gz 的文件和目录</span></span><br><span class="line">[root@VM-8-14-centos ~/luffy]<span class="comment"># tar jcvf part.tar.bz2 get onepiece.txt robin.txt </span></span><br><span class="line">get/                   <span class="comment"># ....... 压缩信息</span></span><br><span class="line">get/link.lnk           <span class="comment"># ....... 压缩信息</span></span><br><span class="line">get/onepiece/          <span class="comment"># ....... 压缩信息</span></span><br><span class="line">get/onepiece/haha.txt</span><br><span class="line">get/link.txt</span><br><span class="line">onepiece.txt</span><br><span class="line">robin.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看目录信息, 多了一个压缩文件 part.tar.bz2</span></span><br><span class="line">[root@VM-8-14-centos ~/luffy]<span class="comment"># ls</span></span><br><span class="line">all.tar.gz  get  onepiece.txt  part.tar.bz2  robin.txt</span><br></pre></td></tr></table></figure>

<h2 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h2><blockquote>
<p><code>zip</code> 格式的压缩包在 Linux 中也是很常见的，在某些版本中需要安装才能使用</p>
</blockquote>
<ul>
<li><p>Ubuntu</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt install zip    	<span class="comment"># 压缩</span></span><br><span class="line">$ sudo apt install unzip	<span class="comment"># 解压缩</span></span><br></pre></td></tr></table></figure></li>
<li><p>CentOS</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 因为 centos 可以使用 root 用户登录, 基于 root 用户安装软件, 不需要加 sudo</span></span><br><span class="line">$ sudo yum install zip    	<span class="comment"># 压缩</span></span><br><span class="line">$ sudo yum install unzip	<span class="comment"># 解压缩</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>压缩(.zip)</p>
<blockquote>
<p>用 <code>zip</code> 压缩目录需要注意一点，必须要添加参数 -r, 这样才能将子目录中的文件一并压缩，如果要压缩的文件中没有目录，该参数就可以不写了。</p>
<p>另外使用 <code>zip</code> 压缩文件，会自动生成文件后缀.zip, 因此就不需要额外指定了。</p>
</blockquote>
<blockquote>
<p>举例：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看目录文件信息</span></span><br><span class="line">[root@VM-8-14-centos ~/luffy]<span class="comment"># ls</span></span><br><span class="line">get  onepiece.txt  robin.txt  temp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 压缩目录 get 和文件 onepiece.txt robin.txt 得到压缩包 all.zip(不需要指定后缀, 自动添加)</span></span><br><span class="line">[root@VM-8-14-centos ~/luffy]<span class="comment"># zip all onepiece.txt robin.txt get/ -r</span></span><br><span class="line">  adding: onepiece.txt (stored 0%)</span><br><span class="line">  adding: robin.txt (stored 0%)</span><br><span class="line">  adding: get/ (stored 0%)</span><br><span class="line">  adding: get/link.lnk (stored 0%)             <span class="comment"># 子目录中的文件也被压缩进去了</span></span><br><span class="line">  adding: get/onepiece/ (stored 0%)            <span class="comment"># 子目录中的文件也被压缩进去了</span></span><br><span class="line">  adding: get/onepiece/haha.txt (stored 0%)    <span class="comment"># 子目录中的文件也被压缩进去了</span></span><br><span class="line">  adding: get/link.txt (stored 0%)             <span class="comment"># 子目录中的文件也被压缩进去了</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 查看目录文件信息, 多了一个压缩包文件 all.zip</span></span><br><span class="line">[root@VM-8-14-centos ~/luffy]<span class="comment"># ls</span></span><br><span class="line">all.zip  get  onepiece.txt  robin.txt  temp</span><br></pre></td></tr></table></figure>

<p>解压缩（.zip）</p>
<blockquote>
<p>对应 zip 格式的文件解压缩，必须要使用 unzip 命令，和压缩的时候使用的命令是不一样的。如果压缩包中的文件要解压到指定目录需要指定参数 -d, 默认是解压缩到当前目录中。<font color='orange'><strong>unzip也可以解压java程序的war包。</strong></font></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 语法1: 解压到当前目录中 </span></span><br><span class="line">$ unzip 压缩包名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 语法: 解压到指定目录, 需要添加参数 -d</span></span><br><span class="line">$ unzip 压缩包名 -d 解压目录</span><br></pre></td></tr></table></figure>

<blockquote>
<p>举例：</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看目录文件信息</span></span><br><span class="line">[root@VM-8-14-centos ~/luffy]# ls</span><br><span class="line">all.zip  get  onepiece.txt  robin.txt  temp</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除 temp 目录中的所有文件</span></span><br><span class="line">[root@VM-8-14-centos ~/luffy]# rm temp/* -rf</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将 all.zip 解压缩到 temp 目录中</span></span><br><span class="line">[root@VM-8-14-centos ~/luffy]# unzip all.zip -d temp/</span><br><span class="line">Archive:  all.zip</span><br><span class="line"> extracting: temp/onepiece.txt           # 释放压缩的子目录中的文件            </span><br><span class="line"> extracting: temp/robin.txt              # 释放压缩的子目录中的文件            </span><br><span class="line">   creating: temp/get/</span><br><span class="line"> extracting: temp/get/link.lnk       </span><br><span class="line">   creating: temp/get/onepiece/</span><br><span class="line"> extracting: temp/get/onepiece/haha.txt  # 释放压缩的子目录中的文件</span><br><span class="line"> extracting: temp/get/link.txt      </span><br><span class="line"><span class="meta"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 temp 目录中的文件信息</span> </span><br><span class="line">[root@VM-8-14-centos ~/luffy]# ls temp/</span><br><span class="line">get  onepiece.txt  robin.txt</span><br></pre></td></tr></table></figure>

<h2 id="rar"><a href="#rar" class="headerlink" title="rar"></a>rar</h2><blockquote>
<p><code>rar</code> 这种压缩格式在 Linux 中并不常用，这是 Windows 常用的压缩格式，如果想要在 Linux 压缩和解压这种格式的文件需要额外安装对应的工具，不同版本的 Linux 安装方式也是不同的。</p>
</blockquote>
<ul>
<li><p>Ubuntu</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行在线下载命令即可</span></span><br><span class="line">$ sudo apt install rar</span><br></pre></td></tr></table></figure></li>
<li><p>CentOS</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 需要下载安装包, 官方地址: https://www.rarlab.com/download.htm</span></span><br><span class="line"><span class="comment"># 从下载页面找到 Linux 版本的下载链接并复制链接地址, 使用 wget 下载到本地</span></span><br><span class="line">$ wget https://www.rarlab.com/rar/rarlinux-x64-6.0.0.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将下载得到的 rarlinux-x64-6.0.0.tar.gz 压缩包解压缩, 得到解压目录 rar</span></span><br><span class="line">$ tar zxvf rarlinux-x64-6.0.0.tar.gz </span><br><span class="line"></span><br><span class="line"><span class="comment"># 将得到的解压目录移动到 /opt 目录中 (因为/opt软件安装目录, 移动是为了方便管理, 不移动也没事儿)</span></span><br><span class="line"><span class="comment"># 该操作需要管理员权限, 我是使用 root 用户操作的</span></span><br><span class="line">$ mv ./rar /opt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给 /opt/rar 目录中的可执行程序添加软连接, 方便命令解析器可以找到该压缩命令</span></span><br><span class="line">$ ln -s /opt/rar/rar /usr/<span class="built_in">local</span>/bin/rar</span><br><span class="line">$ ln -s /opt/rar/unrar /usr/<span class="built_in">local</span>/bin/unrar</span><br></pre></td></tr></table></figure>

<table><tr><td bgcolor=Beige>该方法在任何版本的 Linux 系统中都适用</td></tr></table></li>
</ul>
<h3 id="压缩（-rar）"><a href="#压缩（-rar）" class="headerlink" title="压缩（.rar）"></a>压缩（.rar）</h3><blockquote>
<p>使用 <code>rar</code> 压缩过程中的注意事项和 <code>zip</code> 是一样的，<code>如果压缩的是目录, 需要指定参 -r</code>, 如果只压缩文件就不需要添加了。压缩过程中需要使用参数 <code>a (archive)</code>, 压缩归档的意思。</p>
<p><code>rar</code> 工具在生成压缩包的时候也会自动添加后缀，名字为<code>.rar</code>, 因此我们只需要指定压缩包的名字。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 文件压缩, 需要使用参数 a, 压缩包名会自动添加后缀 .rar</span></span><br><span class="line"><span class="comment"># 如果压缩了目录, 需要加参数 -r</span></span><br><span class="line"><span class="comment"># 语法: </span></span><br><span class="line">$ rar a 压缩包名 要压缩的文件 [-r]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 举例</span></span><br><span class="line"><span class="comment"># 查看目录文件信息</span></span><br><span class="line">[root@VM-8-14-centos ~/luffy]<span class="comment"># ls</span></span><br><span class="line">get  onepiece.txt  robin.txt  temp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 压缩文件 onepiece.txt, robin.txt 和目录 get/ 到要是文件 all.rar 中</span></span><br><span class="line">[root@VM-8-14-centos ~/luffy]<span class="comment"># rar a all onepiece.txt get/ robin.txt -r </span></span><br><span class="line"></span><br><span class="line">RAR 6.00   Copyright (c) 1993-2020 Alexander Roshal   1 Dec 2020</span><br><span class="line">Trial version             Type <span class="string">&#x27;rar -?&#x27;</span> <span class="keyword">for</span> <span class="built_in">help</span></span><br><span class="line"></span><br><span class="line">Evaluation copy. Please register.</span><br><span class="line"></span><br><span class="line">Creating archive all.rar</span><br><span class="line"></span><br><span class="line">Adding    onepiece.txt                     OK </span><br><span class="line">Adding    get/link.lnk                     OK        <span class="comment"># 子目录中的文件也被压缩了 </span></span><br><span class="line">Adding    get/onepiece/haha.txt            OK        <span class="comment"># 子目录中的文件也被压缩了</span></span><br><span class="line">Adding    get/link.txt                     OK        <span class="comment"># 子目录中的文件也被压缩了  </span></span><br><span class="line">Adding    robin.txt                        OK </span><br><span class="line">Adding    get/onepiece                     OK         </span><br><span class="line">Done</span><br><span class="line">[root@VM-8-14-centos ~/luffy]<span class="comment"># ls</span></span><br><span class="line">all.rar  get  onepiece.txt  robin.txt  temp</span><br></pre></td></tr></table></figure>

<h3 id="解压缩（-rar）"><a href="#解压缩（-rar）" class="headerlink" title="解压缩（.rar）"></a>解压缩（.rar）</h3><blockquote>
<p>解压缩.rar 格式的文件的时候，可以使用 rar 也可以使用 unrar, 操作方式是一样的，需要添加参数 x, 默认是将压缩包内容释放到当前目录中，如果要释放到指定目录直接指定解压目录名即可，不需要使用任何参数。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 解压缩: 需要参数 x</span></span><br><span class="line"><span class="comment"># 语法: 解压缩到当前目录中</span></span><br><span class="line">$ rar/unrar x 压缩包名字</span><br><span class="line"></span><br><span class="line"><span class="comment"># 语法: 解压缩到指定目录中</span></span><br><span class="line">rar/unrar x 压缩包名字 解压目录</span><br></pre></td></tr></table></figure>

<blockquote>
<p>举例：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看目录文件信息</span></span><br><span class="line">[root@VM-8-14-centos ~/luffy]<span class="comment"># ls</span></span><br><span class="line">all.rar  get  onepiece.txt  robin.txt  temp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除 temp 目录中的所有文件</span></span><br><span class="line">[root@VM-8-14-centos ~/luffy]<span class="comment"># rm temp/* -rf</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 all.rar 中的文件解压缩到 temp 目录中</span></span><br><span class="line">[root@VM-8-14-centos ~/luffy]<span class="comment"># rar x all.rar temp/ </span></span><br><span class="line"></span><br><span class="line">RAR 6.00   Copyright (c) 1993-2020 Alexander Roshal   1 Dec 2020</span><br><span class="line">Trial version             Type <span class="string">&#x27;rar -?&#x27;</span> <span class="keyword">for</span> <span class="built_in">help</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Extracting from all.rar</span><br><span class="line"></span><br><span class="line">Extracting  temp/onepiece.txt               OK </span><br><span class="line">Creating    temp/get                        OK</span><br><span class="line">Extracting  temp/get/link.lnk               OK          <span class="comment"># 子目录文件也被释放出来了</span></span><br><span class="line">Extracting  temp/get/link.lnk               OK          <span class="comment"># 子目录文件也被释放出来了</span></span><br><span class="line">Extracting  temp/get/link.lnk               OK          <span class="comment"># 子目录文件也被释放出来了</span></span><br><span class="line">Creating    temp/get/onepiece               OK                    </span><br><span class="line">Extracting  temp/get/link.lnk               OK          <span class="comment"># 子目录文件也被释放出来了 </span></span><br><span class="line">Extracting  temp/get/link.lnk               OK          <span class="comment"># 子目录文件也被释放出来了 </span></span><br><span class="line">Extracting  temp/get/onepiece/haha.txt      OK</span><br><span class="line">Extracting  temp/get/link.txt               OK </span><br><span class="line">Extracting  temp/robin.txt                  OK </span><br><span class="line">All OK</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 temp 目录中文件信息</span></span><br><span class="line">[root@VM-8-14-centos ~/luffy]<span class="comment"># ls temp/</span></span><br><span class="line">get  onepiece.txt  robin.txt</span><br></pre></td></tr></table></figure>

<h2 id="xz"><a href="#xz" class="headerlink" title="xz"></a>xz</h2><blockquote>
<p>.xz 格式的文件压缩和解压缩都相对比较麻烦，通过一个命令是完不成对应的操作的，需要通过两步操作才行。并且操作过程中需要使用 tar 工具进行打包，压缩使用的则是 xz 工具。</p>
</blockquote>
<h3 id="压缩（-tar-xz）"><a href="#压缩（-tar-xz）" class="headerlink" title="压缩（.tar.xz）"></a>压缩（.tar.xz）</h3><blockquote>
<p>创建文件的步骤如下，首先 将需要压缩的文件打包 tar cvf xxx.tar files, 然后再对打包文件进行压缩 xz -z xxx.tar, 这样我们就可以得到一个打包之后的压缩文件了。</p>
<p>使用 xz 工具压缩文件的时候需要添加参数 -z</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 语法:</span></span><br><span class="line"><span class="comment"># 第一步</span></span><br><span class="line">$ tar cvf xxx.tar 要压缩的文件</span><br><span class="line"><span class="comment"># 第二步, 最终得到一个xxx.tar.xz 格式的压缩文件</span></span><br><span class="line">$ xz -z xxx.tar</span><br></pre></td></tr></table></figure>

<blockquote>
<p>举例：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看目录文件信息</span></span><br><span class="line">[root@VM-8-14-centos ~/luffy]<span class="comment"># ls</span></span><br><span class="line">get  onepiece.txt  robin.txt  temp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将文件 onepiece.txt, robin.txt 和目录 get 打包到 all.tar 中</span></span><br><span class="line">[root@VM-8-14-centos ~/luffy]<span class="comment"># tar cvf all.tar onepiece.txt robin.txt get/</span></span><br><span class="line">onepiece.txt</span><br><span class="line">robin.txt</span><br><span class="line">get/</span><br><span class="line">get/link.lnk</span><br><span class="line">get/onepiece/</span><br><span class="line">get/onepiece/haha.txt</span><br><span class="line">get/link.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看目录文件信息, 多了一个打包文件 all.tar</span></span><br><span class="line">[root@VM-8-14-centos ~/luffy]<span class="comment"># ls</span></span><br><span class="line">all.tar  get  onepiece.txt  robin.txt  temp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 xz 工具压缩打包文件 all.tar</span></span><br><span class="line">[root@VM-8-14-centos ~/luffy]<span class="comment"># xz -z all.tar </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 最终得到了压缩之后的打包文件 all.tar.xz</span></span><br><span class="line">[root@VM-8-14-centos ~/luffy]<span class="comment"># ls</span></span><br><span class="line">all.tar.xz  get  onepiece.txt  robin.txt  temp</span><br></pre></td></tr></table></figure>

<h3 id="解压缩（tar-xz）"><a href="#解压缩（tar-xz）" class="headerlink" title="解压缩（tar.xz）"></a>解压缩（tar.xz）</h3><blockquote>
<p>解压缩的步骤和压缩的步骤相反，需要先解压缩，然后将文件包中的文件释放出来。</p>
<p>使用 xz 工具解压需要使用参数 -d</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 语法:</span></span><br><span class="line"><span class="comment"># 第一步： 压缩包解压缩, 得到 xxx.tar</span></span><br><span class="line">$ xz -d xxx.tar.xz</span><br><span class="line"><span class="comment"># 第二步: 将 xxx.tar 中的文件释放到当前目录</span></span><br><span class="line">$ tar xvf xxx.tar 			</span><br></pre></td></tr></table></figure>

<blockquote>
<p>举例：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看目录中文件信息, 有一个 all.tar.xz</span></span><br><span class="line">[root@VM-8-14-centos ~/luffy]<span class="comment"># ls</span></span><br><span class="line">all.tar.xz  get  onepiece.txt  robin.txt  temp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 all.tar.xz 解压缩, 得到 all.tar</span></span><br><span class="line">[root@VM-8-14-centos ~/luffy]<span class="comment"># xz -d all.tar.xz </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看目录文件, 得到了 all.tar</span></span><br><span class="line">[root@VM-8-14-centos ~/luffy]<span class="comment"># ls</span></span><br><span class="line">all.tar  get  onepiece.txt  robin.txt  temp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 释放 all.tar 到当前目录</span></span><br><span class="line">[root@VM-8-14-centos ~/luffy]<span class="comment"># tar xvf all.tar </span></span><br><span class="line">onepiece.txt</span><br><span class="line">robin.txt</span><br><span class="line">get/</span><br><span class="line">get/link.lnk</span><br><span class="line">get/onepiece/</span><br><span class="line">get/onepiece/haha.txt</span><br><span class="line">get/link.txt</span><br></pre></td></tr></table></figure>

<script src='https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/mouse_snow.min.js'></script>

]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
      <tags>
        <tag>压缩</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux系统管理</title>
    <url>/Linux%E5%9F%BA%E7%A1%80/Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="系统调试"><a href="#系统调试" class="headerlink" title="系统调试"></a>系统调试</h1><span id="more"></span>
<h2 id="1-linux开机启动流程"><a href="#1-linux开机启动流程" class="headerlink" title="1. linux开机启动流程"></a>1. linux开机启动流程</h2><h3 id="1-1-centos6开机启动流程"><a href="#1-1-centos6开机启动流程" class="headerlink" title="1.1 centos6开机启动流程"></a>1.1 centos6开机启动流程</h3><p>linux启动时我们会看到许多启动信息。</p>
<p>Linux系统的启动过程并不是大家想象中的那么复杂，其过程可以分为5个阶段：</p>
<ul>
<li>内核的引导。</li>
<li>运行 init。</li>
<li>系统初始化。</li>
<li>建立终端 。</li>
<li>用户登录系统。</li>
</ul>
<p>init程序的类型：</p>
<ul>
<li><strong>SysV:</strong> init, CentOS 5之前, 配置文件： /etc/inittab。</li>
<li><strong>Upstart:</strong> init,CentOS 6, 配置文件： /etc/inittab, /etc/init/*.conf。</li>
<li><strong>Systemd：</strong> systemd, CentOS 7,配置文件： /usr/lib/systemd/system、 /etc/systemd/system。</li>
</ul>
<hr>
<h4 id="1-内核引导"><a href="#1-内核引导" class="headerlink" title="1. 内核引导"></a>1. 内核引导</h4><p> 当计算机打开电源后，首先是BIOS开机自检，按照BIOS中设置的启动设备（通常是硬盘）来启动。</p>
<p>操作系统接管硬件以后，首先读入 /boot 目录下的内核文件。</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2014/06/bg2013081702.png" alt="img"></p>
<h4 id="2-运行init"><a href="#2-运行init" class="headerlink" title="2. 运行init"></a>2. 运行init</h4><p>init 进程是系统所有进程的起点，你可以把它比拟成系统所有进程的老祖宗，没有这个进程，系统中任何进程都不会启动。</p>
<p>init 程序首先是需要读取配置文件 /etc/inittab。</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2014/06/bg2013081703.png" alt="img"></p>
<h4 id="3-运行级别"><a href="#3-运行级别" class="headerlink" title="3. 运行级别"></a>3. 运行级别</h4><p>许多程序需要开机启动。它们在Windows叫做”服务”（service），在Linux就叫做”守护进程”（daemon）。</p>
<p>init进程的一大任务，就是去运行这些开机启动的程序。</p>
<p>但是，不同的场合需要启动不同的程序，比如用作服务器时，需要启动Apache，用作桌面就不需要。</p>
<p>Linux允许为不同的场合，分配不同的开机启动程序，这就叫做”运行级别”（runlevel）。也就是说，启动时根据”运行级别”，确定要运行哪些程序。</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2014/06/bg2013081704.png" alt="img"></p>
<h4 id="4-系统初始化"><a href="#4-系统初始化" class="headerlink" title="4. 系统初始化"></a>4. 系统初始化</h4><p>在init的配置文件中有这么一行： si::sysinit:/etc/rc.d/rc.sysinit　它调用执行了/etc/rc.d/rc.sysinit，而rc.sysinit是一个bash shell的脚本，它主要是完成一些系统初始化的工作，rc.sysinit是每一个运行级别都要首先运行的重要脚本。</p>
<p>它主要完成的工作有：激活交换分区，检查磁盘，加载硬件模块以及其它一些需要优先执行任务。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">l5:5:wait:/etc/rc.d/rc 5</span><br><span class="line">这一行表示以5为参数运行/etc/rc.d/rc，/etc/rc.d/rc是一个Shell脚本，它接受5作为参数，去执行/etc/rc.d/rc5.d/目录下的所有的rc启动脚本，/etc/rc.d/rc5.d/目录中的这些启动脚本实际上都是一些连接文件，而不是真正的rc启动脚本，真正的rc启动脚本实际上都是放在/etc/rc.d/init.d/目录下。</span><br><span class="line">而这些rc启动脚本有着类似的用法，它们一般能接受start、stop、restart、status等参数。</span><br><span class="line">/etc/rc.d/rc5.d/中的rc启动脚本通常是K或S开头的连接文件，对于以 S 开头的启动脚本，将以start参数来运行。</span><br><span class="line">而如果发现存在相应的脚本也存在K打头的连接，而且已经处于运行态了(以/var/lock/subsys/下的文件作为标志)，则将首先以stop为参数停止这些已经启动了的守护进程，然后再重新运行。</span><br><span class="line">这样做是为了保证是当init改变运行级别时，所有相关的守护进程都将重启。</span><br><span class="line">至于在每个运行级中将运行哪些守护进程，用户可以通过chkconfig或setup中的&quot;System Services&quot;来自行设定。</span><br></pre></td></tr></table></figure>

<p><img src="https://www.runoob.com/wp-content/uploads/2014/06/bg2013081705.png" alt="img"></p>
<h4 id="5-建立终端"><a href="#5-建立终端" class="headerlink" title="5. 建立终端"></a>5. 建立终端</h4><p>rc执行完毕后，返回init。这时基本系统环境已经设置好了，各种守护进程也已经启动了。</p>
<p>init接下来会打开6个终端，以便用户登录系统。在inittab中的以下6行就是定义了6个终端：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1:2345:respawn:/sbin/mingetty tty1</span><br><span class="line">2:2345:respawn:/sbin/mingetty tty2</span><br><span class="line">3:2345:respawn:/sbin/mingetty tty3</span><br><span class="line">4:2345:respawn:/sbin/mingetty tty4</span><br><span class="line">5:2345:respawn:/sbin/mingetty tty5</span><br><span class="line">6:2345:respawn:/sbin/mingetty tty6</span><br></pre></td></tr></table></figure>

<p>从上面可以看出在2、3、4、5的运行级别中都将以respawn方式运行mingetty程序，mingetty程序能打开终端、设置模式。</p>
<p>同时它会显示一个文本登录界面，这个界面就是我们经常看到的登录界面，在这个登录界面中会提示用户输入用户名，而用户输入的用户将作为参数传给login程序来验证用户的身份。</p>
<h4 id="6-用户登录系统"><a href="#6-用户登录系统" class="headerlink" title="6. 用户登录系统"></a>6. 用户登录系统</h4><p>一般来说，用户的登录方式有三种：</p>
<ul>
<li>（1）命令行登录</li>
<li>（2）ssh登录</li>
<li>（3）图形界面登录</li>
</ul>
<p><img src="https://www.runoob.com/wp-content/uploads/2014/06/bg2013081706.png" alt="img"></p>
<hr>
<h3 id="1-2-centos7开机启动流程"><a href="#1-2-centos7开机启动流程" class="headerlink" title="1.2 centos7开机启动流程"></a>1.2 centos7开机启动流程</h3><h4 id="1-开机自检"><a href="#1-开机自检" class="headerlink" title="1. 开机自检"></a>1. 开机自检</h4><h4 id="2-MBR-GPT引导系统启动"><a href="#2-MBR-GPT引导系统启动" class="headerlink" title="2. MBR/GPT引导系统启动"></a>2. MBR/GPT引导系统启动</h4><h4 id="3-加载GRUB2菜单"><a href="#3-加载GRUB2菜单" class="headerlink" title="3. 加载GRUB2菜单"></a>3. 加载GRUB2菜单</h4><p>（选择内核版本）</p>
<h4 id="4-加载内核选项"><a href="#4-加载内核选项" class="headerlink" title="4. 加载内核选项"></a>4. 加载内核选项</h4><h4 id="5-内核初始化使用systemd进程"><a href="#5-内核初始化使用systemd进程" class="headerlink" title="5. 内核初始化使用systemd进程"></a>5. 内核初始化使用<em>systemd</em>进程</h4><p>（启动的linux系统的第一个进程systemd）</p>
<h4 id="6-读取运行级别"><a href="#6-读取运行级别" class="headerlink" title="6. 读取运行级别"></a>6. 读取运行级别</h4><p>(桌面模式,命令模式)(/etc/systemd/system/default.target)</p>
<h4 id="7-初始化系统"><a href="#7-初始化系统" class="headerlink" title="7. 初始化系统"></a>7. 初始化系统</h4><p>(/usr/lib/systemd/system/sysinit.target)（挂载，启动网络，主机名……）</p>
<h4 id="8-根据运行级-别、并行启动服务"><a href="#8-根据运行级-别、并行启动服务" class="headerlink" title="8. 根据运行级 别、并行启动服务"></a>8. 根据运行级 别、并行启动服务</h4><p>(网络服务，ssh服务，定时任务……)</p>
<h4 id="9-显示login界面-输入用户和密码"><a href="#9-显示login界面-输入用户和密码" class="headerlink" title="9. 显示login界面 (输入用户和密码)"></a>9. 显示<em>login</em>界面 (输入用户和密码)</h4><p>(/usr/lib/systemd/system/getty.target)</p>
<hr>
<h2 id="2-linux关机相关操作"><a href="#2-linux关机相关操作" class="headerlink" title="2. linux关机相关操作"></a>2. linux关机相关操作</h2><h4 id="2-1-shutdown"><a href="#2-1-shutdown" class="headerlink" title="2.1 shutdown"></a>2.1 shutdown</h4><p>shutdown 会给系统计划一个时间关机。它可以被用于停止、关机、重启机器。shutdown 会给系统计划一个时间关机。它可以被用于停止、关机、重启机器。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shutdown -p now  ### 关闭机器</span><br><span class="line">shutdown -H now  ### 停止机器      </span><br><span class="line">shutdown -r 09:35 ### 在 09:35am 重启机器</span><br></pre></td></tr></table></figure>

<p>要取消即将进行的关机，只要输入下面的命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shutdown -c</span><br></pre></td></tr></table></figure>

<h4 id="2-2-halt"><a href="#2-2-halt" class="headerlink" title="2.2 halt"></a>2.2 halt</h4><p>halt 命令通知硬件来停止所有的 CPU 功能，但是仍然保持通电。你可以用它使系统处于低层维护状态。注意在有些情况会它会完全关闭系统。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">halt             ### 停止机器</span><br><span class="line">halt -p          ### 关闭机器、关闭电源</span><br><span class="line">halt --reboot    ### 重启机器</span><br></pre></td></tr></table></figure>

<h4 id="2-3-poweroff"><a href="#2-3-poweroff" class="headerlink" title="2.3 poweroff"></a>2.3 poweroff</h4><p>poweroff 会发送一个 ACPI 信号来通知系统关机。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">poweroff           ### 关闭机器、关闭电源</span><br><span class="line">poweroff --halt    ### 停止机器</span><br><span class="line">poweroff --reboot  ### 重启机器</span><br></pre></td></tr></table></figure>

<h4 id="2-4-reboot"><a href="#2-4-reboot" class="headerlink" title="2.4 reboot"></a>2.4 reboot</h4><p>reboot 命令 reboot 通知系统重启。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">reboot           ### 重启机器</span><br><span class="line">reboot --halt    ### 停止机器</span><br><span class="line">reboot -p        ### 关闭机器</span><br></pre></td></tr></table></figure>

<h2 id="3-linux系统运行级别"><a href="#3-linux系统运行级别" class="headerlink" title="3. linux系统运行级别"></a>3. linux系统运行级别</h2><h4 id="3-1-centos6"><a href="#3-1-centos6" class="headerlink" title="3.1 centos6"></a>3.1 centos6</h4><p>Linux系统有7个运行级别(runlevel)：</p>
<ul>
<li>运行级别0：系统停机状态，系统默认运行级别不能设为0，否则不能正常启动</li>
<li>运行级别1：单用户工作状态，root权限，用于系统维护，禁止远程登陆</li>
<li>运行级别2：多用户状态(没有NFS)</li>
<li>运行级别3：完全的多用户状态(有NFS)，登陆后进入控制台命令行模式</li>
<li>运行级别4：系统未使用，保留</li>
<li>运行级别5：X11控制台，登陆后进入图形GUI模式</li>
<li>运行级别6：系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动</li>
</ul>
<h4 id="3-2-centos7"><a href="#3-2-centos7" class="headerlink" title="3.2 centos7"></a>3.2 centos7</h4><ul>
<li>运行级别0：系统停机状态，系统默认运行级别不能设为0，否则不能正常启动</li>
<li>运行级别1：救援模式，root权限，用于系统维护，禁止远程登陆</li>
<li>运行级别2：多用户状态</li>
<li>运行级别3：多用户状态</li>
<li>运行级别4：多用户状态</li>
<li>运行级别5：X11控制台，登陆后进入图形GUI模式</li>
<li>运行级别6：系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">centos6系统</span></span><br><span class="line">runlevel #查看运行级别</span><br><span class="line">N 3 #如果N是其他数字,代表上一次运行级别</span><br><span class="line">init 3   #切换运行级别</span><br><span class="line">/etc/inittab #永久修改运行级别存放的配置文件</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">centos7系统</span></span><br><span class="line">systemctl get-default #查看系统默认启动运行级别</span><br><span class="line">systemctl set-default TARGET.target   #</span><br><span class="line">修改默认启动运行级别（永久生效）</span><br><span class="line">multi-user.target: analogous to runlevel 3</span><br><span class="line">graphical.target: analogous to runlevel 5</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-系统的systemd"><a href="#4-系统的systemd" class="headerlink" title="4.系统的systemd"></a>4.系统的systemd</h2><ul>
<li><p>什么是关闭/开启<strong>正在运行</strong>的服务/软件 systemctl stop/start sshd</p>
</li>
<li><p>什么是关闭/开启 <strong>开机自启动</strong>项 ?? systemctl disable/enable sshd</p>
</li>
</ul>
<h4 id="1-systemd的由来"><a href="#1-systemd的由来" class="headerlink" title="1.systemd的由来"></a><strong><em>1.systemd</em>的由来</strong></h4><p><em>Linux</em>一直以来都是采用<em>init</em>进程作为祖宗进程，但是<em>init</em>有两个缺点： </p>
<p><em>1</em>、<strong>启动时间长</strong>。<em>Init</em>进程是串行启动，只有前一个进程启动完，才会启动下一 </p>
<p>个进程。 </p>
<p><em>2</em>、<strong>启动脚本复杂</strong>，初始化完成后系统会加载很多脚本，脚本都会处理各自的 </p>
<p>情况，这会让脚本多而复杂。 </p>
<p><em>Centos5</em> 是启动速度最慢的，串行启动过程，无论进程相互之间有无依赖关系。</p>
<p><em>Centos6</em> 相对启动速度有所改进。有依赖的进程之间依次启动而其他与之没有依赖关系的则并行同步启动。</p>
<p><em>Centos7</em> 所有进程无论有无依赖关系则都是并行启动（当然很多时候进程没有真正启动而是只有一个信号或者说是标记而已，在真正利用的时候才会真正启 动）</p>
<img src="../AppData/Roaming/Typora/typora-user-images/image-20210406205736481.png" alt="image-20210406205736481" style="zoom: 80%;" />



<h4 id="2-什么是systemd"><a href="#2-什么是systemd" class="headerlink" title="2.什么是systemd"></a><strong>2.什么是systemd</strong></h4><p><em>systemd</em>即为<strong>system daemon</strong>守护进程，<em>systemd</em>主要解决上文的问题而诞 </p>
<p>生，<em>systemd</em>的目标是，为系统的启动和管理提供一套完整的解决方案。</p>
<p><strong>3.systemd的优势</strong></p>
<p><em>1</em>、最新系统都采用<em>systemd</em>管理（<em>RedHat7,CentOS7,Ubuntu15</em>等） <em>systemctl</em> </p>
<p><em>2</em>、<em>Centos7</em>支持开机并行启动服务，显著提高开机启动效率。 </p>
<p><em>3</em>、<em>Centos7</em>关机只关闭正在运行的服务，而<em>Centos6</em>全部都关闭一次。 </p>
<p><em>4</em>、<em>Centos7</em>服务的启动与停止不在使用脚本进行管理*,C7<em>下面都是配置</em>(/usr/lib/systemd/system/xxxx.service)<em>，也就是</em>/etc/init.d(CentOS 6)*下不在有脚 </p>
<p>本。</p>
<p><em>5</em>、<em>Centos7</em>使用<em>systemd</em>解决原有模式缺陷，比如原有<em>service</em>不会关闭程序产生的子进程。</p>
<h4 id="3-systemd相关配置文件"><a href="#3-systemd相关配置文件" class="headerlink" title="3.systemd相关配置文件"></a><strong>3.systemd相关配置文件</strong></h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/usr/lib/systemd/system/ #记录这一个就</span><br><span class="line">ok. 类似Centos6系统的启动脚本，/etc/init.d/</span><br><span class="line">/etc/systemd/system/    #系统配置存放,了解         </span><br><span class="line">\#类似Centos6系统的/etc/rc.d/rcN.d/</span><br><span class="line">/etc/systemd/system/multi-user.target.wants/*  #系统配置存放,了解</span><br></pre></td></tr></table></figure>

<h4 id="4-systemd管理服务相关命令"><a href="#4-systemd管理服务相关命令" class="headerlink" title="4.systemd管理服务相关命令"></a><strong>4.systemd管理服务相关命令</strong></h4><ul>
<li><em>systemctl</em>管理服务的启动、重启、停止、重载、查看状态等常用命令</li>
</ul>
<table>
<thead>
<tr>
<th>System Vinit（6系统）</th>
<th>systemctl命令（7系统）</th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td>service crond start   <br>/etc/init.dcrond start</td>
<td>systemctl start crond.service</td>
<td>启动服务当前运行</td>
</tr>
<tr>
<td>service crond stop</td>
<td>systemctl stop crond.service</td>
<td>停止服务</td>
</tr>
<tr>
<td>service crond restart</td>
<td>systemctl restart crond.service</td>
<td>重启服务</td>
</tr>
<tr>
<td>service crond reload</td>
<td>systemctl reload crond.service</td>
<td>优雅的重启重新加载配置<br>(不终止服务，不影响正在处理的请求的用户)</td>
</tr>
<tr>
<td>service crond status</td>
<td>systemctl status crond.service</td>
<td>查看服务运行状态</td>
</tr>
<tr>
<td></td>
<td>systemctl is-active crond.service</td>
<td>查看服务是否在运行中</td>
</tr>
<tr>
<td></td>
<td>systemctl mask  crond.service</td>
<td>禁止服务运行</td>
</tr>
<tr>
<td></td>
<td>systemctl unmask crond.service</td>
<td>取消禁止服务运行</td>
</tr>
</tbody></table>
<ul>
<li>systemctl 设置服务<strong>开机启动</strong>、不启动、查看各级别下服务启动状态等常用命令</li>
</ul>
<table>
<thead>
<tr>
<th>System Vinit（6系统）</th>
<th>systemctl命令（7系统）</th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td>chkconfig crond on</td>
<td>systemctl <strong>enable</strong> crond.service</td>
<td>开机自动启动</td>
</tr>
<tr>
<td>chkconfig crond off</td>
<td>systemctl disable crond.service</td>
<td>关闭开机自启动</td>
</tr>
<tr>
<td>chkconfig –list</td>
<td>systemctl list-unit-files</td>
<td>查看各个级别下服务的<br>启动与禁用</td>
</tr>
<tr>
<td>chkconfig –list crond</td>
<td>systemctl is-enabled crond.service</td>
<td>产看指定服务是否为开机自启动</td>
</tr>
<tr>
<td>chkconfig –add crond</td>
<td>systemctl daemon-reload</td>
<td>创建新服务文件或者变设置</td>
</tr>
</tbody></table>
<ul>
<li>systemctl 服务状态说明</li>
</ul>
<table>
<thead>
<tr>
<th><strong>服务状态</strong></th>
<th><strong>状态说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>loaded</td>
<td>服务单元的配置文件已经被处理, 配置放在了/usr/lib/systemd/system/</td>
</tr>
<tr>
<td>active(running)</td>
<td>服务的一个或多个进程在运行中 最常见的状态 start</td>
</tr>
<tr>
<td>active(exited)</td>
<td><strong>一次性</strong>运行的服务成功被执行并退出(服务运行后完成任务,相关进程会自动退出)</td>
</tr>
<tr>
<td>active(waiting)</td>
<td>服务已经运行但在等待某个事件</td>
</tr>
<tr>
<td>inactive</td>
<td>服务没有在运行 stop</td>
</tr>
<tr>
<td>enabled</td>
<td>服务设定为开机运行</td>
</tr>
<tr>
<td>disabled</td>
<td>服务设定为开机不运行</td>
</tr>
<tr>
<td>static</td>
<td>服务不能被设定开机启动,但可以由其他服务启动该服务</td>
</tr>
</tbody></table>
<ul>
<li><em>systemctl</em>的<em>journalctl</em>日志 </li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">服务启动或管理,排错流程</span></span><br><span class="line">systemctl 启动/重启/关闭 服务失败,报错   </span><br><span class="line">journalctl -xe   #-e按页显示   -x进行一些翻译,指出一些故障提示</span><br><span class="line">找error 或 err 或warn 或fail </span><br><span class="line">故障模拟 修改网卡配置文件, IPADDR</span><br><span class="line"></span><br><span class="line">journalctl -n 20    #查看最后20行</span><br><span class="line">journalctl -f       #动态查看日志 ※※※</span><br><span class="line">journalctl -p err   #查看日志的级别</span><br><span class="line">journalctl -u crond #查看某个服务的单元的日志</span><br></pre></td></tr></table></figure>

<p> “auto_save_delay_in_seconds”: 0.15,</p>
<p>netstat -tupln | grep id 查看进程端口</p>
]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
      <tags>
        <tag>system</tag>
      </tags>
  </entry>
  <entry>
    <title>docker镜像常用命令</title>
    <url>/%E4%BA%91%E8%AE%A1%E7%AE%97/docker%E9%95%9C%E5%83%8F%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="一-docker常用命令概述"><a href="#一-docker常用命令概述" class="headerlink" title="一.docker常用命令概述"></a>一.docker常用命令概述</h1><h2 id="1-docker命令的使用方法"><a href="#1-docker命令的使用方法" class="headerlink" title="1.docker命令的使用方法"></a>1.docker命令的使用方法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如下图所示，对应的是docker命令的使用方法。</span><br><span class="line"></span><br><span class="line">root@docker201.oldboyedu.com ~]# docker</span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/WEBa1b09cd4e8367cff954da5894fd62145?method=download&shareKey=b79e77e15aae2b5c0eb95265453925bf" alt="image-20210609213405422"></p>
<h2 id="2-查看docker子命令的帮助信息"><a href="#2-查看docker子命令的帮助信息" class="headerlink" title="2.查看docker子命令的帮助信息"></a>2.查看docker子命令的帮助信息</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如下图所示，我们可以查看docker命令的帮助信息哟~</span><br><span class="line"></span><br><span class="line">root@docker201.oldboyedu.com ~]# docker search --help</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/WEB6e05b6635d195f21b94e1d8f640d1cb7?method=download&shareKey=974002314d9cfbb8263faf9e53cf84d0" alt="image-20210609214340268"></p>
<h2 id="3-镜像管理命令概述"><a href="#3-镜像管理命令概述" class="headerlink" title="3.镜像管理命令概述"></a>3.镜像管理命令概述</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如下图所示，不难发现&quot;docker image ls&quot;和&quot;docker images&quot;的效果是一样的。&quot;docker image pull&quot;和&quot;docker pull&quot;效果是相同的。</span><br><span class="line"></span><br><span class="line">后者是较老docker版本者的使用习惯，有关镜像管理命令由于历史性原因保留了两种用法。</span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/WEBb0e3f973d439eba1eef3db8cfb1062cb?method=download&shareKey=23f3fb4eff247598f7b54f8a47ebfcdc" alt="image-20210609223402204"></p>
<h1 id="二-生产环境中常用的-docker镜像相关指令"><a href="#二-生产环境中常用的-docker镜像相关指令" class="headerlink" title="二.生产环境中常用的 docker镜像相关指令"></a>二.生产环境中常用的 docker镜像相关指令</h1><h2 id="1-搜索docker镜像-search"><a href="#1-搜索docker镜像-search" class="headerlink" title="1.搜索docker镜像(search)"></a>1.搜索docker镜像(search)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@docker201.oldboyedu.com ~]# docker search mysql</span><br><span class="line"></span><br><span class="line">[root@docker201.oldboyedu.com ~]# docker search mysql --limit 5</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">搜索效果如下图所示，其提供了五个字段，分别代表的含义解释如下:</span><br><span class="line">	NAME:</span><br><span class="line">		镜像的名称。</span><br><span class="line">	</span><br><span class="line">	DESCRIPTION:</span><br><span class="line">    	镜像的描述信息。</span><br><span class="line">    	</span><br><span class="line">    STARS:</span><br><span class="line">    	镜像的星星数量，星星越多，说明受欢迎度越高哟~</span><br><span class="line">    	</span><br><span class="line">    OFFICIAL:</span><br><span class="line">    	该镜像是否是官方发布。</span><br><span class="line">    	</span><br><span class="line">    AUTOMATED</span><br><span class="line">		该镜像是否支持支持自动化构建功能。</span><br><span class="line">		</span><br><span class="line">温馨提示:</span><br><span class="line">	(1)选镜像时建议优先考虑官方(OFFICIAL)和星星(STARS)数量较多的镜像，官方镜像仓库地址如下所示:</span><br><span class="line">	hub.docker.com</span><br><span class="line">	(2)关于自动化构建，此处建议先战略性跳过，感兴趣的小伙伴可参考以下连接哟;</span><br><span class="line">	https://docs.docker.com/docker-hub/builds/</span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/WEBaaa2c96612a58cef5deb98e155635c7f?method=download&shareKey=f1c2441038068a631fd4a29b68fd9040" alt="image-20210609215802087"></p>
<h2 id="2-下载镜像-pull"><a href="#2-下载镜像-pull" class="headerlink" title="2.下载镜像(pull)"></a>2.下载镜像(pull)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@docker201.oldboyedu.com ~]# docker pull nginx:1.20.1</span><br><span class="line"></span><br><span class="line">[root@docker201.oldboyedu.com ~]# docker pull nginx</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/WEBfce8b97916ed696de7356e76ee0bc9d3?method=download&shareKey=12be685d09ee3c80a504e63e14650a8a" alt="image-20210609222829366"></p>
<h2 id="3-上传镜像-push，先战略性跳过"><a href="#3-上传镜像-push，先战略性跳过" class="headerlink" title="3.上传镜像(push，先战略性跳过)"></a>3.上传镜像(push，先战略性跳过)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在后面构建镜像仓库的时候讲解，此处战略性跳过。</span><br></pre></td></tr></table></figure>



<h2 id="4-查看本地镜像列表-ls"><a href="#4-查看本地镜像列表-ls" class="headerlink" title="4.查看本地镜像列表(ls)"></a>4.查看本地镜像列表(ls)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@docker201.oldboyedu.com ~]# docker images</span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/WEB83aa1364dcf8b67a47486ce846338194?method=download&shareKey=feeeb9254f51a80eecdab20ee3184217" alt="image-20210609224007741"></p>
<h2 id="5-导出镜像-save"><a href="#5-导出镜像-save" class="headerlink" title="5.导出镜像(save)"></a>5.导出镜像(save)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@docker201.oldboyedu.com ~]# docker save nginx:1.20.1 -o oldboyedu_docker_nginx.tar.gz</span><br><span class="line"></span><br><span class="line">温馨提示:</span><br><span class="line">	如下图所示，我们可以基于镜像的ID从而导出指定的镜像。我不推荐这样做，因为导入镜像的时候会发现镜像名称和其版本号均为&quot;&lt;none&gt;&quot;</span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/WEB792460399beee2a5e441a474626151e3?method=download&shareKey=7a1a43b230e1e236e9dea135ec6216bf" alt="image-20210609224811160"></p>
<h2 id="6-删除镜像-rm"><a href="#6-删除镜像-rm" class="headerlink" title="6.删除镜像(rm)"></a>6.删除镜像(rm)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@docker201.oldboyedu.com ~]# docker rmi 993ef3592f66温馨提示:	(1)我们可以基于镜像的ID来删除指定的镜像文件，当然，也可以基于镜像名称和TAG编号一起删除;	(2)很明显&quot;docker image rm&quot;有&quot;docker rmi&quot;,&quot;docker remove&quot;多个别名哟;	(3)使用&quot;docker rm&quot;删除的是容器哟，而非镜像;	(4)想要批量删除镜像，可以先停止docker服务，然后将&quot;/var/lib/docker/*&quot;目录全部删除，这意味着对docker进行初始化操作，因为它意味着删除了所有数据，该操作是不可逆的。</span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/WEB626ccb680756386d7f9c08e5e912cc2c?method=download&shareKey=a0517324a685e303c0b3b8051d85bc80" alt="image-20210609231702768"></p>
<h2 id="7-导入镜像-load"><a href="#7-导入镜像-load" class="headerlink" title="7.导入镜像(load)"></a>7.导入镜像(load)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@docker201.oldboyedu.com ~]# docker image load -i oldboyedu_docker_nginx.tar.gz </span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/WEB98eda67f056a6b51e47dfa1f93ac94da?method=download&shareKey=90dca910bd88fe01bf9e7b358c29b1d5" alt="image-20210609232131913"></p>
<h2 id="8-导入镜像-import"><a href="#8-导入镜像-import" class="headerlink" title="8.导入镜像(import)"></a>8.导入镜像(import)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如下图所示，使用import指令也可以导入镜像，但都没有名字哟~	请先允许我买个关子哈，后面给大家介绍一下它的妙用哟！</span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/WEBc3f8a54d9320315c7f7ff5c5442baa72?method=download&shareKey=c23168b37d24ef706578dfd95065874d" alt="image-20210609234235462"></p>
<h2 id="9-打标签-tag"><a href="#9-打标签-tag" class="headerlink" title="9.打标签(tag)"></a>9.打标签(tag)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如下图所示，我们可以为一个镜像打多个标签哟~</span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/WEBb4cfc8c013b11809d5b2cafd8f768f76?method=download&shareKey=bbf931b6eaf86df870c85747556a1945" alt="image-20210610000547806"></p>
<h2 id="10-清除无效镜像-prune"><a href="#10-清除无效镜像-prune" class="headerlink" title="10.清除无效镜像(prune)"></a>10.清除无效镜像(prune)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如下图所示，我们可以清理无效的镜像。所谓的无效的镜像我们指的就是没有镜像名称和标签的。</span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/WEBdd07e56007d4e20ed0796223213c22fb?method=download&shareKey=e5b489a02a2be0070d56640c9ae3145d" alt="image-20210610000922663"></p>
<h2 id="11-构建镜像-build，战略性跳过"><a href="#11-构建镜像-build，战略性跳过" class="headerlink" title="11.构建镜像(build，战略性跳过)"></a>11.构建镜像(build，战略性跳过)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker image build -t oldboyedu_dockerfile_xiaoniao:v1 .</span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/WEB14a2c2d450069aa8557b4d4651cde152?method=download&shareKey=291fdf5664cded2e6a4545140031da07" alt="image-20210616224136999"></p>
<h2 id="12-查看构建历史-history，战略性跳过"><a href="#12-查看构建历史-history，战略性跳过" class="headerlink" title="12.查看构建历史(history，战略性跳过)"></a>12.查看构建历史(history，战略性跳过)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker image history centos:7 --no-trunc</span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/WEBf9169889087fb0b58b1b2bb4758b31fd?method=download&shareKey=0279059f27439fce1252af6baf0740cc" alt="image-20210616235412627"></p>
<h2 id="13-查看镜像属性-inspect，战略性跳过"><a href="#13-查看镜像属性-inspect，战略性跳过" class="headerlink" title="13.查看镜像属性(inspect，战略性跳过)"></a>13.查看镜像属性(inspect，战略性跳过)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">后期会补，此处先跳过。</span><br></pre></td></tr></table></figure>

<h1 id="三-课堂练习"><a href="#三-课堂练习" class="headerlink" title="三.课堂练习"></a>三.课堂练习</h1><h2 id="1-批量导入镜像"><a href="#1-批量导入镜像" class="headerlink" title="1.批量导入镜像"></a>1.批量导入镜像</h2><h3 id="请批量导入镜像"><a href="#请批量导入镜像" class="headerlink" title="请批量导入镜像"></a>请批量导入镜像</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如下图所示，以oldboyedu开头的都是我提前打包好的镜像，请批量完成打包操作。</span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/WEBc318f490aef27748b0be3970515c13c8?method=download&shareKey=52bf1d33ba0e9668d5f9254505cb768e" alt="image-20210610004039213"></p>
<h3 id="参考案例"><a href="#参考案例" class="headerlink" title="参考案例"></a>参考案例</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@docker201.oldboyedu.com ~]# for image in `ls *.tar.gz`; do docker load -i $image; done</span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/WEB4bc9b0ac34f5e1893979ba4e6d8b29e5?method=download&shareKey=d32997c9e0e92f62c48a6903272c54c6" alt="image-20210610004612153"></p>
<h2 id="2-批量导出镜像"><a href="#2-批量导出镜像" class="headerlink" title="2.批量导出镜像"></a>2.批量导出镜像</h2><h3 id="请批量导出镜像"><a href="#请批量导出镜像" class="headerlink" title="请批量导出镜像"></a>请批量导出镜像</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">请将上述案例的&quot;nginx:latest&quot;和&quot;mysql:latest&quot;两个软件包打包到同一个文件中。</span><br></pre></td></tr></table></figure>



<h3 id="参考案例-1"><a href="#参考案例-1" class="headerlink" title="参考案例"></a>参考案例</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@docker201.oldboyedu.com ~]# docker save -o oldboyedu_docker_demo.tar.gz nginx:latest mysql:latest</span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/WEB0ff6f2fc014e3a2bc9392b49102d81d5?method=download&shareKey=6869c3f127ec541ab17f846906f263a4" alt="image-20210610005328968"></p>
]]></content>
      <categories>
        <category>云计算</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>定时任务</title>
    <url>/Linux%E5%9F%BA%E7%A1%80/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</url>
    <content><![CDATA[<h1 id="Linux定时任务"><a href="#Linux定时任务" class="headerlink" title="Linux定时任务"></a>Linux定时任务</h1><h2 id="定时任务基本概述"><a href="#定时任务基本概述" class="headerlink" title="定时任务基本概述"></a>定时任务基本概述</h2><ul>
<li><p>crond简介</p>
<p>Linux系统上面有很多计划性的工作，比如在某个时间点需要执行某个动作，在Linux中，一般使用crontab命令来实现控制计划任务，通过crontab 命令，我们可以在固定的间隔时间执行指定的系统指令或 shell script脚本。时间间隔的单位可以是分钟、小时、日、月、周及以上的任意组合。这个命令非常设合周期性的日志分析或数据备份等工作。crontab命令是基于crond这个系统服务的，crond服务是安装Linux系统时自动安装的，它会检查当前系统中是否有要执行的任务。</p>
<p>Crond服务会定期（默认每分钟检查一次）检查系统中是否有要执行的任务工作，如果有，便会根据其预先设定的定时任务规则自动执行该定时任务工作，这个crond定时任务服务就相当于我们平时早起使用的闹钟一样。</p>
</li>
<li><p>Linux下的任务调度分为系统层面的任务调度和用户自定义的任务调度。</p>
</li>
</ul>
<ol>
<li><p><strong>系统级别的定时任务</strong></p>
<p>比如写缓存数据到硬盘、临时文件清理、系统信息采集、日志文件切割。</p>
<p>在/etc目录下有一个crontab文件，这个就是系统任务调度的配置文件。打开/etc目录，我们可以看到有很多cron相关的目录，如下：    </p>
<img src="AppData/Roaming/Typora/typora-user-images/image-20210413155628596.png" alt="image-20210413155628596" style="zoom:150%;" />

<p>cron.deny表示该文件中所列的用户不允许使用crontab命令;</p>
<p>cron.daily表示每天都要按照计划完成的任务；</p>
<p>cron.hourly表示每个小时都要按照计划完成的任务；</p>
<p>cron.weekly表示每个小时都要按照计划完成的任务；</p>
</li>
<li><p><strong>用户级别的定时任务</strong></p>
<p>定时向互联网同步时间、定时备份系统配置文件、定时备份数据库的数据。</p>
<p>*/var/spool/cron/*目录是所有crontab文件存放的目录，以用户名命名</p>
<p>如centos7.9下：/var/spool/cron/root </p>
</li>
</ol>
<hr>
<h2 id="crontab配置文件"><a href="#crontab配置文件" class="headerlink" title="crontab配置文件"></a>crontab配置文件</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/crontab</span><br><span class="line">SHELL=/bin/bash</span><br><span class="line">PATH=/sbin:/bin:/usr/sbin:/usr/bin</span><br><span class="line">MAILTO=root</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> For details see man 4 crontabs</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Example of job definition:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> .---------------- minute (0 - 59)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> |  .------------- hour (0 - 23)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> |  |  .---------- day of month (1 - 31)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> |  |  |  |  |</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> *  *  *  *  * user-name  <span class="built_in">command</span> to be executed</span></span><br><span class="line"></span><br><span class="line">备注：</span><br><span class="line">1） *  表示任意的(分、时、日、月、周)时间都执行</span><br><span class="line">2） -  表示一个时间范围段, 如5-7点</span><br><span class="line">3） ,  表示分隔时段, 如6,0,4表示周六、日、四</span><br><span class="line">4） /  表示每隔n单位时间, 如*/10 每10分钟</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="设置定时任务"><a href="#设置定时任务" class="headerlink" title="设置定时任务"></a>设置定时任务</h2><h3 id="crontab-命令选项："><a href="#crontab-命令选项：" class="headerlink" title="crontab 命令选项："></a>crontab 命令选项：</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-e                    #编辑定时任务</span><br><span class="line">-l                     #查看定时任务</span><br><span class="line">-r                     #删除定时任务</span><br><span class="line">-u                    #指定其他用户</span><br><span class="line">-i                     #在删除用户的crontab文件时给确认提示。</span><br></pre></td></tr></table></figure>

<p><strong>服务操作说明</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">需提前安装软件包</span></span><br><span class="line">yum install -y ntpdate</span><br><span class="line">服务操作说明：</span><br><span class="line"></span><br><span class="line">/sbin/service crond start //启动服务</span><br><span class="line"></span><br><span class="line">/sbin/service crond stop //关闭服务</span><br><span class="line"></span><br><span class="line">/sbin/service crond restart //重启服务</span><br><span class="line"></span><br><span class="line">/sbin/service crond reload //重新载入配置</span><br><span class="line"></span><br><span class="line">/sbin/service crond status //启动服务</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-2-任务实例："><a href="#3-2-任务实例：" class="headerlink" title="3.2 任务实例："></a>3.2 任务实例：</h3><p><strong>示例一：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">示例1：使用root用户每2分钟执行一次时间同步</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">先在Linux系统上查看命令是否正确</span></span><br><span class="line">[root@tom ~]# ntpdate ntp1.aliyun.com</span><br><span class="line">12 Apr 12:59:18 ntpdate[69500]: adjust time server 120.25.115.20 offset 0.024905 sec</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">配置定时任务</span></span><br><span class="line"><span class="meta">#</span><span class="bash">编辑定时任务</span></span><br><span class="line">[root@tom  ~]# crontab -e -u root</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">每2分钟执行一次时间同步 by wxg At 2021.04.12</span></span><br><span class="line">*/2 * * * * /usr/sbin/ntpdate ntp1.aliyun.com &amp;&gt;/dev/null</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">查看定时任务</span></span><br><span class="line">[root@tom  ~]# crontab -l -u root</span><br><span class="line"><span class="meta">#</span><span class="bash">每2分钟执行一次时间同步 by wxg At 2021.04.12</span></span><br><span class="line">*/2 * * * * /usr/sbin/ntpdate ntp1.aliyun.com &amp;&gt;/dev/null</span><br></pre></td></tr></table></figure>

<p><strong>示例二</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">示例2：每天凌晨6点做一次备份 打包备份/etc/ 备份到/tmp中并命名当天日期</span><br><span class="line">crontab -e -u root</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">每天凌晨3点做一次备份？ 打包备份/etc/</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  % 在crontab中比较特殊应用 \ 转义</span></span><br><span class="line">00 06 * * * tar zcf /tmp/`date +\%F_\%w`_etc.tar.gz /etc    </span><br><span class="line"></span><br><span class="line">pr 12 13:09:01 tom CRON[69714]: (tom) CMD (sudo tar ar zcf /tmp/`date +%F`_etc.tar.gz /etc   )</span><br></pre></td></tr></table></figure>

<h3 id="3-3-crond拒绝某个用户使用"><a href="#3-3-crond拒绝某个用户使用" class="headerlink" title="3.3 crond拒绝某个用户使用"></a>3.3 crond拒绝某个用户使用</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">1.使用root将需要拒绝的用户加入/etc/cron.deny</span></span><br><span class="line">[root@tom  ~]# echo &quot;Jerry&quot; &gt;&gt; /etc/cron.deny</span><br><span class="line"><span class="meta">#</span><span class="bash">2.登陆该普通用户，测试是否能编写定时任务</span></span><br><span class="line">[oldboy@tom  ~]$ crontab -e</span><br><span class="line">You (Jerry) are not allowed to use this program </span><br><span class="line">(crontab)</span><br><span class="line">See crontab(1) for more information</span><br></pre></td></tr></table></figure>

<h3 id="crond注意的事项"><a href="#crond注意的事项" class="headerlink" title="crond注意的事项"></a>crond注意的事项</h3><ol>
<li><p>给定时任务注释</p>
</li>
<li><p>将需要定期执行的任务写入<em>Shell</em>脚本中，避免直接使用命令无法执行的情况<em>tar date</em></p>
</li>
<li><p>定时任务的结尾一定要有*&amp;&gt;/dev/null*或者将结果追加重定向&gt;&gt;/tmp/date.log文件</p>
<p>每条任务调度执行完毕，系统都会将任务输出信息通过电子邮件的形式发送给当前系统用户，这样日积月累，日志信息会非常大，可能会影响系统的正常运行，因此，将每条任务进行重定向处理非常重要。</p>
</li>
<li><p>注意有些命令是无法成功执行的 <em>echo “123” &gt;&gt;/tmp/test.log &amp;&gt;/dev/null</em></p>
</li>
<li><p>如果一定要是用命令，命令必须使用绝对路径</p>
</li>
</ol>
<h3 id="crontab备份"><a href="#crontab备份" class="headerlink" title="crontab备份"></a>crontab备份</h3><p>通过查找*/var/log/cron*中执行的记录，去推算任务执行的时间</p>
<p>定时的备份*/var/spool/cron/{username}*</p>
<h2 id="定时任务安全项目实战练习"><a href="#定时任务安全项目实战练习" class="headerlink" title="定时任务安全项目实战练习"></a>定时任务安全项目实战练习</h2><ul>
<li><p>项目名称: XXXXX网站安全检查项目</p>
</li>
<li><p>项目背景: 网站因为安全配置导致病毒入侵,如何快速排查出哪些是病毒(被感染的文件或命令)</p>
</li>
<li><p>项目步骤: </p>
<p><img src="AppData/Roaming/Typora/typora-user-images/image-20210414211016694.png" alt="image-20210414211016694"></p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">将系统中/etc/目录下的文件做指纹，指纹结果定向到file.md5中</span></span><br><span class="line">find /etc/ -type f | xargs md5sum &gt;&gt; /file.md5</span><br><span class="line"><span class="meta">#</span><span class="bash">进行校验</span></span><br><span class="line"><span class="meta">#</span><span class="bash">若无文件被修改 则输出ok ，若有则输出filed</span></span><br><span class="line">md5sum -c  file.md5</span><br><span class="line"><span class="meta">#</span><span class="bash">使被篡改的文件输出</span></span><br><span class="line">md5sum -c --quiet file.md5</span><br></pre></td></tr></table></figure>



<h2 id="错误排查"><a href="#错误排查" class="headerlink" title="错误排查"></a>错误排查</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">crontab -e</span><br><span class="line">no crontab <span class="keyword">for</span> root - using an empty one</span><br><span class="line">/bin/sh: /usr/bin/vi: No such file or directory</span><br><span class="line">crontab: <span class="string">&quot;/usr/bin/vi&quot;</span> exited with status 127</span><br><span class="line"></span><br><span class="line">发生这种情况是因为没有正确定义编辑器。为此，您必须指定二进制文件的完整路径：</span><br><span class="line"><span class="built_in">export</span> EDITOR=/usr/bin/vim</span><br><span class="line">或者</span><br><span class="line"><span class="built_in">export</span> EDITOR=/usr/bin/vi</span><br></pre></td></tr></table></figure>

<script src='https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/mouse_snow.min.js'></script>





]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
      <tags>
        <tag>cron</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟化和云计算的区别</title>
    <url>/%E4%BA%91%E8%AE%A1%E7%AE%97/%E8%99%9A%E6%8B%9F%E5%8C%96%E5%92%8C%E4%BA%91%E8%AE%A1%E7%AE%97%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="一-Docker架构分析"><a href="#一-Docker架构分析" class="headerlink" title="一.Docker架构分析"></a>一.Docker架构分析</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如下图所示，Docker采用的是 Client/Server 架构。客户端向服务器发送请求，服务器负责构建、运行和分发容器。</span><br><span class="line"></span><br><span class="line">　　客户端和服务器可以运行在同一个 Host 上，客户端也可以通过socket或 REST API与远程的服务器通信。</span><br><span class="line">　　</span><br><span class="line">　　推荐阅读:</span><br><span class="line">	https://docs.docker.com/get-started/overview/</span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/WEB3031069c14b2641550ed11dbcbbc4fc1?method=download&shareKey=983cfe4b6cdf65ec627e1c390c4e6932" alt="img"></p>
<h2 id="1-Client"><a href="#1-Client" class="headerlink" title="1.Client"></a>1.Client</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">　　Docker客户端，最常用的Docker客户端是docker命令。通过docker我们可以方便地在Host上构建和运行容器。</span><br><span class="line">　　    </span><br><span class="line">　　docker支持很多操作(docker命令行工具)，用户也可以通过REST API与服务器通信。</span><br><span class="line">　　    </span><br><span class="line">　　Client和Docker daemon通信可使用https/http协议进行通信，为了安全起见，默认使用的就是https协议。</span><br></pre></td></tr></table></figure>



<h2 id="2-Docker-Host"><a href="#2-Docker-Host" class="headerlink" title="2.Docker-Host"></a>2.Docker-Host</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Docker daemon： 　</span><br><span class="line">　　　　Docker daemon是服务器组件，即Docker守护进程服务器，以Linux后台服务的方式运行。</span><br><span class="line">　　　　Docker daemon运行在Docker host上，负责创建、运行、监控容器，构建、存储镜像。默认配置下，Docker daemon只能响应来自本地Host的客户端请求。如果要允许远程客户端请求，需要在配置文件中打开TCP监听（支持IPV4和IPV6）。</span><br><span class="line">       </span><br><span class="line">　　Containers： 　　</span><br><span class="line">　　　　Docker容器，用于加载Docker镜像。换句话说，Docker容器就是Docker镜像的运行实例。我们知道镜像(Image)是只读的，在启动一个Container时，其实就是基于Image来新建一个专用的可写仓供用户使用。</span><br><span class="line">       </span><br><span class="line">　　Image： 　　</span><br><span class="line">　　　　可将Docker镜像看成只读模板(它类似于虚拟机使用的ISO镜像文件)，通过它可以创建Docker容器。例如某个镜像可能包含一个Ubuntu操作系统、一个Apache HTTP Server以及用户开发的Web应用。</span><br><span class="line">　　　　镜像有多种生成方法：</span><br><span class="line">　　　　　　(1)可以从无到有开始创建镜像；</span><br><span class="line">　　　　　　(2)也可以下载并使用别人创建好的现成的镜像</span><br><span class="line">　　　　　　(3)还可以在现有镜像上创建新的镜像</span><br><span class="line">　　　　　　(4)我们可以将镜像的内容和创建步骤描述在一个文本文件中，这个文件被称作Dockerfile，通过执行docker build &lt;docker-file&gt;命令可以构建出Docker镜像。</span><br><span class="line">　　　　公开的镜像仓库有很多种，如下所示: </span><br><span class="line">　　　　　　Docker官方镜像地址：</span><br><span class="line">　　　　　　　　https://hub.docker.com/。</span><br><span class="line">　　　　　　阿里的docker镜像地址：</span><br><span class="line">　　　　　　　　https://mirrors.aliyun.com/docker-ce/linux/</span><br><span class="line">　　　　　　清华大学docker镜像地址：</span><br><span class="line">　　　　　　 https://mirrors.tuna.tsinghua.edu.cn/docker-ce/</span><br><span class="line"></span><br><span class="line">　　温馨提示:</span><br><span class="line">　　　　生产环境中，我们通常在公司内部部署有私有镜像仓库。如使用Harbor，Docker Registry等等。在后续的文章我们会逐一对其进行讲解。</span><br></pre></td></tr></table></figure>



<h2 id="3-Registry"><a href="#3-Registry" class="headerlink" title="3.Registry"></a>3.Registry</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我们去构建镜像时，镜像做好之后应该有一个统一存放位置，我们称之为Docker仓库，Registry是存放Docker镜像的仓库（官方默认仓库在&quot;https://hub.docker.com&quot;），Registry分私有和公有两种。</span><br><span class="line"></span><br><span class="line">Images和Registry之间默认使用的时https协议，当然如果你非要指定为http协议也是可以的。</span><br><span class="line"></span><br><span class="line">启动容器时，docker daemon会试图从本地获取相关的镜像；本地镜像不存在时，其将从Registry中下载该镜像并保存到本地。　　</span><br><span class="line"></span><br><span class="line">Registry用于保存docker镜像，包括镜像的层次结构和元数据。用户可自建Registry，也可使用官方的Docker Hub。　　</span><br><span class="line"></span><br><span class="line">Docker Registry中的镜像通常由开发人员制作，而后推送至&quot;公共&quot;或&quot;私有&quot;Registry上保存，供其它人员使用，例如&quot;部署&quot;到生产环境。</span><br><span class="line"></span><br><span class="line">Docker Registry可分为以下几类:　　　　</span><br><span class="line">　　　　Sponsor Registry:</span><br><span class="line">　　　　　　第三方的registry，供客户端和Docker社区使用。　　　　</span><br><span class="line">　　　　Mirror Registry:</span><br><span class="line">　　　　　　第三方的registry，只让客户使用。　　　　</span><br><span class="line">　　　　Vendor Registry:</span><br><span class="line">　　　　　　由发布Docker镜像的供应商提供的registry。　　　　</span><br><span class="line">　　　　Private Registry:</span><br><span class="line">　　　　　　通过设有防火墙和额外的安全层的私有实体提供的registry。　　</span><br><span class="line"></span><br><span class="line">Registry包括Repository和Index，详细说明如下：　　　　</span><br><span class="line">	Repository:　　　　　　</span><br><span class="line">		由某特定的docker镜像的所有迭代版本组成的镜像仓库；</span><br><span class="line">		一个Registry中可以存在多个Repository：　　　　　　　　</span><br><span class="line">		Repository可分为&quot;顶层仓库&quot;和&quot;用户仓库&quot;；　　　　　　　　</span><br><span class="line">		用户仓库名称格式为&quot;用户名/仓库名&quot;。　　　　　　</span><br><span class="line">		每个仓库可以包含多个Tag(标签)，每个标签对应一个镜像；　　　　</span><br><span class="line">	Index：　　　　　　</span><br><span class="line">		维护用户账户，镜像的校验以及公共命名空间的信息；　　　　　　</span><br><span class="line">		相当于为Registry提供了一个完成用户认证等功能的检索接口。</span><br></pre></td></tr></table></figure>



<h2 id="4-镜像名称判断"><a href="#4-镜像名称判断" class="headerlink" title="4.镜像名称判断"></a>4.镜像名称判断</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">官方仓库:</span><br><span class="line">	官方镜像:</span><br><span class="line">       	nginx:1.20.1</span><br><span class="line">       用户上传镜像:</span><br><span class="line">       	jasonyin2020/oldboyedu_birds:v1</span><br><span class="line">       	</span><br><span class="line">第三方仓库:</span><br><span class="line">	用户上传镜像:</span><br><span class="line">		tuv7rqqq.mirror.aliyuncs.com/library/nginx:latest</span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/WEB619ede23fe543e8ad87fc3167b989033?method=download&shareKey=50ed40d4e7be6b8498105cdff2e8fc4d" alt="image-20210609221448005"></p>
<h2 id="5-docker、containerd的关系"><a href="#5-docker、containerd的关系" class="headerlink" title="5.docker、containerd的关系"></a>5.docker、containerd的关系</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">为了防止docker一家独大，docker当年的实现被拆分出了几个标准化的模块，标准化的目的是模块是可被其他实现替换的，不由任何一个厂商控制。</span><br><span class="line"></span><br><span class="line">docker由docker-client,dockerd,containerd,docker-shim,runc组成，所以containerd是docker的基础组件之一，下面是从containerd引过来的一张图。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">推荐阅读:</span><br><span class="line">	https://containerd.io/</span><br><span class="line">	https://cloud.tencent.com/document/product/457/35747</span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/WEB9ae043893800198f4cfd20c83d42606e?method=download&shareKey=4d6e228352542fb79aaf6d93dfa1b491" alt="image-20210624151140220"></p>
<h1 id="二-部署docker环境"><a href="#二-部署docker环境" class="headerlink" title="二.部署docker环境"></a>二.部署docker环境</h1><h2 id="1-关闭并禁用防火墙"><a href="#1-关闭并禁用防火墙" class="headerlink" title="1.关闭并禁用防火墙"></a>1.关闭并禁用防火墙</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@docker201.oldboyedu.com ~]# systemctl stop firewalld</span><br><span class="line">[root@docker201.oldboyedu.com ~]# </span><br><span class="line">[root@docker201.oldboyedu.com ~]# systemctl disable firewalld</span><br><span class="line">Removed symlink /etc/systemd/system/multi-user.target.wants/firewalld.service.</span><br><span class="line">Removed symlink /etc/systemd/system/dbus-org.fedoraproject.FirewallD1.service.</span><br><span class="line">[root@docker201.oldboyedu.com ~]# </span><br></pre></td></tr></table></figure>



<h2 id="2-停用并禁用selinux"><a href="#2-停用并禁用selinux" class="headerlink" title="2.停用并禁用selinux"></a>2.停用并禁用selinux</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@docker201.oldboyedu.com ~]# getenforce </span><br><span class="line">Enforcing</span><br><span class="line">[root@docker201.oldboyedu.com ~]# </span><br><span class="line">[root@docker201.oldboyedu.com ~]# setenforce 0</span><br><span class="line">[root@docker201.oldboyedu.com ~]# </span><br><span class="line">[root@docker201.oldboyedu.com ~]# grep ^SELINUX= /etc/selinux/config</span><br><span class="line">SELINUX=enforcing</span><br><span class="line">[root@docker201.oldboyedu.com ~]# </span><br><span class="line">[root@docker201.oldboyedu.com ~]# sed -ri s&#x27;#(SELINUX=)enforcing#\1disabled#&#x27; /etc/selinux/config</span><br><span class="line">[root@docker201.oldboyedu.com ~]# </span><br><span class="line">[root@docker201.oldboyedu.com ~]# grep ^SELINUX= /etc/selinux/config</span><br><span class="line">SELINUX=disabled</span><br><span class="line">[root@docker201.oldboyedu.com ~]# </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="3-卸载docker较旧的依赖项-如果您的操作系统是刚刚安装完成的状态，或者当前服务器没有安装过docker环境，则可以跳过该步骤"><a href="#3-卸载docker较旧的依赖项-如果您的操作系统是刚刚安装完成的状态，或者当前服务器没有安装过docker环境，则可以跳过该步骤" class="headerlink" title="3.卸载docker较旧的依赖项(如果您的操作系统是刚刚安装完成的状态，或者当前服务器没有安装过docker环境，则可以跳过该步骤)"></a>3.卸载docker较旧的依赖项(如果您的操作系统是刚刚安装完成的状态，或者当前服务器没有安装过docker环境，则可以跳过该步骤)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum -y remove docker docker-client docker-client-latest docker-common docker-lastest docker-lastest-logrotate docker-logrotate  docker-engine</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">温馨提示:</span><br><span class="line">　　(1)现在将Docker Engine软件包称为docker-ce，较旧的Docker Engine版本称为docker或docker-engine。如果已安装这些程序，请卸载它们以及相关的依赖项，因为新老docker版本并不相互兼容哟;</span><br><span class="line">　　(2)如果您在之前没有安装过docker环境，则无需做当前步骤，如果您非要做该步骤，可能会出现如下图所示的情况，属于正常现象！</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/WEB7a08da595901182122b042d0086d7216?method=download&shareKey=65d6999a105b014572ad817c35e72072" alt="image-20210608230633881"></p>
<h2 id="4-Docker-engine常见的安装方法概述"><a href="#4-Docker-engine常见的安装方法概述" class="headerlink" title="4.Docker engine常见的安装方法概述"></a>4.Docker engine常见的安装方法概述</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">您可以根据需要以不同的方式安装Docker Engine：</span><br><span class="line">　　　　(1)大多数用户会 设置Docker的存储库并从中进行安装，以简化安装和升级任务。这是推荐的方法。</span><br><span class="line">　　　　(2)一些用户下载并手动安装RPM软件包，并完全手动管理升级。这在诸如在无法访问互联网的空白系统上安装Docker的情况下非常有用。</span><br><span class="line">　　　　(3)在测试和开发环境中，一些用户选择使用自动便利脚本来安装Docker。　　</span><br><span class="line">　　　　</span><br><span class="line">　　　　温馨提示:　　　　</span><br><span class="line">　　　　	本篇博客是基于存储库(需要配置软件源)的方式进行安装，即在新主机上首次安装Docker Engine之前，需要设置Docker存储库。之后，您可以从存储库安装和更新Docker。</span><br></pre></td></tr></table></figure>



<h2 id="5-切换国内的软件源-本案例切换的是阿里源，当然，您也可以考虑使用其它的公网软件源哟"><a href="#5-切换国内的软件源-本案例切换的是阿里源，当然，您也可以考虑使用其它的公网软件源哟" class="headerlink" title="5.切换国内的软件源(本案例切换的是阿里源，当然，您也可以考虑使用其它的公网软件源哟)"></a>5.切换国内的软件源(本案例切换的是阿里源，当然，您也可以考虑使用其它的公网软件源哟)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(1)备份CentOS官网的软件源</span><br><span class="line">mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup</span><br><span class="line"></span><br><span class="line">(2)下载阿里云的软件源</span><br><span class="line">curl -o /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-7.repo </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(3)非阿里云ESC产品推荐操作该步骤</span><br><span class="line">sed -i -e &#x27;/mirrors.cloud.aliyuncs.com/d&#x27; -e &#x27;/mirrors.aliyuncs.com/d&#x27; /etc/yum.repos.d/CentOS-Base.repo</span><br><span class="line"></span><br><span class="line">(4)生成本地缓存</span><br><span class="line">yum makecache</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">温馨提示:</span><br><span class="line">　　上述的sed命令是可选操作，因为非阿里云ECS用户会出现&quot;Could not resolve host: mirrors.cloud.aliyuncs.com; Unknown error&quot;信息，不影响使用。</span><br><span class="line"></span><br><span class="line">参考链接: 　　</span><br><span class="line">　　https://developer.aliyun.com/mirror/centos</span><br></pre></td></tr></table></figure>



<h2 id="6-配置docker-ce的软件源-也称为”存储库”"><a href="#6-配置docker-ce的软件源-也称为”存储库”" class="headerlink" title="6.配置docker-ce的软件源(也称为”存储库”)"></a>6.配置docker-ce的软件源(也称为”存储库”)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(1)添加docker-ce的软件源</span><br><span class="line">	yum -y install yum-utils</span><br><span class="line">	yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line">	</span><br><span class="line">(2)官方软件源默认启用了最新的软件，您可以通过编辑软件源的方式获取各个版本的软件包。例如官方并没有将测试版本的软件源置为可用，您可以通过以下方式开启。同理可以开启各种测试版本等。</span><br><span class="line">	yum-config-manager --enable docker-ce-test  # 可选操作，若不启用并不影响安装docker-ce。</span><br><span class="line">	yum-config-manager --enable docker-ce-nightly  # 可选操作</span><br><span class="line"></span><br><span class="line">(3)如果您启用了多个Docker存储库，则在未在yum installor yum update命令中指定版本的情况下进行安装或更新将始终安装可能的最高版本，这可能不适合您的稳定性需求，这个时候我们也可以来禁用最新的软件源哟~</span><br><span class="line">	yum-config-manager --disable docker-ce-test</span><br><span class="line">	yum-config-manager --disable docker-ce-nightly</span><br><span class="line">	</span><br><span class="line">参考链接:</span><br><span class="line">　　https://developer.aliyun.com/mirror/docker-ce</span><br><span class="line">　　https://docs.docker.com/engine/install/centos/</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="7-安装Docker-Engine和容器"><a href="#7-安装Docker-Engine和容器" class="headerlink" title="7.安装Docker Engine和容器"></a>7.安装Docker Engine和容器</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(1)若不指定安装的docker版本，则默认安装最新版本的Docker Engine和容器</span><br><span class="line">	yum -y install docker-ce docker-ce-cli containerd.io</span><br><span class="line"></span><br><span class="line">(2)要安装特定版本的Docker Engine，请在存储库中列出可用版本，然后选择并安装。返回的列表取决于启用的存储库，并且特定于您的CentOS版本（.el7此示例中的后缀表示）</span><br><span class="line">	yum list docker-ce --showduplicates | sort -r</span><br><span class="line">	</span><br><span class="line">(3)通过其完全合格的软件包名称安装特定版本，该软件包名称是软件包名称（docker-ce）加上版本字符串（第二列），从第一个冒号（:）一直到第一个连字符，并用连字符（-）分隔。其语法格式如下所示。</span><br><span class="line">	yum install docker-ce-&lt;VERSION_STRING&gt; docker-ce-cli-&lt;VERSION_STRING&gt; containerd.io  # 安装特定docker版本的语法格式，下面有对应的案例哟~</span><br><span class="line">	yum install docker-ce-20.10.7 docker-ce-cli-20.10.7 containerd.io</span><br><span class="line">	</span><br><span class="line">温馨提示:</span><br><span class="line">	(1)此处我安装了指定的版本，我们可以将&quot;/etc/yum.conf&quot;的&quot;keepcache&quot;进行缓存即可。</span><br><span class="line">	(2)将rpm包进行打包下发到其他节点</span><br><span class="line">        [root@docker201.oldboyedu.com ~]# mkdir docker_rpm_20.10</span><br><span class="line">        [root@docker201.oldboyedu.com ~]# </span><br><span class="line">        [root@docker201.oldboyedu.com ~]# find /var/cache/yum/ -type f -name &quot;*.rpm&quot; | xargs mv -t docker_rpm_20.10</span><br><span class="line">        [root@docker201.oldboyedu.com ~]# </span><br><span class="line">        [root@docker201.oldboyedu.com ~]# </span><br><span class="line">        [root@docker201.oldboyedu.com ~]# tar zcf docker_rpm_20.10.tar.gz docker_rpm_20.10</span><br><span class="line">        [root@docker201.oldboyedu.com ~]# </span><br><span class="line">        [root@docker201.oldboyedu.com ~]# ll -h</span><br><span class="line">        总用量 109M</span><br><span class="line">        drwxr-xr-x. 2 root root 4.0K 6月   9 21:00 docker_rpm_20.10</span><br><span class="line">        -rw-r--r--. 1 root root 109M 6月   9 21:01 docker_rpm_20.10.tar.gz</span><br><span class="line">        [root@docker201.oldboyedu.com ~]# </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="8-启动docker守护进程并设置开机自启动"><a href="#8-启动docker守护进程并设置开机自启动" class="headerlink" title="8.启动docker守护进程并设置开机自启动"></a>8.启动docker守护进程并设置开机自启动</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@docker201.oldboyedu.com ~]# systemctl start docker</span><br><span class="line">[root@docker201.oldboyedu.com ~]# </span><br><span class="line">[root@docker201.oldboyedu.com ~]# systemctl enable docker</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="9-查看docker的概要信息"><a href="#9-查看docker的概要信息" class="headerlink" title="9.查看docker的概要信息"></a>9.查看docker的概要信息</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@docker201.oldboyedu.com ~]# docker info</span><br></pre></td></tr></table></figure>

<p><img src="%25E7%25AC%2594%25E8%25AE%25B0/04-%25E8%2580%2581%25E7%2594%25B7%25E5%25AD%25A9%25E6%2595%2599%25E8%2582%25B2-Docker%25E7%259A%2584%25E6%259E%25B6%25E6%259E%2584%25E4%25BB%258B%25E7%25BB%258D%25E5%258F%258A%25E9%2583%25A8%25E7%25BD%25B2%25E5%25AE%259E%25E6%2588%2598.assets/image-20210609004903141.png" alt="image-20210609004903141"></p>
<h2 id="10-修改docker-engine的默认Registry，建议使用国内的镜像仓库，国外的源网络会延迟较大"><a href="#10-修改docker-engine的默认Registry，建议使用国内的镜像仓库，国外的源网络会延迟较大" class="headerlink" title="10.修改docker engine的默认Registry，建议使用国内的镜像仓库，国外的源网络会延迟较大"></a>10.修改docker engine的默认Registry，建议使用国内的镜像仓库，国外的源网络会延迟较大</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@docker201.oldboyedu.com ~]# tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;&gt; &#123;&gt; &quot;registry-mirrors&quot;: [&quot;https://tuv7rqqq.mirror.aliyuncs.com&quot;]&gt; &#125;&gt; EOF&#123;&quot;registry-mirrors&quot;: [&quot;https://tuv7rqqq.mirror.aliyuncs.com&quot;]&#125;[root@docker201.oldboyedu.com ~]# [root@docker201.oldboyedu.com ~]# [root@docker201.oldboyedu.com ~]# cat /etc/docker/daemon.json &#123;&quot;registry-mirrors&quot;: [&quot;https://tuv7rqqq.mirror.aliyuncs.com&quot;]&#125;[root@docker201.oldboyedu.com ~]# [root@docker201.oldboyedu.com ~]# systemctl daemon-reload[root@docker201.oldboyedu.com ~]# [root@docker201.oldboyedu.com ~]# systemctl restart docker[root@docker201.oldboyedu.com ~]# 参考链接:　　https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors</span><br></pre></td></tr></table></figure>

<p><img src="%25E7%25AC%2594%25E8%25AE%25B0/04-%25E8%2580%2581%25E7%2594%25B7%25E5%25AD%25A9%25E6%2595%2599%25E8%2582%25B2-Docker%25E7%259A%2584%25E6%259E%25B6%25E6%259E%2584%25E4%25BB%258B%25E7%25BB%258D%25E5%258F%258A%25E9%2583%25A8%25E7%25BD%25B2%25E5%25AE%259E%25E6%2588%2598.assets/image-20210609005632041.png" alt="image-20210609005632041"></p>
<h1 id="三-dockers命令自动补全-新手必备"><a href="#三-dockers命令自动补全-新手必备" class="headerlink" title="三.dockers命令自动补全(新手必备)"></a>三.dockers命令自动补全(新手必备)</h1><h2 id="1-为啥能自动补全"><a href="#1-为啥能自动补全" class="headerlink" title="1.为啥能自动补全"></a>1.为啥能自动补全</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Linux系统许多命令都会提供该命令自身的命令补齐脚本，在安装命令时会自动安装自动补齐脚本，如果有的话，该机制在Linux中被称为bash-complete。	如下图所示，在/usr/share/bash-completion/completions/ 目录下有许多命令自动补齐的脚本，我们已经安装了docker环境。	</span><br></pre></td></tr></table></figure>

<p><img src="%25E7%25AC%2594%25E8%25AE%25B0/04-%25E8%2580%2581%25E7%2594%25B7%25E5%25AD%25A9%25E6%2595%2599%25E8%2582%25B2-Docker%25E7%259A%2584%25E6%259E%25B6%25E6%259E%2584%25E4%25BB%258B%25E7%25BB%258D%25E5%258F%258A%25E9%2583%25A8%25E7%25BD%25B2%25E5%25AE%259E%25E6%2588%2598.assets/image-20210609230730489.png" alt="image-20210609230730489"></p>
<h2 id="2-安装相关依赖包"><a href="#2-安装相关依赖包" class="headerlink" title="2.安装相关依赖包"></a>2.安装相关依赖包</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum -y install bash-completionsource /usr/share/bash-completion/bash_completion</span><br></pre></td></tr></table></figure>



<h2 id="3-验证补全功能"><a href="#3-验证补全功能" class="headerlink" title="3.验证补全功能"></a>3.验证补全功能</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如下图所示，当我们输入子命令不知道该如何是好的时候，就可以连续按两下&quot;tab&quot;键即可。</span><br></pre></td></tr></table></figure>

<p><img src="04-%E8%80%81%E7%94%B7%E5%AD%A9%E6%95%99%E8%82%B2-Docker%E7%9A%84%E6%9E%B6%E6%9E%84%E4%BB%8B%E7%BB%8D%E5%8F%8A%E9%83%A8%E7%BD%B2%E5%AE%9E%E6%88%98.assets/image-20210609231114594.png" alt="image-20210609231114594"></p>
]]></content>
      <categories>
        <category>云计算</category>
      </categories>
      <tags>
        <tag>虚拟化</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker发展史</title>
    <url>/%E4%BA%91%E8%AE%A1%E7%AE%97/Docker%E5%8F%91%E5%B1%95%E5%8F%B2/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">原文连接:</span><br><span class="line">	https://www.cnblogs.com/yinzhengjie2020/p/14017860.html</span><br></pre></td></tr></table></figure>

<h1 id="一-Docker的历史"><a href="#一-Docker的历史" class="headerlink" title="一.Docker的历史"></a>一.Docker的历史</h1><h2 id="1-Docker技术开源，IT界的福音"><a href="#1-Docker技术开源，IT界的福音" class="headerlink" title="1.Docker技术开源，IT界的福音"></a>1.Docker技术开源，IT界的福音</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2010年，几个大胡子年轻人在旧金山成立了一家做PaaS平台的公司，起名为&quot;dotCloud&quot;，该公司主要是基于PaaS平台为开发者或开发商提供技术服务。他们提供了对多种运行环境支持，如Java，Python，Ruby，Node.js等。</span><br><span class="line"></span><br><span class="line">　　PaaS的概念虽好，但是由于认知、理念和技术的局限性，市场的接受度并不高，市场的规模也不够大。</span><br><span class="line"></span><br><span class="line">　　除此之外，还有巨头不断进场搅局，IBM的蓝云，微软的Azure，Amazon的EC2，Google的GAE，VMware的Cloud Foundry等等，可谓强敌环伺，而且强敌都不差钱，想玩多久就玩多久，想玩多大玩多大。</span><br><span class="line"></span><br><span class="line">　　在这种情况下，虽然dotCloud在2011年初拿到了1000万美元的融资，但依然举步维艰。这可能叫生不逢时吧，在PaaS领域有太多的巨头和大企业了。</span><br><span class="line"></span><br><span class="line">　　有一天dotCloud的创始人Solomon Hykes就召集了公司核心开发人员，商量准备开源Docker技术。因此，在2013年3月，Docker正式以开源软件形式在pycon网站(见下图)首次发布了。正式由于这次开源，让容器领域焕发了第二春。</span><br><span class="line"></span><br><span class="line">　　可以说，Docker是继Linux之后，最让人感到兴奋的系统层面的开源项目，据不完全统计，包括dotCloud公司，RedHat，IBM，Google，Cisco，亚马逊及国内华为等，都在为它贡献代码。</span><br><span class="line"></span><br><span class="line">　　在美国，几乎所有的云计算厂商都在拥抱Docker这个生态圈。你知道的，很快Docker技术风靡全球，于是，dotCloud决定改名为Docker Inc(下面简称&quot;Docker&quot;)，全身心投入到Docker的开发中。</span><br><span class="line"></span><br><span class="line">　　更名后的Docker并于2014年8月，Docker宣布把平台即服务的业务dotCloud出售给位于德国柏林的平台即服务提供商cloudControl，自此dotCloud和Docker分道扬镳。</span><br><span class="line">　　</span><br><span class="line">　　参考链接:</span><br><span class="line">　　　　https://us.pycon.org/2013/</span><br><span class="line">　　　　https://www.oschina.net/news/57838/docker-dotcloud</span><br><span class="line">　　　　《docker容器实战：原理、架构与应用》书籍</span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/WEB67988db9dd6ff42c2b860da5a3a98bbf?method=download&shareKey=0c22e289e153a4fd412d0d7b509735be" alt="img"></p>
<h2 id="2-容器编排工具Kubernetes诞生"><a href="#2-容器编排工具Kubernetes诞生" class="headerlink" title="2.容器编排工具Kubernetes诞生"></a>2.<strong>容器编排工具Kubernetes诞生</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Google多年来一直使用容器作为交付应用程序的一种重要方式，且运行有一款名为Borg(在一定程度上借鉴了Omega)的编排工具。当谷歌于2014年3月开始开发Kubernetes时，原本是希望在大规模场景下，将容器化编排管理能力带到大众手中。</span><br><span class="line"></span><br><span class="line">　　这是一个很大的目标，McLuckie，Beda和队友Brendan Burns相信实现这一目标的唯一途径就是将技术开源并围绕其建立一个社区。事实证明他们的这个决定非常正确，但在当时没人能够100％确定。</span><br><span class="line">　　</span><br><span class="line">　　kubernetes很明智的选择当时最流行的容器，没错，就是Docker。Kubernetes对docker容器运行时的支持，迎来了大量的使用用户。</span><br><span class="line">　　</span><br><span class="line">　　Kubernetes于2014年6月6日首次发布。容器化才刚刚崭露头角，这主要得益于Docker，它是向开发人员推广容器化概念的功臣。但在当时，由于刚刚开始发展，因此尚不存在标准的容器管理方法。</span><br><span class="line">　　</span><br><span class="line">　　Kubernetes在以下几个方面堪称独一无二: 　　　　</span><br><span class="line">　　　　(1)它基于谷歌多年来开发的现有技术，Kohn说:&quot;尽管Kubernetes的代码是新的，但它背后的概念、工程和技术都是基于谷歌15年来建立Borg的经验(据说其前身是:&quot;Omega&quot;调度系统，两者各有优势!)&quot;; 　　　　</span><br><span class="line">　　　　(2)Kubernetes从一开始就是为开源而设计的。 </span><br><span class="line"></span><br><span class="line">　　参考链接: 　　　　</span><br><span class="line">　　　　https://blog.csdn.net/snail_ren/article/details/72636868 　　　　</span><br><span class="line">　　　　https://blog.csdn.net/M2l0ZgSsVc7r69eFdTj/article/details/80681470</span><br></pre></td></tr></table></figure>



<h2 id="3-Docker是一家有野心的公司-陆续推出Docker编排工具三剑客"><a href="#3-Docker是一家有野心的公司-陆续推出Docker编排工具三剑客" class="headerlink" title="3.Docker是一家有野心的公司-陆续推出Docker编排工具三剑客"></a>3.Docker是一家有野心的公司-陆续推出Docker编排工具三剑客</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Swarm:　　　　</span><br><span class="line">	早在2014年底，Docker公司就设计了容器集群的方案组合（也称之为docker编排工具三剑客）：Machine(可快速创建Docker运行环境) + Swarm(是Docker社区原生提供的容器集群管理工具) + Compose(自定义文件格式以运行多容器应用程序的工具)。当然此时的Swarm局限性较大，比如：</span><br><span class="line">　　　　　　(1)没有副本和负载均衡的概念，这导致服务无法高可用；</span><br><span class="line">　　　　　　(2)当然也更不存在什么服务网络管理和跨节点数据存储这些东西；</span><br><span class="line">　　　　　　(3)没有服务模型：集群中服务间关系和启动顺序编排也很复杂，于是就有了下面的SwarmKit的诞生；</span><br><span class="line">　　</span><br><span class="line">　　SwarmKit:</span><br><span class="line">　　　　在2016年2月，Docker公司开始了一个名叫SwarmKit的项目。而恰在Docker 1.12 RC之前的一段时间，Docker发布了Swarmkit，这是一个独立的、开源的容器编排项目。</span><br><span class="line">　　　　SwarmKit不同于一开始的经典Swarm，它从一开始就重新设计了一套独立的API和模型体系，并且采用独立的客户端命令行工具&quot;swarmctl&quot;。和上面的经典Swarm模型相比，它加入了如下特性：</span><br><span class="line">　　　　　　(1)重新设计的一套独立的API和模型体系;</span><br><span class="line">　　　　　　(2)使用了自己的CLI(swarmd命令负责管理，swarmctl命令用于控制);</span><br><span class="line">　　　　　　(3)节点管理、服务模型更加自然，提供编排和调度服务;</span><br><span class="line">　　　　　　(4)将过去Swarm依赖的外部集群一致性存储组件Etcd的核心部分内置化;</span><br><span class="line">　　　　　　(5)然而此时的SwarmKit并没有提供诸如服务发现、负载均衡和路由等功能。尽管如此，SwarmKit其实已经是我们今天广泛使用的Docker Swarm集群技术的基石。</span><br><span class="line">　　</span><br><span class="line">　　Swarm Mode:</span><br><span class="line">　　　　Swarm Mode则更进一步，它在Docker 1.12版本开始为大家所周知，一个docker swarm命令红遍大江南北，这个所谓的Swarm Mode其实就是我们今天所广泛使用的Docker Swarm集群技术。</span><br><span class="line">　　　　然而Swarm Mode并不是一个全新的东西，也并不是一个全新的模式，而是站在SwarmKit的巨人肩膀上发展起来的，是Docker中的一组与集群相关功能的统称而已。</span><br><span class="line">　　　　Docker将SwarmKit的核心模块内嵌于Docker的后台服务之中，通过不同的命令允许使用者同时以&quot;本节点&quot;和&quot;本集群&quot;这两种视角来操作整个集群，增加了集群的管理、节点的管理、服务的管理和编排等等一系列高级特性。</span><br><span class="line">　　　　因此总结一下Swarm Mode就是：</span><br><span class="line">　　　　　　(1)基于Swarmkit编写;</span><br><span class="line">　　　　　　(2)支持服务模型以及服务发现、路由和负载均衡等新功能;</span><br><span class="line">　　　　　　(3)使用Docker原生态的CLI命令;</span><br><span class="line">　　　　　　(4)集成到了Docker engine中(强大的 docker swarm 命令);</span><br><span class="line"></span><br><span class="line">　　参考链接:</span><br><span class="line">	https://github.com/docker/machine/</span><br><span class="line">	https://github.com/docker/compose</span><br><span class="line">	https://www.jianshu.com/p/7eb93f1e9ed4</span><br><span class="line">	https://www.jianshu.com/p/3f3c9e0e3db5</span><br></pre></td></tr></table></figure>



<h2 id="4-CoreOS-Rkt-轻量级容器"><a href="#4-CoreOS-Rkt-轻量级容器" class="headerlink" title="4.CoreOS Rkt 轻量级容器"></a>4.CoreOS Rkt 轻量级容器</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">创立于2013年的CoreOS公司旨在为各种规模的企业构建并交付基础设施，帮助其获得与大型软件企业对等的运营环境、实现自动更新与服务器修复，并协助解决停机时间控制、安全性保障以及恢复能力实现等实际难题。</span><br><span class="line"></span><br><span class="line">　　CoreOS公司最早是Docker的支持者，其产品CoreOS操作系统是适用于企业的轻量级容器化的Linux发行版，是Docker生态圈的重要一员。</span><br><span class="line">   </span><br><span class="line">　　随着Docker在容器行业变得逐渐强大，Docker也越来越臃肿，CoreOS公司希望有一个更加开放和中立的容器标准，因此推出了自己的容器计划，很明显CoreOS公司也想在容器方面有一席之地。当然，这样不得不说后面有谷歌和红帽公司在背后做支持。</span><br><span class="line"></span><br><span class="line">　　Rkt诞生于2014年11月末，我在GitHub上发现他在2014年11月27日就发布了&quot;v0.0.0&quot;版本，&quot;v0.1.0&quot;版本是在同年的12月1日发布的。</span><br><span class="line"></span><br><span class="line">　　Rkt是一种与Docker类似的容器引擎，由CoreOS公司主导，得到了Redhat、Google、Vmware等公司的支持，更加专注于解决安全、兼容、执行效率等方面的问题。</span><br><span class="line"></span><br><span class="line">　　就这样，CoreOS公司成为了Docker公司的容器引擎竞争对手。由于Docker已经深入人心，尽管Rkt也很优秀，但很少有人愿意将Docker技术栈迁移到Rkt技术栈。最终容器之战Docker占领了大部分市场。</span><br><span class="line"></span><br><span class="line">　　CoreOS是CoreOS Tectonic的创建者，CoreOS Tectonic是一种企业级Kubernetes平台，可提供自动化操作，实现在私有和公共云提供商之间的可移植性，并且基于开源软件。它还提供CoreOS Quay（企业级容器注册表）。</span><br><span class="line"></span><br><span class="line">　　CoreOS还以帮助推动许多开源技术创新而闻名，这些创新技术是容器化应用程序的核心，包括Kubernetes，它是该领域的主要贡献者。</span><br><span class="line"></span><br><span class="line">　　参考链接:</span><br><span class="line">　　　　https://www.openshift.com/learn/coreos/</span><br><span class="line">　　　　https://www.redhat.com/en/about/press-releases/red-hat-acquire-coreos-expanding-its-kubernetes-and-containers-leadership</span><br><span class="line">　　　　https://github.com/rkt/rkt/releases</span><br><span class="line">　　　　https://www.sohu.com/a/216850450_468741</span><br></pre></td></tr></table></figure>



<h2 id="5-容器编排工具之争Kubernetes完胜Docker-Swarm系列"><a href="#5-容器编排工具之争Kubernetes完胜Docker-Swarm系列" class="headerlink" title="5.容器编排工具之争Kubernetes完胜Docker Swarm系列"></a>5.容器编排工具之争Kubernetes完胜Docker Swarm系列</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Docker容器开源1年3个月后，Google公司开源了容器编排系统(Kubernetes,下面简称&quot;K8S&quot;)，当时就以最流行的Docker作为底层容器引擎，因此也为该开源项目带来不少Docker用户，可以说是相当的&quot;吸粉&quot;呀~</span><br><span class="line"></span><br><span class="line">　　Docker公司也在同年年底推出了Swarm以抵抗K8S市场，在后续的3年时间内相继推出了SwarmKit，Swarm Mode集群编排方案。在Swarm被纳入Docker 1.12后，Swarm与K8S之争日趋白热化。可以看出Docker公司的野心还是非常大的。</span><br><span class="line"></span><br><span class="line">　　在Docker公司和Google公司进行容器编排工具大战时，CoreOS公司开源的rkt容器引擎主动站队到Kubernetes，达成了合作关系，Kubernetes主力代码贡献者是Google(贡献源码第一)和RedHat(贡献源码第二)公司的人员。</span><br><span class="line"></span><br><span class="line">　　由于CoreOS的主动加入，Kubernetes在2016年7月11日发布的kubernetes 1.3版本之后将rkt作为可选容器引擎。但这条在当时的新闻对Docker项目发展几乎没有受到任何影响，Docker早已凭借自身的稳定性和易用性占领了大批的用户！</span><br><span class="line"></span><br><span class="line">　　大概在2017年秋季左右，如下图所示，可惜最终容器编排市场Google占有率(69%)远超过了Docker Swarm容器编排的占有率(18%)，这场容器编排技术大战以Google公司完胜宣告结束。</span><br><span class="line"></span><br><span class="line">　　究其原因并不是Docker公司实力不行，而是由于Google公司在开源K8S之前已经有了15年企业内部的使用容器的经验了(在这15年内已经经历了两代调度系统，即Omega和Borg)。</span><br><span class="line"></span><br><span class="line">　　经理了第一代调度系统:Omega，第二代调度系统:Borg，前两者都是商业的调度系统(即Google公司内部使用)，而第三代调度系统K8S则是开源产品，它借鉴了前两者调度的优势和经验。而Docker集群的集群编排是从2014年年底才开始的，经验尚有不足。</span><br><span class="line"></span><br><span class="line">　　参考链接:</span><br><span class="line">　　　　https://kubernetes.io/blog/2016/07/rktnetes-brings-rkt-container-engine-to-kubernetes/</span><br><span class="line">　　　　https://www.cncf.io/blog/2019/08/16/cncf-archives-the-rkt-project/</span><br><span class="line">　　　　https://github.com/moby/moby</span><br><span class="line">　　　　https://www.sohu.com/a/221638054_198222</span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/WEB1ab95f6b2ddb05596dc581b947d54f8b?method=download&shareKey=2b70028265caaef229423afe298a90bc" alt="img"></p>
<h2 id="6-Docker的版本变化"><a href="#6-Docker的版本变化" class="headerlink" title="6.Docker的版本变化"></a>6.Docker的版本变化</h2><p><img src="https://note.youdao.com/yws/api/personal/file/WEB11eee9ed623cb7fdfc7c8bd9a34364d2?method=download&shareKey=9075113bae2bd6aaec09774fef3fa14c" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我们知道Docker在容器编排技术上败给了K8s，大量市场被Google公司拿下，因此它没有找到一个很好的变现方式。</span><br><span class="line"></span><br><span class="line">　　为了让Docker项目做的更大，目的是吸引更多的投资人，将来未上市就想成为传说中的&quot;独角兽&quot;，此时这家领导层发现&quot;Docker&quot;这个关键词在互联网上非常火，该公司始终无法变现，能否通过这个关键词来引流呢?</span><br><span class="line"></span><br><span class="line">　　于是在2017年3月2日，Docker公司高层决定将docker更名为新的项目moby，其GitHub对应的地址为: &quot;https://github.com/moby/moby&quot;。</span><br><span class="line">   </span><br><span class="line">　　moby项目属于Docker项目的全新上游，docker将是一个隶属于moby的子产品，并将Docker开源版做了双发行版本，即Docker社区版(Community Edition，简称&quot;dockerce&quot;)和Docke企业(Enterprise Edition，简称&quot;dockeEE&quot;)版。</span><br><span class="line"></span><br><span class="line">　　在此期间Docker社区版的使用者对此做法有很多不满。后来Docker的CEO不得不解释说是为了Docker社区版更好的发展。很多程序员估计都心里念叨过:&quot;我信你个鬼，你个糟老头子坏得很!&quot;</span><br><span class="line"></span><br><span class="line">　　K8S将Docker社区版合并的代码贡献给CNCF组织，其目的是要告诉大家Google公司不会讲K8S私有化，这样大家方能大胆使用。</span><br><span class="line"></span><br><span class="line">　　现在K8S使用Go语言研发(Docker也是使用Go语言研发)，而k8s目前还处于高速发展期，更新版本迭代是相当之快。</span><br><span class="line">　　</span><br><span class="line">　　最早的时候docker就是一个开源项目，主要由docker公司维护。2017年年初，docker公司将原先的docker项目改名为moby，并创建了docker-ce和docker-ee。这三者的关系是：</span><br><span class="line">　　　　(1)moby是继承了原先的docker的项目，是社区维护的的开源项目，谁都可以在moby的基础打造自己的容器产品;</span><br><span class="line">　　　　(2)docker-ce是docker公司维护的开源项目，是一个基于moby项目的免费的容器产品，GitHub地址如下所示:</span><br><span class="line">　　　　　　　　https://github.com/docker/docker-ce</span><br><span class="line">　　　　　　　　如下图所示，需要注意的是: 从Docker 20.10版本开始，用于Docker Engine和Docker CLI的软件包直接从其各自的源存储库而不是从此存储库构建。</span><br><span class="line">　　　　　　　　　　https://github.com/moby/moby</span><br><span class="line">　　　　　　　　　　https://github.com/docker/cli</span><br><span class="line">　　　　(3)docker-ee是docker公司维护的闭源产品，是docker公司的商业产品，官网地址如下所示:</span><br><span class="line">　　　　　　　　https://www.docker.com/enterprise-edition</span><br><span class="line">   </span><br><span class="line">   docker-ce的发布计划v1.13.1之后，发布计划更改为:</span><br><span class="line">　　　　Edge: 月版本，每月发布一次，命名格式为YY.MM，维护到下个月的版本发布</span><br><span class="line">　　　　Stable: 季度版本，每季度发布一次，命名格式为YY.MM，维护4个月</span><br><span class="line"></span><br><span class="line">　　官方原文:</span><br><span class="line">　　　　https://www.docker.com/blog/docker-enterprise-edition/</span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/WEB66b7ad0030c25e12c2371a0085bef70a?method=download&shareKey=a7b2de6278e3d07dcfd22acc5fb0dc70" alt="img"></p>
<h2 id="7-Rkt和Docker陆续被收购"><a href="#7-Rkt和Docker陆续被收购" class="headerlink" title="7.Rkt和Docker陆续被收购"></a>7.Rkt和Docker陆续被收购</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CoreOS公司(开源了RKT的母公司)被收购:</span><br><span class="line">　　　　2018年1月31日由Redhat公司宣布收购CoreOS且已签署最终协议，收购价格为2.5亿美元。</span><br><span class="line">　　　　2018年4月16日是发布的最新rkt容器工具，目前该项目已经停止维护，因此生产环境中不推荐大家使用该容器技术。推荐使用主流的容器工具，如Docker，Pouch，podman。</span><br><span class="line">　　Docker公司被收购:</span><br><span class="line">　　　　2019年11月左右，Mirantis收购Docker，但收购金额两家公司貌似很保密，至今未公开发布官方说明。Mirantis表示，今后的重点是Kubernetes。他还承诺将对Swarm的支持再延长至少两年。</span><br><span class="line"></span><br><span class="line">　　参考链接:</span><br><span class="line">　　　　https://analyticsindiamag.com/mirantis-docker-acquisition-enterprise-kubernetes-containers/</span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/WEBe77069bef21f02263ff45e8e0466247e?method=download&shareKey=9bf0a58ffae900a282b96dee0f3d232e" alt="img"></p>
<h1 id="二-OCI与CNI那些事-往期学员面试官有问到这两个概念的含义哟"><a href="#二-OCI与CNI那些事-往期学员面试官有问到这两个概念的含义哟" class="headerlink" title="二.OCI与CNI那些事(往期学员面试官有问到这两个概念的含义哟~)"></a>二.OCI与CNI那些事(往期学员面试官有问到这两个概念的含义哟~)</h1><h2 id="1-OCI-全称-”Open-Container-Initiative”"><a href="#1-OCI-全称-”Open-Container-Initiative”" class="headerlink" title="1.OCI(全称:”Open Container Initiative”)"></a>1.OCI(全称:”Open Container Initiative”)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">业内最早的容器运行时环境(Runtime)是LXC，起初Docker就是利用LXC做容器管理引擎，但是在创建容器用户空间时不在用LXC的模板现场安装生成容器。　　而是实事先通过一种镜像技术(类似于KVM镜像启动)，把一个操作系统用户空间所要用到的所有组件事先准备编排好打包成一个文件，这个文件Docker称之为镜像文件。　　但后来觉得隔离性差，于是自研了libcontainer组件，不过此时Docker已被CNCF挟持了，当然容器的话语权依旧归Docker公司，这并不是说CNCF组织没有能力定制Docker的标准，只不过他们真那样做就太欺负Docker公司了。　　后来Docker又转型到runC，所以说到目前为止，runC是Docker的独生子。　　随着LXC，LXD，Docker，Rkt等容器运行时环境各有不同，这时候容器运行时的确是有点多了，开放容器倡议(Open Container Initiative，简称&quot;OCI&quot;)由多家公司共同成立的项目，并由linux基金会进行管理。 　　　　OCI是建立围绕容器格式和运行时的开放式行业标准的明确目的的开放式的治理结构。OCI由Docker和其他容器行业的领导者于2015年6月建立，但在2015年12月18日才在GitHub上发布的&quot;v0.1.1&quot;。 　　　　　　所谓container runtime，主要负责的是容器的生命周期的管理。OCI目前包含两个规范：运行时规范(runtime-spec)和映像规范(image-spec)。　　　　(1)OCI的runtime spec标准中对于容器的状态描述，创建，删除，查看等操作进行了定义，以及容器运行时如何运行指定文件系统上的包;　　　　(2)OCI的image-spec标准在定义了如何创建一个OCI运行时可运行的文件系统上的包;　　Docker公司将容器镜像格式和runtime(也就是runc)都捐献给了Open Container Initiative组织。runc是对于OCI标准的一个参考实现，是一个可以用于创建和运行容器的CLI(command-line interface)工具。　　runc直接与容器所依赖的cgroup/linux kernel等进行交互，负责为容器配置cgroup/namespace等启动容器所需的环境，创建启动容器的相关进程。　　　　为了兼容OCI标准，docker也做了架构调整。2016年12月14日，Docker公司宣布将将容器运行时相关的程序从docker daemon剥离出来，形成了containerd。而早在同年的3月份，Docker 1.11的Docker Engine里就包含了containerd。　　Containerd向docker提供运行容器的API，二者通过grpc进行交互。containerd最后会通过runc来实际运行容器。其架构如下图所示。　　　　参考链接:　　　　https://github.com/opencontainers/runc　　　　https://opencontainers.org/　　　　https://github.com/opencontainers/runtime-spec/releases/tag/v0.1.1　　　　https://www.cnblogs.com/xuxinkun/p/8036832.html　　　　http://www.dockone.io/article/9400</span><br></pre></td></tr></table></figure>

<p><img src="%25E7%25AC%2594%25E8%25AE%25B0/03-%25E8%2580%2581%25E7%2594%25B7%25E5%25AD%25A9%25E6%2595%2599%25E8%2582%25B2-Docker%2520Container%25E5%258F%2591%25E5%25B1%2595%25E5%258F%25B2.assets/1912698-20201227221604504-1079617044.png" alt="img"></p>
<h2 id="2-CNI-全称”Container-Runtime-Interface”"><a href="#2-CNI-全称”Container-Runtime-Interface”" class="headerlink" title="2.CNI(全称”Container Runtime Interface”)"></a>2.CNI(全称”Container Runtime Interface”)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubernetes在初期版本里，就对多个容器引擎做了兼容，因此可以使用docker、rkt对容器进行管理。以docker为例，kubelet中会启动一个docker manager，通过直接调用docker的api进行容器的创建等操作。　　在kubernetes中，pod是由一组进行了资源限制的，在隔离环境中的容器组成。而这个隔离环境，称之为PodSandbox。　　据说是Google(对K8S源码贡献第一)和RedHat(对K8S源码贡献第二)这两家公司有意将Docker边缘化，因此大力扶持由CoreOS公司2014年开源的轻量级rkt容器工具引擎。　　在Kubernetes早期版本，主要是支持docker和rkt两种容器引擎，这需要Kubernetes官方做大量的工作来兼容这两种容器，而兼容会带来很多维护性工作。　　于是在OCI提出一年后，大概在2016年12月19日，即在k8s 1.5版本之后，kubernetes推出了自己的运行时接口Container Runtime Interface(下面简称&quot;CRI&quot;)。　　凡是支持CRI皆可作为K8S的底层运行时，CRI接口的推出，隔离了各个容器引擎之间的差异，而通过统一的接口与各个容器引擎之间进行互动。　　与OCI不同，CRI与kubernetes的概念更加贴合，并紧密绑定。CRI不仅定义了容器的生命周期的管理，还引入了k8s中pod的概念，并定义了管理pod的生命周期。　　但Docker本身并未实现CRI，因此使用临时解决方案: 其中kubelet是通过CRI接口，调用docker-shim，并进一步调用docker api实现的。但这增大了K8S官方的工作负担，于是在2020年12月宣布将来会弃用docker-shim。　　如上文所述，docker独立出来了containerd。kubernetes也顺应潮流，孵化了cri-containerd项目，用以将containerd接入到cri的标准中。　　为了进一步与oci进行兼容，kubernetes还孵化了cri-o，成为了架设在cri和oci之间的一座桥梁。通过这种方式，可以方便更多符合oci标准的容器运行时，接入kubernetes进行集成使用。　　可以预见到，通过cri-o，kubernetes在使用的兼容性和广泛性上将会得到进一步加强。　　大概在2017年左右，Docker将自身的容器运行时(即&quot;containerd&quot;)捐给了CNCF组织(该组织维护的是Kubernetes开源产品)。同年，Docker的网络组建(libnetwork)增加了CNI的支持，同时实现基于IPVS的SERVICE负载均衡。　　来自谷歌、Docker、IBM、中兴通讯和ZJU的工程师们致力于为containerd实现CRI。该项目名为cri containerd，其特性在2017年9月25日发布了完整的v1.0.0-alpha.0版本。　　在2018年5月24日，Kubernetes GA版本正式集成了cri containerd架构。使用cri containerd，用户可以运行Kubernetes集群，使用containerd作为底层运行时，而无需安装Docker。　　2019年8月16日，CNCF组织正式将rkt归档，结束了rkt容器的在Kubernetes的生命周期，在此之前，2018年4月16日是发布的最新rkt容器工具。　　　　参考链接:　　　　https://kubernetes.io/blog/2017/11/containerd-container-runtime-options-kubernetes/　　　　https://kubernetes.io/blog/2018/05/24/kubernetes-containerd-integration-goes-ga/　　　　https://www.cncf.io/blog/2019/08/16/cncf-archives-the-rkt-project/　　　　https://github.com/containerd/cri　　　　https://github.com/cri-o/cri-o 　　　　https://kubernetes.io/blog/2016/12/container-runtime-interface-cri-in-kubernetes/　　　　https://kubernetes.io/blog/2020/12/02/dockershim-faq/　　　　https://github.com/kubernetes/enhancements/tree/master/keps/sig-node/1985-remove-dockershim　　　　https://github.com/rkt/rkt/releases　　　　https://www.cnblogs.com/xuxinkun/p/8036832.html 　　　　　　　　http://www.dockone.io/article/9400</span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/WEB48fb42fa8bb35137453b0207276dde15?method=download&shareKey=117206892bc6f2b3700aac305486e96f" alt="img"></p>
<h1 id="三-2020年Docker被误会的两件事"><a href="#三-2020年Docker被误会的两件事" class="headerlink" title="三.2020年Docker被误会的两件事"></a>三.2020年Docker被误会的两件事</h1><h2 id="1-Docker-Inc-”修改DockerHub定价和TOS"><a href="#1-Docker-Inc-”修改DockerHub定价和TOS" class="headerlink" title="1.Docker Inc.”修改DockerHub定价和TOS"></a>1.Docker Inc.”修改DockerHub定价和TOS</h2><p><img src="https://note.youdao.com/yws/api/personal/file/WEBc34450c3b70f956e5f50e072ce2f5f33?method=download&shareKey=182a0859082fb8cc0bb757e39bc0c71e" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对免费用户/未登录用户影响:　　　　流量限制:　　　　　　(1)未登录用户每6小时允许PULL 100次;　　　　　　(2)已登录用户每6小时允许PULL 200次;　　　　镜像保留策略:　　　　　　由于Docker Hub保留的镜像总大小已经超过了15PB，其中有4.5PB属于无效镜像。　　　　　　从2020年11月1日开始生效，非活跃(指的是没有push或poll操作的)镜像，保留周期为6个月。清理前，会发送通知告知清理操作。　　　　　　Docker团队也宣传会在Docker Hub上开发一个Dashboard以供用户查阅当前镜像的一个健康程度。　　　　上述消息对企业或个人有什么影响吗？我个人觉得影响不大，因为稍微有一点规模的公司，肯定是有基础架构部门的，里面有专门负责运维的同学，它们肯定不会使用官网的Docker Hub仓库，而是会考虑自建私有的高可用Harbor服务仓库。　　对于Docker Hub，Docker Registry，Harbor的部署或基本使用感兴趣的小伙伴可参考我之前整理的笔记，我这里就不赘述啦~　　　　https://www.cnblogs.com/yinzhengjie/p/12231835.html　　　　https://www.cnblogs.com/yinzhengjie/p/12232737.html　　　　https://www.cnblogs.com/yinzhengjie/p/12233594.html　　　　https://www.cnblogs.com/yinzhengjie/p/12235258.html　　　　https://www.cnblogs.com/yinzhengjie/p/12237263.html　　参考链接:　　　　https://www.docker.com/legal/docker-terms-service　　　　https://www.docker.com/pricing　　　　https://docs.docker.com/docker-hub/builds/　　　　https://docs.docker.com/docker-hub/repos/</span><br></pre></td></tr></table></figure>



<h2 id="2-Kubernetes宣布开始进入废弃dockershim支持的倒计时"><a href="#2-Kubernetes宣布开始进入废弃dockershim支持的倒计时" class="headerlink" title="2.Kubernetes宣布开始进入废弃dockershim支持的倒计时"></a>2.Kubernetes宣布开始进入废弃dockershim支持的倒计时</h2><p><img src="https://note.youdao.com/yws/api/personal/file/WEB70afa27be547b9c6580222f932f2cc83?method=download&shareKey=1eb469746002952ca1a5cee14a91f6b2" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">由于Docker在设计之初并未考虑集群编排的能力，主要考虑的单机的环境迁移问题。而且在2013年3月dotCloud公司开源时Kubernetes还为诞生呢！　　于是谷歌在2014年3月开始开发Kubernetes，到2014年6月6日首次发布。并与2015年7月发布Kubernetes 1.0，并加入CNCF组织。2018年K8S从CNCF基金会毕业。　　Kubernetes选择Docker作为容器运行时，本身就是因为当时它没有其他的选择，而且当时最火的容器引擎就是Docker。选择Docker可以为Kubernetes带来更多的用户。　　　　综上所述，因此Kubernetes在开始时那就对Docker做了内置的支持，使用&quot;dockershim&quot;作为调用Docker的API接口作为临时解决方案，以兼容docker引擎，当然维护该组件是需要耗费资源的。　　　　大概在2017年左右，Docker将的容器运行时(即&quot;containerd&quot;)捐给了CNCF组织(该组织维护的是Kubernetes开源产品)。 　　来自谷歌、Docker、IBM、中兴通讯和ZJU的工程师们致力于为containerd实现CRI。该项目名为cri containerd，其特性在2017年9月25日发布了完整的v1.0.0-alpha.0版本。　　在2018年5月24日，Kubernetes GA版本正式集成了cri containerd架构。使用cri containerd，用户可以运行Kubernetes集群，使用containerd作为底层运行时，而无需安装Docker。 　　由于历史性原因，从2014年至今2020年底，一直维护dockershim，Kubernetes将在下一个版本Kubernetes 1.20版本中宣布废弃dockershim(若使用其API只会发出警告信息)，当然你依旧可以使用，直到k8s 1.23版本发布才会被正式移除哟~ 　　此外，这些较新的CRI运行时中正在实现与dockershim基本上不兼容的功能，例如cgroups v2和用户名称空间。删除对dockershim的支持将允许在这些领域中进行进一步的开发。　　综上所述:　　　　(1)随着cri-containerd从2018年正式发布以来已经有两年多时间了，基本上也侧面证明了cri-containerd的稳定性，K8S官方任务可以将其作为容器的运行时；　　　　(2)因此以后可以使用符合CRI标准的cri-container作为容器运行时，这样符合2016年其推出的CNI规范！不过最新版本的容器运行时版本架构发生变化，如下图所示。　　　　参考链接:　　　　https://kubernetes.io/blog/2020/12/02/dockershim-faq/　　　　https://kubernetes.io/blog/2018/05/24/kubernetes-containerd-integration-goes-ga/　　　　　　　　https://www.bilibili.com/video/BV1y5411G7Zf</span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/WEB1e2f2b29378b4551d5a312df57361964?method=download&shareKey=9ccad19ee566b7cceeb200f1093d971b" alt="img"></p>
<h2 id="3-dockershim之后的方向如何呢"><a href="#3-dockershim之后的方向如何呢" class="headerlink" title="3.dockershim之后的方向如何呢?"></a>3.dockershim之后的方向如何呢?</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Docker和收购它的公司MIRANTIS会一起维护一个开源的dockershim组件，以便docker作为Kubernetes的容器运行时。　　本次Kubernetes放弃对dockershime的维护到底有什么影响?　　　　(1)对普通用户没有任何影响;　　　　(2)对开发工程师也没用太大影响;　　　　(3)对K8S运维工程师的小伙伴需要注意：　　　　　　　　a)需要考虑将容器运行时考虑换成支持CRI的容器运行时，换句话说，就是不使用原生docker的容器运行时，而是使用集成了CRI Plugin的Containerd运行时;　　　　　　　　b)不使用K8S官方提供的cri-containerd组件，那就只能使用Docker公司和MIRANITS公司共同维护的dockershim组件啦，只不过该组件需要你在K8S集群外部维护而已。　　　　听说K8S放弃dockershim后Podman可以借机上位了?　　　　别听风就是雨，Podman和Docker一样都不兼容Container Runtime Interface(就是我们简称的&quot;CRI&quot;)，此前Docker之所以是K8s的底层容器引擎是因为K8S官方提供了dockershim来调用docker容器的API。　　　　尽管我们可以使用支持kind工具(它是一个CRI工具，下面链接有其官网地址)来使得Docker或者Podman容器引擎来实现CRI功能，估计使用者也寥寥无几吧，毕竟已经有比较成熟的cir-contained容器运行时。　　　　当然，如果我们在使用的容器运行时是cri-o的时候，这时候可以使用docker或者podman来做本地调试。　　参考链接:　　　　https://www.mirantis.com/blog/mirantis-to-take-over-support-of-kubernetes-dockershim-2/　　　　https://kind.sigs.k8s.</span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/WEBdbba5bbdc3f504884268df5a4499ed12?method=download&shareKey=3ad39a4774f43e421488f0fecf1d9faa" alt="img"></p>
]]></content>
      <categories>
        <category>云计算</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux磁盘管理</title>
    <url>/Linux%E5%9F%BA%E7%A1%80/Linux%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="Linux磁盘管理"><a href="#Linux磁盘管理" class="headerlink" title="Linux磁盘管理"></a>Linux磁盘管理</h1><h2 id="磁盘的分类及特点"><a href="#磁盘的分类及特点" class="headerlink" title="磁盘的分类及特点"></a>磁盘的分类及特点</h2><h3 id="磁盘的分类"><a href="#磁盘的分类" class="headerlink" title="磁盘的分类"></a>磁盘的分类</h3><ul>
<li>机械硬盘hdd—容量大，价格便宜速度慢 ；</li>
<li>固态硬盘sdd—容量小，价格较贵速度快；</li>
</ul>
<h3 id="磁盘接口"><a href="#磁盘接口" class="headerlink" title="磁盘接口"></a>磁盘接口</h3><ul>
<li><p>IDE（Integrated Drive Electronics）</p>
<p><img src="https://exp-picture.cdn.bcebos.com/e9a4f2eeadbcbe2fb5bfecad54dae43b3a867865.jpg?x-bce-process=image/resize,m_lfit,w_500,limit_1/format,f_jpg/quality,q_80" alt="硬盘的接口种类"></p>
<ul>
<li>本意是指把“硬盘控制器”与“盘体”集成在一起的硬盘驱动器；</li>
<li>优点：价格低廉兼容性好；</li>
</ul>
</li>
<li><p>SCSI（Small Computer System Interface ）</p>
<p><img src="https://exp-picture.cdn.bcebos.com/edafb3bcbe2f4770b5d7756f6f3b3b8603217965.jpg?x-bce-process=image/resize,m_lfit,w_500,limit_1/format,f_jpg/quality,q_80" alt="硬盘的接口种类"></p>
<ul>
<li>不是专门为硬盘设计的，而是一种总线型的系统接口；</li>
<li>优点：适应面广高性能同时具备内、外置；</li>
</ul>
</li>
<li><p>FC（Fibre Channel ）</p>
<p><img src="https://exp-picture.cdn.bcebos.com/51cd85cec7f88a772f0d22f96e4a2f27e6eff865.jpg?x-bce-process=image/resize,m_lfit,w_500,limit_1/format,f_jpg/quality,q_80" alt="硬盘的接口种类"></p>
<ul>
<li>FC最初是专门为网络系统设计的随着存储系统对速度的需求，逐渐应用到硬盘系统中；</li>
<li>优点：带宽高、连接距离长、连接设备数量大；</li>
</ul>
</li>
<li><p>SATA（Serial ATA ）</p>
<p><img src="http://www.dnpz.net/uploads/allimg/180122/983-1P1221054295Z.jpg" alt="电脑硬件知识：带你了解硬盘的各种接口类型"></p>
<ul>
<li>是一种完全不同于并行ATA的新型硬盘接口类型，由于采用串行方式传输数据而得名；</li>
<li>优点：一对一连接，独享带宽、支持热插拔、低电压信号、带宽升级潜力大；</li>
</ul>
</li>
<li><p>SAS（Serial Attached SCSI ） </p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/4101dfdf9cf599b1de7b5314b0861421.png" alt="image"></p>
<ul>
<li><p>即串行连接SCSI，是新一代的SCSI技术，和SATA相同，都是采用串行技术以获得更高的传输速度，并通过缩短连接线改善内部空间 </p>
</li>
<li><p>优点：兼容性好、数据传输率高；</p>
</li>
</ul>
<p>搭配方式：</p>
<p>SSD+SAS==》土豪</p>
<p>SSD+SATA==》常规，对速度有特殊要求</p>
<p>机械+SAS==》常规，对速度要求一般，比较核心业务使用</p>
<p>机械+SATA==》公司内部服务</p>
</li>
</ul>
<h3 id="磁盘性能指标"><a href="#磁盘性能指标" class="headerlink" title="磁盘性能指标"></a>磁盘性能指标</h3><ul>
<li>容量<ul>
<li>家用：1T、2T……</li>
<li>企业: 300G、600G、900G……</li>
</ul>
</li>
<li>转速<ul>
<li>家用：4.5k\7.2krpm</li>
<li>企业：7.2k、10k、15k</li>
</ul>
</li>
<li>缓存</li>
</ul>
<h3 id="磁盘组成"><a href="#磁盘组成" class="headerlink" title="磁盘组成"></a>磁盘组成</h3><table>
<thead>
<tr>
<th align="center">磁盘知识点</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">磁头 header</td>
<td align="center">读取或写入数据,移动只能是径向方法,磁头是从0开始,磁头数==盘面数</td>
</tr>
<tr>
<td align="center">磁道tracker</td>
<td align="center">当磁盘旋转时，磁头若保持在一个位置上，则每个磁头都会在磁盘表面划出一个圆形轨迹，这些圆形轨迹就叫做磁道。</td>
</tr>
<tr>
<td align="center">扇区sector</td>
<td align="center">扇区，是指磁盘上划分的区域。磁盘上的每个磁道被等分为若干个弧段，这些弧段便是磁盘的扇区，硬盘的读写以扇区为基本单位，从1开始</td>
</tr>
<tr>
<td align="center">柱面cylinder</td>
<td align="center">硬盘通常由重叠的一组盘片构成，每个盘面都被划分为数目相等的磁道，并从外缘的“0”开始编号，具有相同编号的磁道形成一个圆柱，称之为磁盘的柱面</td>
</tr>
</tbody></table>
<ul>
<li><p>扇区（512KB）是磁盘读取的基本单位</p>
</li>
<li><p>block（4KB）是系统层面上面读写数据的单位 </p>
</li>
</ul>
<p><img src="../AppData/Roaming/Typora/typora-user-images/image-20210330201437498.png" alt="image-20210330201437498"></p>
<h2 id="RAID独立冗余磁盘阵列"><a href="#RAID独立冗余磁盘阵列" class="headerlink" title="RAID独立冗余磁盘阵列"></a>RAID独立冗余磁盘阵列</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>简单的说，RAID是一种把多块独立的硬盘（物理硬盘）按不同的方式组 合起来形成一个硬盘组（逻辑硬盘），从而提高存储性能和容错功能。</p>
<h3 id="raid级别"><a href="#raid级别" class="headerlink" title="raid级别"></a>raid级别</h3><ul>
<li><p><em>raid0</em></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">容量：N块盘合在一起的容量；</span><br><span class="line">性能：理论上是N块盘合在一起的读写速度，实际上是略低一些；</span><br><span class="line">冗余性：不允许坏任何一块硬盘，一块坏，全部gg;</span><br><span class="line">场合：追求读写性能，但对数据安全性无要求；</span><br><span class="line">特点:追求速度，不考虑数据安全；</span><br><span class="line">ps:可以考虑用集群服务器</span><br></pre></td></tr></table></figure></li>
<li><p><em>raid1</em></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">至少2快盘</span><br><span class="line">容量：一块盘的容量</span><br><span class="line">性能：几乎就是一块盘的读写速度</span><br><span class="line">冗余性：可以坏一块盘，另外一块盘有完整的数据；一块存数据，一块备份数据（备份过）</span><br><span class="line">场合：对数据安全性有要求，对读写速度没有要求</span><br><span class="line">特点:追求数据安全，不考虑速度</span><br><span class="line">ps:主要用于服务器的系统盘</span><br></pre></td></tr></table></figure></li>
<li><p><em>raid5</em>(结余raid0与raid1之间，是一种折中的方案)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">至少三块盘，两两之间做奇偶校验，相同结果为0，不同结果为1</span><br><span class="line">容量：以三快盘为例，只有两块容量可用，一块作为校验</span><br><span class="line">性能：读写速度低于raid0，高于raid1</span><br><span class="line">冗余性：可以坏一块盘，其余两块可通过奇偶校验推导出坏盘的数据</span><br><span class="line">场合：一般场合都可使用</span><br><span class="line">ps:兼顾了速度和安全性</span><br></pre></td></tr></table></figure></li>
<li><p><em>raid10</em>(raid1和raid0整合的产物，兼顾了raid1的数据安全性和raid0的性能，成本高)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">至少4块</span><br><span class="line">容量：所有容量的一半</span><br><span class="line">性能：读写速度很快</span><br><span class="line">冗余性：可以损坏一半，但损毁的的不能再一组</span><br><span class="line">场合：</span><br><span class="line">ps:性能和冗余很好的业务。数据库主库和存储的主节点</span><br></pre></td></tr></table></figure></li>
<li><p>冗余 raid1 raid10 raid5 raid0</p>
</li>
<li><p>读写性能 raid0 raid10 raid5 raid1</p>
</li>
<li><p>成本 raid0、raid5、raid1、raid10</p>
</li>
</ul>
<h2 id="磁盘分区"><a href="#磁盘分区" class="headerlink" title="磁盘分区"></a>磁盘分区</h2><p><strong>1.分区表</strong></p>
<ul>
<li>MBR</li>
</ul>
<p>磁盘主引导记录 0磁头0磁道1扇区 大小512k</p>
<p>磁盘分区表结构：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">446bytes:</span><br><span class="line">	主引导记录MBR所在地址；</span><br><span class="line">64bytes:</span><br><span class="line">	磁盘分区信息 DPT，磁盘分区表；</span><br><span class="line">2bytes:</span><br><span class="line">	55AA,分区信息结束 DPT 磁盘分区表；</span><br></pre></td></tr></table></figure>

<ul>
<li><p>GPT</p>
<ul>
<li>mbr升级版</li>
<li>主分区足够用</li>
<li>可支持大容量硬盘</li>
</ul>
<p>区别:</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">gpt</th>
<th align="center">mbr</th>
</tr>
</thead>
<tbody><tr>
<td align="center">主分区数量不限</td>
<td align="center">主分区最多4个扩展分区1个</td>
</tr>
<tr>
<td align="center">可额外支持大容量2tb以上硬盘</td>
<td align="center">mbr只支持2tb以内的硬盘</td>
</tr>
</tbody></table>
<ul>
<li>主分区p：存放数据，必须拥有；</li>
<li>扩展分区e：用来给逻辑分区创造空间；</li>
<li>逻辑分区l：在扩展分区下面，进行创建，使用扩展分区空间；</li>
</ul>
<p><em><strong>2.询磁盘信息</strong></em></p>
<p>一般查询磁盘信息主要查看这三个指标</p>
<ul>
<li>使用率</li>
<li>当前读写速度</li>
<li>其它信息</li>
</ul>
<p>1.df命令 ： 查看当前磁盘容量使用率（不用参数以k为单位）；</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">df -i #查看inode使用情况</span><br><span class="line">df -h #以人性化方式显示</span><br><span class="line">df -T  #查看磁盘分区类型（文件系统类型）</span><br><span class="line"></span><br><span class="line">[root@yum_server_100 /]# df -i</span><br><span class="line">Filesystem                Inodes IUsed    IFree IUse% Mounted on</span><br><span class="line">devtmpfs                  121457   393   121064    1% /dev</span><br><span class="line">tmpfs                     124460     1   124459    1% /dev/shm</span><br><span class="line">tmpfs                     124460   765   123695    1% /run</span><br><span class="line">tmpfs                     124460    16   124444    1% /sys/fs/cgroup</span><br><span class="line">/dev/mapper/centos-root 26214400 47406 26166994    1% /</span><br><span class="line">/dev/mapper/centos-home 24637440    13 24637427    1% /home</span><br><span class="line">/dev/sde1                 524288   326   523962    1% /boot</span><br><span class="line">tmpfs                     124460     1   124459    1% /run/user/0</span><br><span class="line">[root@yum_server_100 /]# </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">root@yum_server_100 /]# df -h</span><br><span class="line">Filesystem               Size  Used Avail Use% Mounted on</span><br><span class="line">devtmpfs                 475M     0  475M   0% /dev</span><br><span class="line">tmpfs                    487M     0  487M   0% /dev/shm</span><br><span class="line">tmpfs                    487M  7.6M  479M   2% /run</span><br><span class="line">tmpfs                    487M     0  487M   0% /sys/fs/cgroup</span><br><span class="line">/dev/mapper/centos-root   50G   14G   37G  27% /</span><br><span class="line">/dev/mapper/centos-home   47G   33M   47G   1% /home</span><br><span class="line">/dev/sde1               1014M  137M  878M  14% /boot</span><br><span class="line">tmpfs                     98M     0   98M   0% /run/user/0</span><br><span class="line"></span><br><span class="line">[root@yum_server_100 /]# df -T</span><br><span class="line">Filesystem              Type     1K-blocks     Used Available Use% Mounted on</span><br><span class="line">devtmpfs                devtmpfs    485828        0    485828   0% /dev</span><br><span class="line">tmpfs                   tmpfs       497840        0    497840   0% /dev/shm</span><br><span class="line">tmpfs                   tmpfs       497840     7768    490072   2% /run</span><br><span class="line">tmpfs                   tmpfs       497840        0    497840   0% /sys/fs/cgroup</span><br><span class="line">/dev/mapper/centos-root xfs       52403200 13739376  38663824  27% /</span><br><span class="line">/dev/mapper/centos-home xfs       49250820    33044  49217776   1% /home</span><br><span class="line">/dev/sde1               xfs        1038336   140076    898260  14% /boot</span><br><span class="line">tmpfs                   tmpfs        99572        0     99572   0% /run/user/0</span><br></pre></td></tr></table></figure>

<p>2.使用lsblk查看分区情况</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@yum_server_100 /]# lsblk</span><br><span class="line">NAME            MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sda               8:0    0    1G  0 disk </span><br><span class="line">sdb               8:16   0    1G  0 disk </span><br><span class="line">└─sdb1            8:17   0  100M  0 part </span><br><span class="line">sdc               8:32   0    1G  0 disk </span><br><span class="line">sdd               8:48   0    3T  0 disk </span><br><span class="line">sde               8:64   0  100G  0 disk </span><br><span class="line">├─sde1            8:65   0    1G  0 part /boot</span><br><span class="line">└─sde2            8:66   0   99G  0 part </span><br><span class="line">  ├─centos-root 253:0    0   50G  0 lvm  /</span><br><span class="line">  ├─centos-swap 253:1    0    2G  0 lvm  [SWAP]</span><br><span class="line">  └─centos-home 253:2    0   47G  0 lvm  /home</span><br><span class="line">sr0              11:0    1  3.7G  0 rom  </span><br><span class="line">sr1              11:1    1  4.5G  0 rom  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3.使用du命令查看目录或者文件容量，不参加以k为单位</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">du -sh #人性化输出显示大小</span><br><span class="line">-s :summary 总结，汇总列出总和</span><br><span class="line">-h:人性化显示容量信息，人类可读 </span><br></pre></td></tr></table></figure>

<p>4.iotop  显示当前硬盘读取速度</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iotop #显示磁盘io</span><br><span class="line">iotop -o 只显示进行读写进程信息</span><br><span class="line">dd if=/dev/zero  of=/tmp/big    bs=1k  count=10000000</span><br></pre></td></tr></table></figure>

<h3 id="fdisk-分区"><a href="#fdisk-分区" class="headerlink" title="fdisk 分区"></a>fdisk 分区</h3><ul>
<li><p>fdisk :这个命令是磁盘分区表操作工具，fdisk能将磁盘分区，同时也能为每个分区指定分区类型，总的来说，fdisk就是磁盘工具。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">fdisk -l	#查看硬盘分区表</span><br><span class="line"><span class="meta">#</span><span class="bash"> fdisk -l</span></span><br><span class="line">  Device Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/sdb1            2048      206847      102400   83  Linux</span><br><span class="line">/dev/sdb2          206848      616447      204800   83  Linux</span><br><span class="line">/dev/sdb3          616448     1230847      307200    5  Extended</span><br><span class="line">/dev/sdb5          618496      638975       10240   83  Linux</span><br><span class="line">/dev/sdb6          641024      661503       10240   83  Linux</span><br><span class="line">/dev/sdb7          663552      684031       10240   83  Linux</span><br><span class="line">/dev/sdb8          686080      890879      102400    c  W95 FAT32 (LBA)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>fdisk /dev/sdb 分区</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@yum_server_100 /]# fdisk /dev/sdb</span><br><span class="line"><span class="meta">#</span><span class="bash">进入Command 分区命令行；如果输入错误用ctrl+u进行删除重新输入命令</span></span><br><span class="line">Welcome to fdisk (util-linux 2.23.2).</span><br><span class="line"></span><br><span class="line">Changes will remain in memory only, until you decide to write them.</span><br><span class="line">Be careful before using the write command.</span><br><span class="line"></span><br><span class="line">Device does not contain a recognized partition table</span><br><span class="line">Building a new DOS disklabel with disk identifier 0xe42d9531.</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> p -- 展示指定硬盘已有分区（目前没有增加分区）</span></span><br><span class="line">Command (m for help): p</span><br><span class="line">Disk /dev/sdc: 1073 MB, 1073741824 bytes, 2097152 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disk label type: dos</span><br><span class="line">Disk identifier: 0xe42d9531</span><br><span class="line"></span><br><span class="line">   Device Boot      Start         End      Blocks   Id  System</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> n--在硬盘中新增一个主分区</span></span><br><span class="line">Command (m for help): n</span><br><span class="line"><span class="meta">#</span><span class="bash"> 会有选p主分区 e扩展分区 默认空白是p主分区</span> </span><br><span class="line">Partition type:</span><br><span class="line">   p   primary (0 primary, 0 extended, 4 free)</span><br><span class="line">   e   extended</span><br><span class="line">Select (default p): p</span><br><span class="line">Partition number (1-4, default 1): 1  #分区编号默认编号1</span><br><span class="line">First sector (2048-2097151, default 2048): #选择分区开始位置这里忽略只在意结束位置（大小）</span><br><span class="line">Using default value 2048</span><br><span class="line">Last sector, +sectors or +size&#123;K,M,G&#125; (2048-2097151, default 2097151): +100M #指定分区大小</span><br><span class="line">Partition 1 of type Linux and of size 100 MiB is set  #成功！！！</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">分区后 p展示分区信息</span></span><br><span class="line">Command (m for help): p</span><br><span class="line">  Device Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/sdc1            2048      206847      102400   83  Linux</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#同理要想建立扩展分区 在n之后选择e即可 扩展分区建立后 才能建立逻辑分区</span></span> </span><br><span class="line"></span><br><span class="line">d 删除分区</span><br><span class="line">t 将分区换类型</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="parted分区"><a href="#parted分区" class="headerlink" title="parted分区"></a>parted分区</h3><p><strong>一.parted的用用途及说明：</strong></p>
<ul>
<li>parted ：parted分区是fdisk分区升级版本，可以划分多个主分，支持2TB以上的磁盘分区，并且允许调整分区的大小。</li>
<li>parted是一个用于硬盘分区或调整分区大小的工具。使用它你可以创建、清除、调整、移动和复制ext2、ext3、linux-swap、FAT、FAT32和reiserfs分区；也能创建、调整和移动苹果系统的HFS分区；还能检测jfs、ntfs、ufs和xfs分区。该工具常用于为新安装的操作系统创建空间，重新分配硬盘使用情况，在将数据拷贝到新硬盘的时候也常常使用。</li>
</ul>
<p><strong>二.parted的使用方法及步骤</strong></p>
<p>1.对磁盘进行分区</p>
<p>(1) 命令方式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">parted /dev/sdb mklabel gpt mkpart 1 ext3 1 1T</span><br></pre></td></tr></table></figure>

<p>(2)交互式：</p>
<ul>
<li>命令：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">p (print) 	    #显示磁盘分区信息</span><br><span class="line">mktable 	#创建磁盘分区表 gpt/msdos</span><br><span class="line">mkpart 		#创建磁盘分区 mkpart primary 0 100</span><br><span class="line">rm 			#删除磁盘分区</span><br><span class="line">q 			#quit</span><br></pre></td></tr></table></figure>

<ul>
<li>分区步骤:</li>
</ul>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left">#parted  /dev/sdb</td>
<td align="left">对/dev/sdb进行分区或管理操作</td>
</tr>
<tr>
<td align="left">GNU Parted 3.1<br/>Using /dev/sda<br/>Welcome to GNU Parted! Type ‘help’ to view a list of commands.</td>
<td align="left">系统返回值</td>
</tr>
<tr>
<td align="left">(parted)   mklabel  gpt</td>
<td align="left">定义分区表格式常用的有msdos和gpt分区表格式，msdos不支持2TB以上（常用的有msdos和gpt分区表格式，msdos不支持2TB以上容量的磁盘，所以大于2TB的磁盘选gpt分区表格式）</td>
</tr>
<tr>
<td align="left">(parted) mkpart p1</td>
<td align="left">创建第1个分区，名称为p1</td>
</tr>
<tr>
<td align="left">File system type?  [ext2]?</td>
<td align="left">定义分区格式（不支持ext4，想分ext4格式分区，可以通过mkfs.ext4格式化ext4格式）</td>
</tr>
<tr>
<td align="left">Start？  1</td>
<td align="left">定义分区的起始位置（单位支持K,M,G,T）</td>
</tr>
<tr>
<td align="left">End？  1G</td>
<td align="left">定义分区的结束位置（单位支持K,M,G,T）</td>
</tr>
<tr>
<td align="left">(parted)   print</td>
<td align="left">查看当前分区情况</td>
</tr>
<tr>
<td align="left">Model: VMware, VMware Virtual S (scsi)<br/>Disk /dev/sda: 1074MB<br/>Sector size (logical/physical): 512B/512B<br/>Partition Table: gpt<br/>Disk Flags: <br/><br/>Number  Start   End     Size    File    system  Name  Flags<br/> 1      1049kB  1073MB      1072MB</td>
<td align="left">系统返回值</td>
</tr>
</tbody></table>
<ul>
<li>删除分区步骤：</li>
</ul>
<table>
<thead>
<tr>
<th>(parted)   rm</th>
<th>rm删除命令(删除前必须检查是否挂载)</th>
</tr>
</thead>
<tbody><tr>
<td>Partition number？ 1</td>
<td>删除第一个分区</td>
</tr>
<tr>
<td>(parted)   print</td>
<td>查看当前分区情况</td>
</tr>
<tr>
<td>(parted)   print</td>
<td>查看当前分区情况</td>
</tr>
<tr>
<td>Model:   ATA VBOX HARDDISK (scsibr/Disk   /dev/sda: 21.5GB<br/><br/>Sector   size (logical/physical): 512B/512B<br/><br/>Partition   Table: msdos<br/><br/>Number  Start     End   Size  File system  Name  Flags<br/></td>
<td>系统返回值</td>
</tr>
</tbody></table>
<h2 id="挂载与格式化"><a href="#挂载与格式化" class="headerlink" title="挂载与格式化"></a>挂载与格式化</h2><p><strong>挂载三部曲：</strong></p>
<ul>
<li>磁盘分区：fdisk、parted、gdisk；</li>
<li>格式化：创建文件系统（使磁盘可以存储文件）；</li>
<li>挂载：设置设备入口，给用户访问·。</li>
</ul>
<h3 id="第一部—创建磁盘分区"><a href="#第一部—创建磁盘分区" class="headerlink" title="第一部—创建磁盘分区"></a>第一部—创建磁盘分区</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">fdisk  </span><br><span class="line">n</span><br><span class="line">Disk /dev/sdb: 1073 MB, 1073741824 bytes, 2097152 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disk label type: dos</span><br><span class="line">Disk identifier: 0xc2483040</span><br><span class="line">   Device Boot     Start         End     Blocks   Id </span><br><span class="line">System</span><br><span class="line">/dev/sdb1            2048     2097151     1047552   83 </span><br><span class="line">Linux</span><br></pre></td></tr></table></figure>

<h3 id="第二部—格式化创建文件系统"><a href="#第二部—格式化创建文件系统" class="headerlink" title="第二部—格式化创建文件系统"></a>第二部—格式化创建文件系统</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> mkf.xfs /dev/sdb1</span> </span><br><span class="line">meta-data=/dev/sdb1              isize=512    agcount=4, </span><br><span class="line">agsize=65472 blks</span><br><span class="line">         =                       sectsz=512   attr=2, </span><br><span class="line">projid32bit=1</span><br><span class="line">         =                       crc=1        finobt=0, </span><br><span class="line">sparse=0</span><br><span class="line">data     =                       bsize=4096   </span><br><span class="line">blocks=261888, imaxpct=25</span><br><span class="line">         =                       sunit=0      swidth=0</span><br><span class="line">blks</span><br><span class="line">naming   =version 2              bsize=4096   ascii-ci=0</span><br><span class="line">ftype=1</span><br><span class="line">log      =internal log           bsize=4096   blocks=855, </span><br><span class="line">version=2</span><br><span class="line">         =                       sectsz=512   sunit=0</span><br><span class="line">blks, lazy-count=1</span><br><span class="line">realtime =none                   extsz=4096   blocks=0, </span><br><span class="line">rtextents=0</span><br></pre></td></tr></table></figure>

<h3 id="第三部—挂载"><a href="#第三部—挂载" class="headerlink" title="第三部—挂载"></a>第三部—挂载</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mount 设备 入口</span><br><span class="line">mount /d v/sdb1   /mnt  </span><br><span class="line">[root@oldboyedu ~]# mount /de/sdb1 /mnt/</span><br><span class="line">[root@oldboyedu ~]# df -h</span><br><span class="line">Filesystem               Size Used Avail Use% Mounted on</span><br><span class="line">devtmpfs                 475M     0 475M   0% /dev</span><br><span class="line">tmpfs                   487M     0 487M   0% /dev/shm</span><br><span class="line">tmpfs                   487M  7.7M 479M   2% /run</span><br><span class="line">tmpfs                   487M     0 487M   0% </span><br><span class="line">/sys/fs/cgroup</span><br><span class="line">/dev/mapper/centos-root   37G   16G   22G  43% /</span><br><span class="line">/dev/sda1               1014M 137M 878M  14% /boot</span><br><span class="line">tmpfs                     98M     0   98M   0% </span><br><span class="line">/run/user/0</span><br><span class="line">/dev/sdb1               1020M   33M 988M   4% /mnt</span><br></pre></td></tr></table></figure>

<h3 id="永久挂载"><a href="#永久挂载" class="headerlink" title="永久挂载"></a>永久挂载</h3><p>上述挂载方式为临时挂载方式接下来介绍两种永久挂载方式：</p>
<ul>
<li>方法一：通用写法，把挂载命令写到开机执行，开机启动文件 /etc/rc.d/rc.loacl</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/rc.d/rc.local</span><br><span class="line">把挂载命令写到开机执行文件上</span><br><span class="line">mount /dev/sdb /mount</span><br><span class="line">chmod +x /etc/rc.d/rc.local</span><br></pre></td></tr></table></figure>

<ul>
<li>方法二：专业写法，开机开机自动挂载信息表    /etc/fstab</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/etc/fstab文件内容格式说明</span><br><span class="line">/dev/mapper/centos-root /                       xfs     defaults        0 0</span><br><span class="line">UUID=0b6d9742-6dc9-434e-acb3-88d46bc5210c /boot                   xfs     defaults        0 0</span><br><span class="line">/dev/mapper/centos-home /home                   xfs     defaults        0 0</span><br><span class="line">/dev/mapper/centos-swap swap                    swap    defaults        0 0</span><br><span class="line"></span><br><span class="line">弟1列：备名称、uuid</span><br><span class="line">第2列：挂载点</span><br><span class="line">第3列：文件系统类型</span><br><span class="line">第4列：挂载选项</span><br><span class="line">第5列：是否备份</span><br><span class="line">第6列：是否开机检查</span><br></pre></td></tr></table></figure>

<h2 id="SWAP"><a href="#SWAP" class="headerlink" title="SWAP"></a>SWAP</h2><ul>
<li>swap 交换分区，内存不足时将物理内存充当临时内存。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">通过创建文件增加swap</span><br><span class="line">1）创建文件 dd  if=/dev/zero  of=/tmp/swap  bs=1M count=500</span><br><span class="line">2)转换为swap 	 mkswap /tmp/swap</span><br><span class="line">3)激活 		 swapon /tmp/swap</span><br><span class="line"></span><br><span class="line">free -h 查看系统内存情况</span><br><span class="line">swapon -s 查看当前系统swap组成</span><br></pre></td></tr></table></figure>

<ul>
<li><p>永久生效</p>
<ul>
<li>swapon /tmp/swap 命令写到 /etc/rc.local</li>
<li>将swap分区属性写到 /etc/fstab</li>
</ul>
</li>
<li><p>umount /mnt 卸载</p>
</li>
<li><p>umount -lf 强制卸载</p>
</li>
</ul>
<script src='https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/mouse_snow.min.js'></script>

















]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
      <tags>
        <tag>磁盘</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux容器（Container）发展史</title>
    <url>/%E4%BA%91%E8%AE%A1%E7%AE%97/Linux%E5%AE%B9%E5%99%A8(Container)%E5%8F%91%E5%B1%95%E5%8F%B2/</url>
    <content><![CDATA[<script src='https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/mouse_snow.min.js'></script>

<script src='https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/mouse_snow.min.js'></script>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">原文连接:</span><br><span class="line">	https://www.cnblogs.com/yinzhengjie2020/p/14013388.html</span><br></pre></td></tr></table></figure>

<h1 id="一-容器-Container-技术概述"><a href="#一-容器-Container-技术概述" class="headerlink" title="一.容器(Container)技术概述"></a>一.容器(Container)技术概述</h1><h2 id="1-什么是容器-Container"><a href="#1-什么是容器-Container" class="headerlink" title="1.什么是容器(Container)"></a>1.<strong>什么是容器(Container)</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">容器是一种基础工具；泛指任何可以用于容纳其它物品的工具，可以部分或完全封闭，被用于容纳，存储，运输物品；物体可以被放置在容器中，而容器则可以保护内容物。</span><br><span class="line"></span><br><span class="line">　　人类使用容器的历史至少有十万年，甚至可能有数百万的历史。以下是我们生活中常见到的容器的类型:</span><br><span class="line">       瓶:</span><br><span class="line">           指口部比腹部窄小，颈长的容器。</span><br><span class="line">       罐:</span><br><span class="line">           指那些开口较大，一般为近圆筒形的器皿。</span><br><span class="line">       箱:</span><br><span class="line">           通常是立方体或圆柱体。形状固定。</span><br><span class="line">       篮:</span><br><span class="line">           以条形物编织而成。</span><br><span class="line">       桶:</span><br><span class="line">           一种圆柱形的容器。</span><br><span class="line">       袋:</span><br><span class="line">           柔性材料制成的容器，形状会受内容物而变化。</span><br><span class="line">       翁:</span><br><span class="line">           通常是指陶制，口小肚大的容器。</span><br><span class="line">       碗:</span><br><span class="line">           用来盛载食物的容器。</span><br><span class="line">       柜:</span><br><span class="line">           指由一个盒组成的家俱。</span><br><span class="line">       鞘:</span><br><span class="line">           用于装载刀刃的容器。</span><br><span class="line"></span><br><span class="line">   综上所述，想必大家对容器这个概念应该有所了解，说了这么多，我想表达的是: &quot;计算机中的技术来源于现实生活&quot;。</span><br><span class="line"></span><br><span class="line">   那计算机所指的容器(Container)到底是什么呢？可能你会说它是能装&quot;东西&quot;的一个技术，那这个&quot;东西&quot;到底是啥呢？自然是就是我们熟悉的所有应用程序(Application Program)啦。</span><br><span class="line"></span><br><span class="line">   我们以Linux容器为例，它是运行在操作系统上的一系列进程。运行这些进程所需的所有文件都由另一个只读镜像文件提供，这意味着从&quot;开发 -&gt; 测试 --&gt; 生产&quot;的整个过程中，Linux容器都具有可移植性和一致性。</span><br><span class="line"></span><br><span class="line">   换句话说，Linux容器技术能够让您对应用及其整个运行时环境(包括全部所需文件)一起进行打包或隔离。从而让您可以在不同环境(如开发、测试和生产等环境)之间轻松迁移应用，同时还可保留应用的全部功能。</span><br><span class="line"></span><br><span class="line">   因而，相对于依赖重复传统测试环境的开发渠道，容器的运行速度要快得多。容器比较普遍也易于使用，因此也成了IT安全方面的重要组成部分。将安全性内置于容器管道，可以为您的基础架构增添防护，从而保障容器的可靠性、可扩展性和信赖度。</span><br><span class="line">   </span><br><span class="line">   推荐阅读: </span><br><span class="line">       https://www.redhat.com/zh/topics/containers/whats-a-linux-container。</span><br><span class="line">       https://www.redhat.com/zh/topics/security/container-security</span><br><span class="line">       https://www.redhat.com/zh/topics/security</span><br><span class="line">       https://www.docker.com/resources/what-container</span><br><span class="line">       https://docs.docker.com/get-started/#what-is-a-container</span><br></pre></td></tr></table></figure>



<h2 id="2-为什么要用容器"><a href="#2-为什么要用容器" class="headerlink" title="2.为什么要用容器"></a>2.为什么要用容器</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">场景:</span><br><span class="line">　　　　假设您在使用一台笔记本电脑开发一个应用，而且您的开发环境具有特定的配置。其他开发人员身处的环境配置可能稍有不同。您正在开发的应用不止依赖于您当前的配置，还需要某些特定的库、依赖项和文件。</span><br><span class="line">　　　　与此同时，您的企业还拥有标准化的开发和生产环境，有着自己的配置和一系列支持文件。您希望尽可能多在本地模拟这些环境，而不产生重新创建服务器环境的开销。</span><br><span class="line"></span><br><span class="line">　　根据以上场景分析，您要考虑如何确保应用能够在这些环境中运行和通过质量检测，并且在部署过程中不出现令人头疼的各种依赖问题，也无需重新编写代码和进行故障修复呢？答案就是使用容器。</span><br><span class="line">　　　　(1)容器可以确保您的应用拥有必需的库、依赖项和文件，让您可以在生产中自如地迁移这些应用，无需担心会出现任何负面影响。</span><br><span class="line">　　　　(2)实际上，您可以将容器镜像中的内容，视为Linux发行版的一个安装实例，因为其中完整包含RPM软件包、配置文件等内容。但是，安装容器镜像发行版，要比安装新的操作系统副本容易得多。这样可以避免不必要的麻烦，做到皆大欢喜。</span><br><span class="line"></span><br><span class="line">　　虽然这只是一个常见情况的示例，但在需要很高的可移植性、可配置性和隔离的情况下，我们可以利用Linux容器通过很多方式解决难题。 Linux容器的价值在于，它能加速开发并满足新出现的业务需求。</span><br><span class="line"></span><br><span class="line">　　在某些情形中(如通过Apache Kafka进行实时数据流处理)，容器是不可或缺的，因为它们是提供应用所需的可扩展性的唯一途径。 无论基础架构是在企业内部还是在云端，或者混合使用两者，容器都能满足您的需求。当然，选择正确的容器平台也同样重要。</span><br><span class="line"></span><br><span class="line">　　在云服务范畴内，CaaS被认为是基础架构即服务(IaaS)的一种子集，介于IaaS和平台即服务(PaaS)之间。  CaaS的基本资源为容器，它是云原生应用和微服务的常见部署机制。此外，CaaS还可以提高环境之间的可移植性，无论是混合环境还是多云环境。</span><br><span class="line"></span><br><span class="line">　　使用容器有很多好处，以下是比较容器可圈可点的特性:</span><br><span class="line">       (1)可移植性：</span><br><span class="line">           用容器开发的应用拥有运行所需的一切，并可以部署在包括私有云和公共云在内的多种环境中。</span><br><span class="line">           可移植性也意味着灵活性，因为您可以更轻松地在环境和提供商之间移动工作负载。 </span><br><span class="line">       (2)可扩展性：</span><br><span class="line">           容器具有水平扩展的功能，这意味着用户可以在同一集群中成倍增加相同容器的数量，从而根据需要进行扩展。</span><br><span class="line">           通过仅在需要时使用和运行所需的内容，可以大大降低成本。 </span><br><span class="line">       (3)高效性：</span><br><span class="line">           容器所需的资源要少于虚拟机(VM)，因为它们不需要虚拟单独的操作系统。</span><br><span class="line">           您可以在单个服务器上运行多个容器，而且它们需要较少的裸机硬件，这意味着成本更低。</span><br><span class="line">       (4)更高的安全性：</span><br><span class="line">           容器之间彼此隔离，这意味着在一个容器遭到破坏的情况下，其他容器并不会受到影响。 </span><br><span class="line">       (5)速度：</span><br><span class="line">           由于容器相对于操作系统具有自主性，因此其启动和停止仅需几秒钟的时间。这也加快了开发和运维工作，同时带来了更快、更流畅的用户体验。</span><br></pre></td></tr></table></figure>



<h1 id="二-常见的容器管理技术概述"><a href="#二-常见的容器管理技术概述" class="headerlink" title="二.常见的容器管理技术概述"></a>二.常见的容器管理技术概述</h1><h2 id="1-Unix-chroot"><a href="#1-Unix-chroot" class="headerlink" title="1.Unix chroot"></a>1.Unix chroot</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">　　容器的概念始于1979年前后的UNIX chroot，它是一个UNIX操作系统上的系统调用，用于将一个进程及其子进程的根目录改变到文件系统中的一个新位置，让这些进程只能访问到该目录。</span><br><span class="line"></span><br><span class="line">　　这个功能的想法是为每个进程提供独立的磁盘空间。其后在1982年前后，它被加入到了BSD系统中。</span><br><span class="line"></span><br><span class="line">　　温馨提示:</span><br><span class="line">　　　　BSD是Unix的扩展版本，FreeBSD是BSD发行版最流行的系统。</span><br></pre></td></tr></table></figure>



<h2 id="2-Unix-FreeBSD-jail"><a href="#2-Unix-FreeBSD-jail" class="headerlink" title="2.Unix FreeBSD jail"></a>2.Unix FreeBSD jail</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在2000年前后，FreeBSD jail这种技术可将FreeBSD系统分区为多个子系统(也称为Jail)。Jail是作为安全环境而开发的，系统管理员可与企业内部或外部的多个用户共享这些Jail。</span><br><span class="line">   </span><br><span class="line">　　Jail的目的是让进程在经过修改的chroot环境中创建，而不会脱离和影响整个系统。在chroot环境中，对文件系统、网络和用户的访问都实现了虚拟化。　　</span><br><span class="line">　　</span><br><span class="line">　　尽管Jail在实施方面存在局限性，但最终人们找到了脱离这种隔离环境的方法。但这个概念非常有吸引力。</span><br><span class="line"></span><br><span class="line">　　推荐阅读:</span><br><span class="line">       https://www.freebsd.org/doc/handbook/jails.html</span><br><span class="line">       https://www.freebsd.org/</span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/5460EC51825E46C0BE8059FAA9E676D9?method=download&shareKey=9d5b906bf6c8d799d10c4a1979168b43" alt="img"></p>
<h2 id="3-Linux-VServer"><a href="#3-Linux-VServer" class="headerlink" title="3.Linux-VServer"></a>3.Linux-VServer</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2001年前后，通过Jacques Gélinas的VServer项目，隔离环境的实施进入了Linux领域。正如Gélinas所说:&quot;这项工作的目的是高度独立且安全的单一环境中运行多个通用Linux服务器&quot;。 </span><br><span class="line"></span><br><span class="line">　　Linux-VServer也是一个操作系统级虚拟化解决方案。Linux-VServer对Linux内核进行虚拟化，这样多个用户空间环境又称为&quot;Virtual Private Server&quot;(简称&quot;VPS&quot;)就可以单独运行，而不需要互相了解。</span><br><span class="line"></span><br><span class="line">　　Linux-VServer通过修改Linux内核实现用户空间的隔离。Linux VServer也使用了chroot来为每个VPS隔离root目录。虽然chroot允许指定新root目录，但还是需要其他一些功能(称为Chroot-Barrier)来限制VPS脱离其隔离的root目录回到上级目录。</span><br><span class="line"></span><br><span class="line">　　给定一个隔离的root目录之后，每个VPS就可以拥有自己的用户列表和root密码。在完成了这项针对Linux中多个受控制用户空间的基础性工作后，Linux容器开始逐渐成形并最终发展成了现在的模样。</span><br><span class="line">　　</span><br><span class="line">　　如下图所示，2.4和2.6版本的Linux内核支持Linux-VServer，它可以运行于很多平台之上，包括 x86、x86-64、SPARC、MIPS、ARM 和 PowerPC。</span><br><span class="line">　　</span><br><span class="line">　　温馨提示:　　　　</span><br><span class="line">		同年时间(即2001年)，Parallels公司发布了Virtuozzo Container产品，只不过该版本是商用版本。直到2005年才基于Virtuozzo Containers研发了OpenVZ进行开源。</span><br><span class="line">	</span><br><span class="line">	推荐阅读:</span><br><span class="line">        http://linux-vserver.org/Welcome_to_Linux-VServer.org</span><br><span class="line">     </span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/FFB7E088B246455D914EE9CA1FFA2B8C?method=download&shareKey=c2fdcdd84be6c9a319f433609374d628" alt="img"></p>
<h2 id="4-Oracle-Solaris-Container-Sun公司的Solaris与FreeBSD，Mac系统一样，均是Unix扩展版-即BSD-的发行版"><a href="#4-Oracle-Solaris-Container-Sun公司的Solaris与FreeBSD，Mac系统一样，均是Unix扩展版-即BSD-的发行版" class="headerlink" title="4.Oracle Solaris Container(Sun公司的Solaris与FreeBSD，Mac系统一样，均是Unix扩展版(即BSD)的发行版)"></a>4.Oracle Solaris Container(Sun公司的Solaris与FreeBSD，Mac系统一样，均是Unix扩展版(即BSD)的发行版)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2004年前后，作为Solaris 10中具有突破性意义的关键技术之一，由Sun公司虚拟化专家Joost Pronk van Hoogeveen、Jeff Victor和Chien-Hua Yen等研发的Solaris Containers能够促进服务器整合，并提高应用程序可用性和易管理性。</span><br><span class="line"></span><br><span class="line">　　Solaris网格容器由两个主要组件构成：Solaris区域(Zone)和Solaris资源管理器(SRM)。SRM 管理每个容器接收到的物理系统资源，而Solaris区域则控制名称空间隔离。&quot;区域&quot;和SRM一起构成Solaris容器的基础。</span><br><span class="line"></span><br><span class="line">　　在2008年前后Sun以10亿美元收购开源数据库公司MySQL，做为一个开源的关系型数据库管理系统，MySQL在市场上受到了广泛的欢迎，并成为流行的网站架构方式LAMP(Linux+Apache+MySQL+PHP)的一部分。</span><br><span class="line">　　　　</span><br><span class="line">　　2009年4月20日，加利福尼亚州圣克拉拉市Sun Microsystems（NASDAQ：JAVA）和Oracle Corporation（NASDAQ：ORCL）今天宣布，他们已达成最终协议，根据该协议，Oracle将以每股9.50美元的现金价格收购Sun普通股。</span><br><span class="line">　　　　交易总价值约为74亿美元，扣除Sun的现金和债务后为56亿美元。曾经的工作站之王、Unix之王和缔造了Solaris、Java传奇的巨人Sun倒下了</span><br><span class="line"></span><br><span class="line">　　Java和JavaScript啥关系?　　　　</span><br><span class="line">　　	Java由SUN公司研发，SUN公司和网景(Netscape)公司的是合作关系。JavaScript在1995年由Netscape公司(该公司成立于1994年)的Brendan Eich，在网景导航者浏览器上首次设计实现而成。</span><br><span class="line">　　　　因为Netscape与Sun合作，Netscape管理层希望它外观看起来像Java，因此取名为JavaScript。但实际上它的语法风格与Self及Scheme较为接近。JavaScript的标准是ECMAScript 。</span><br><span class="line">　　　　1998年11月，网景被美国在线（American OnLine，AOL）收购，而后来美国在线和时代华纳合并，之后再独立。美国在线依然使用网景这品牌。</span><br><span class="line">　　　　2007年12月28日，美国在线在博客表示将停止网景浏览器的开发，并于2008年3月1日停止安全更新和所有的技术支持，并建议用户转移使用Mozilla Firefox浏览器。</span><br><span class="line">　　　　这就意味着于1994年问世的Netscape将正式退出历史舞台。于2008年3月1日停止支持的网景浏览器后，保留了门户网站Netscape。此外也有经营着一个以网景为名的廉价互联网服务。</span><br><span class="line"></span><br><span class="line">　　推荐阅读:</span><br><span class="line">　　　　https://www.lampchina.net/ask/MTM3MTkwMg.html</span><br><span class="line">　　　　https://www.fujitsu.com/global/products/computing/servers/unix/sparc-enterprise/software/solaris10/container/</span><br><span class="line">　　　　https://baike.baidu.com/item/%E7%BD%91%E6%99%AF/70176?fromtitle=netscape&amp;fromid=2778944</span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/DAAE3B5719C74AC082F59E02370867CB?method=download&shareKey=890184d5eeabed4b0732a5d940d1ee46" alt="img"></p>
<h2 id="5-Parallels-Virtuozzo-OpenVZ"><a href="#5-Parallels-Virtuozzo-OpenVZ" class="headerlink" title="5.Parallels Virtuozzo/OpenVZ"></a>5.Parallels Virtuozzo/OpenVZ</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2005年前后，前面我们提到过，Virtuozzo(2001年发布)是SWsoft公司（目前SWsoft已经改名为Parallels）的操作系统虚拟化软件的命名，Virtuozzo是商业解决方案，而OpenVZ是以Virtuozzo为基础的开源项目，它们采用的也是操作系统级虚拟化技术。</span><br><span class="line"></span><br><span class="line">　　OpenVZ类似于Linux-VServer，它通过对Linux内核进行补丁来提供虚拟化、隔离、资源管理和状态检查。每个OpenVZ容器都有一套隔离的文件系统、用户及用户组等。</span><br><span class="line"></span><br><span class="line">　　OpenVZ是Linux的基于容器的虚拟化。OpenVZ在单个物理服务器上创建多个安全的，隔离的Linux容器(也称为VE或VPS)，以提高服务器利用率并确保应用程序不冲突。</span><br><span class="line"></span><br><span class="line">　　每个容器的执行和执行都完全像独立服务器一样。容器可以独立地重新引导，并且具有root用户访问权限，用户，IP地址，内存，进程，文件，应用程序，系统库和配置文件。</span><br><span class="line"></span><br><span class="line">　　推荐阅读:</span><br><span class="line">　　　　https://wiki.openvz.org/Main_Page</span><br><span class="line">　　　　https://wiki.openvz.org/Quick_installation</span><br><span class="line">　　　　https://wiki.openvz.org/Download</span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/19B0AC02D1FD40F2A970D566E4AAC044?method=download&shareKey=2f809f15505179b4fd510a02797f544a" alt="img"></p>
<h2 id="6-Linux-Kernel支持Cgroup-控制组-和NameSpace-命名空间-技术"><a href="#6-Linux-Kernel支持Cgroup-控制组-和NameSpace-命名空间-技术" class="headerlink" title="6.Linux Kernel支持Cgroup(控制组)和NameSpace(命名空间)技术"></a>6.Linux Kernel支持Cgroup(控制组)和NameSpace(命名空间)技术</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">早期，Jail和VServer基本上都是在chroot概念之上稍作改进和其他一些标准工具的组合来实现此特定的虚拟服务器模型。很快，更多技术结合进来，让这种隔离方法从构想变为现实。</span><br><span class="line"></span><br><span class="line">　　2007年前后，Linux内核支持Cgroup和NameSpace技术，这两种技术在增加对Linux的整体控制的同时，也成为了保持环境隔离的重要框架。</span><br><span class="line"></span><br><span class="line">　　NameSpace(命名空间)主要包含以下六种技术:</span><br><span class="line">　　　　MNT Namespace(提供磁盘挂载点和文件系统的隔离能力):</span><br><span class="line">　　　　　　每个容器都要有独立的根文件系统用户空间，以实现在容器里面启动服务并且使用容器的运行环境。换句话说，就是在容器里面不能访问宿主机的资源，宿主机是使用了chroot技术把容器锁定到一个指的运行目录里面。</span><br><span class="line">　　　　　　举个例子:</span><br><span class="line">　　　　        一个宿主机是ubuntu的服务器，可以在里面启动一个centos运行环境的容器并且在里面启动一个Nginx服务，此Nginx运行时使用的运行环境就是centos系统目录的运行环境。</span><br><span class="line">　　　　IPC Namespace(提供进程间通信的隔离能力):</span><br><span class="line">　　　　　　一个容器内的进程间通信，允许一个容器内的不同进程的(内存,缓存等)数据访问，但是不能跨容器访问其他容器的数据 。</span><br><span class="line">　　　　UTS Namespace(提供主机名隔离能力):</span><br><span class="line">　　　　　　用于系统标识,其中包含了hostname和域名domainname,它使得一个容器拥有属于自己hostname标识,这个主机名标识独立于宿主机系统和其上的他容器 。</span><br><span class="line">　　　　PID Namespace(提供进程隔离能力):</span><br><span class="line">　　　　　　CentOS Linux系统中，有一个PID为1的进程(init/systemd)是其他所有进程的父。</span><br><span class="line">　　　　　　在每个容器内也要有一个父进程来管理其下属的子进程，多个容器进程的PID namespace进程隔离(比如PID编号重复、容器内的主进程与回收子进程等)。</span><br><span class="line">　　　　Net Namespace(提供网络隔离能力):</span><br><span class="line">　　　　　　每一个容器都类似于虚拟机一样有自己的网卡，监听端口，TCP/IP协议栈等。</span><br><span class="line">　　　　　　以Docker为例，使用network namespace启动一个vethX接口，这样你的容器将拥有它自己的桥接ip地址，通常是docker0。</span><br><span class="line">　　　　　　上面提到的docker0本质上是Linux的虚拟网桥(Virtual Bridge)，网桥是在OSI七层模型的数据链路网络设备，通过mac地址对网络进行划分，并且在不同网络直接传递数据。</span><br><span class="line">　　　　User Namespace(提供用户隔离能力):</span><br><span class="line">　　　　　　各个容器内可能会出现重名的用户和用户组名称,或重复的用户UID或者GID,那么怎隔离各个容器内的用户空间呢？</span><br><span class="line">　　　　　　User Namespace允许在各个宿主机的各个容器空间内创建相同的用户名以及相同的用户UID和GID，只是会用户的作用范围限制在每个容器内。</span><br><span class="line">　　　　　　即A容器和B容器可以有相同的用户名称和ID的账户，但是此用户的有效范围仅是当前容器内，不能访问另外一个容器内的文件系统，即相互隔离，互不影响，永不相见。</span><br><span class="line"></span><br><span class="line">　　Cgroups:</span><br><span class="line">　　　　一个容器如果不对其做任何资源限制，则宿主机(也称为物理机，英文名称为:&quot;Physical machine&quot;)会允许其占用无限大的内存空间，有时候会因为代码bug程序会一直申请内存，直到把宿主机内存占完。</span><br><span class="line">　　　　综上所述，为了避免此类的问题出现，宿主机有必要对容器进行资源分配限制，比如CPU，内存，磁盘等。</span><br><span class="line">　　　　Linux Cgroups的全称是Linux Control Groups，它最主要的作用就是限制一个进程组能够使用的资源上限，包括CPU，内存，磁盘，网络带宽等等。</span><br><span class="line">　　　　此外，Linux Cgroups还能够对进程优先级设置，以及将进程挂起和恢复等操作。</span><br><span class="line"></span><br><span class="line">　　温馨提示:</span><br><span class="line">　　　　如下图所示，有关的NameSpace(命名空间)各种核心技术所支持的Linux Kernel的发行版本。因此推荐大家使用Linux Kernel 3.8+的版本哟~</span><br><span class="line">　　　　如果您使用的是Ubuntu就不用担心Linux Kernel版本啦，因为它使用的Kernel版本要比CentOS的新，但如果您要是想使用CentOS发行，推荐使用CentOS 7.6+版本。</span><br><span class="line"></span><br><span class="line">   参考连接:</span><br><span class="line">       https://www.cnblogs.com/yinzhengjie/p/12183066.html</span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/52EB4ADF496F4B25B049BB3864CCD9A9?method=download&shareKey=cee90ddb278ddaa76c3489247e270793" alt="img"></p>
<h2 id="7-LXC-LXD"><a href="#7-LXC-LXD" class="headerlink" title="7.LXC/LXD"></a>7.LXC/LXD</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">由于inux Kernel支持Cgroup(控制组)和NameSpace(命名空间)技术，这意味着一切都可在Linux内核中实现虚拟化，因此推动了容器的进一步发展。</span><br><span class="line"></span><br><span class="line">　　LXC:</span><br><span class="line">　　　　2008年前后，作为一个开源容器平台，Linux容器项目LXC是众所周知的工具，模板，库和语言绑定集。它的级别很低，非常灵活，几乎涵盖了上游内核支持的每个遏制功能。同年，RedHat公司发布了用于管理虚拟化平台的Libvirt工具。</span><br><span class="line">　　　　LXC是Linux内核包含功能的用户空间接口。通过功能强大的API和简单的工具，它使Linux用户可以轻松地创建和管理系统或应用程序容器。LXC采用简单的命令行界面，可改善容器启动时的用户体验。</span><br><span class="line">　　　　LXC提供了一个操作系统级的虚拟化环境，可在许多基于Linux的系统上安装。在Linux发行版中，可能会通过其软件包存储库来提供LXC。</span><br><span class="line">　　　　当前的LXC使用以下内核功能来包含进程：</span><br><span class="line">　　　　　　(1)Kernel namespaces (ipc, uts, mount, pid, network and user);</span><br><span class="line">　　　　　　(2)Apparmor and SELinux profiles;</span><br><span class="line">　　　　　　(3)Seccomp policies;</span><br><span class="line">　　　　　　(4)Chroots (using pivot_root);</span><br><span class="line">　　　　　　(5)Kernel capabilities;</span><br><span class="line">　　　　　　(6)CGroups (control groups);</span><br><span class="line">　　　　LXC容器通常被认为是chroot和成熟的虚拟机之间的中间对象。LXC的目标是创建一个与标准Linux安装尽可能接近的环境，而不需要单独的内核。</span><br><span class="line">　　　　LXC的意思是LinuX Containers，它是第一个最完善的Linux容器管理器的实现方案，是通过cgroups和Linux名字空间namespace实现的。</span><br><span class="line">　　　　LXC存在于liblxc库中，提供了各种编程语言的API实现，包括Python3、Python2、Lua、Go、Ruby和Haskell等。</span><br><span class="line">　　　　与其它容器技术不同的是，LXC可以工作在普通的Linux内核上，而不需要增加补丁。现在LXC project是由Canonical Ltd.赞助的项目，目前由Canonical公司赞助并托管的。</span><br><span class="line"></span><br><span class="line">　　LXD: </span><br><span class="line">　　　　虽然LXC使得用户能够通过简单的命令行界面轻松地启动使用容器，但是和我们过去使用的虚拟机来讲，它的复杂程度并没有多大降低，而且其隔离性依旧没有虚拟机好。　　</span><br><span class="line">　　　　LXC最大的好处就是在性能和资源上有所节约，但是在大规模容器使用上LXC依然没有找到很好的突破口，于是后来就出现了LXD，Docker等技术。</span><br><span class="line">　　　　LXD是新的LXC体验。它使用一个命令行工具来管理容器，从而提供了全新的直观用户体验。可以通过REST API以透明方式通过网络管理容器。通过与OpenNebula和OpenStack等云平台集成，它还可以用于大规模部署。 </span><br><span class="line">　　　　LXD是下一代系统容器管理器。它提供类似于虚拟机的用户体验，但是使用Linux容器。它基于映像，并带有可用于各种Linux发行版的预制映像，并且基于非常强大但非常简单的REST API构建。 </span><br><span class="line"></span><br><span class="line">　　推荐阅读: </span><br><span class="line">　　　　https://www.freedesktop.org/wiki/Software/systemd/</span><br><span class="line">　　　　https://linuxcontainers.org/</span><br><span class="line">　　　　https://linuxcontainers.org/lxc/introduction/</span><br><span class="line">　　　　https://linuxcontainers.org/lxd/introduction/</span><br><span class="line">　　　　http://www.canonical.com/</span><br><span class="line">　　　　https://libvirt.org/</span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/41A1C4F35B914459A3CA9553F7963BF1?method=download&shareKey=cee7e1cfadecd718bf40d47dc3d2da1a" alt="img"></p>
<h2 id="8-Docker"><a href="#8-Docker" class="headerlink" title="8.Docker"></a>8.Docker</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2013年dotCloud公司首次在pycon官网首次公布了Docker开源版本。Docker带来了一种先进的软件交付方式，即通过容器进行进行软件的交付。并对外宣传的是Build(本地编译)，Ship(传输到其他服务器节点)，Run(可以移植到指定的服务器运行)。</span><br><span class="line"></span><br><span class="line">　　实际上我们可以使用docker build将代码的运行环境制作成镜像，通过dock push将镜像发布至私有或共有的docker仓库。其他人可以通过dock pull下载你提交的镜像，而后使用docker run将指定在镜像启动。此过程可以排除环境依赖等问题。</span><br><span class="line"></span><br><span class="line">　　docker这款开源软件可以有效的解决(程序员开发的)程序在运行时环境差异而带来的一系列问题，达到&quot;Build once, Run anywhere&quot;的目标。</span><br><span class="line"></span><br><span class="line">　　此后docker也称为了容器的代名词(就想Hadoop成了大数据的代名词一样)，并成为容器时代的引领者。关于Docker容器的历史，架构，应用场景等我这里不做赘述，感兴趣的小伙伴可参考我另外一篇笔记。 　　</span><br><span class="line">   Docker容器的应用场景:</span><br><span class="line">　　　　(1)应用程序打包和发布;</span><br><span class="line">　　　　(2)应用程序隔离；</span><br><span class="line">　　　　(3)持续集成;</span><br><span class="line">　　　　(4)部署微服务;</span><br><span class="line">　　　　(5)快速搭建测试环境;</span><br><span class="line">　　　　(6)提供CAAS产品;</span><br><span class="line">　　　　</span><br><span class="line">　　推荐阅读: 　　　　 　　　　</span><br><span class="line">　　　　https://www.cnblogs.com/yinzhengjie2020/p/14017860.html 　　　　</span><br><span class="line">　　　　https://www.cnblogs.com/yinzhengjie2020/p/14022268.html 　　　　</span><br><span class="line">　　　　https://us.pycon.org/2013/</span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/724E98446FE142399ECC746F000399A0?method=download&shareKey=1706a7eabac30938ff3ddd2f2b17e456" alt="img"></p>
<h2 id="9-RedHat-已被IBM收购-的CoreOS-rkt容器技术"><a href="#9-RedHat-已被IBM收购-的CoreOS-rkt容器技术" class="headerlink" title="9.RedHat(已被IBM收购)的CoreOS rkt容器技术"></a>9.RedHat(已被IBM收购)的CoreOS rkt容器技术</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Rkt诞生于2014年11月末，我在GitHub上发现他在2014年11月27日就发布了&quot;v0.0.0&quot;版本，&quot;v0.1.0&quot;版本是在同年的12月1日发布的。</span><br><span class="line"></span><br><span class="line">   Rkt是一种与Docker类似的容器引擎，由CoreOS公司主导，得到了Redhat、Google、Vmware等公司的支持，更加专注于解决安全、兼容、执行效率等方面的问题。</span><br><span class="line"></span><br><span class="line">   CoreOS公司最早是Docker的支持者，其产品CoreOS操作系统是适用于企业的轻量级容器化的Linux发行版，是Docker生态圈的重要一员。</span><br><span class="line">   </span><br><span class="line">   随着Docker在容器行业变得逐渐强大，Docker也越来越臃肿，CoreOS公司希望有一个更加开放和中立的容器标准，因此推出了自己的容器计划，很明显CoreOS公司也想在容器方面有一席之地。</span><br><span class="line"></span><br><span class="line">   就这样，CoreOS公司成为了Docker公司的容器引擎竞争对手。由于Docker已经深入人心，尽管Rkt也很优秀，但很少有人愿意将Docker技术栈迁移到Rkt技术栈。最终容器之战Docker占领了大部分市场。</span><br><span class="line"></span><br><span class="line">   2018年4月16日是发布的最新rkt容器工具，目前该项目已经停止维护，因此生产环境中不推荐大家使用该容器技术。推荐使用主流的容器工具，如Docker，Pouch，podman。</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   参考链接:</span><br><span class="line">       https://github.com/rkt/rkt/releases</span><br><span class="line">       https://www.sohu.com/a/216850450_468741</span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/8612FE371E8E4095BAD4891027AFBCD9?method=download&shareKey=d4bbef959f682552830c095de0baf589" alt="img"></p>
<h2 id="10-阿里开源的Pouch容器技术"><a href="#10-阿里开源的Pouch容器技术" class="headerlink" title="10.阿里开源的Pouch容器技术"></a>10.阿里开源的Pouch容器技术</h2><p><img src="Linux%E5%AE%B9%E5%99%A8(Container)%E5%8F%91%E5%B1%95%E5%8F%B2.assets/D4C678E2013948C6ADF8653042E5F162" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2017年11月19日上午，在中国开源年会现场，阿里巴巴正式开源了基于Apache 2.0协议的容器技术Pouch。</span><br><span class="line"></span><br><span class="line">　　Pouch Container是阿里巴巴集团创建的一个开源项目，旨在促进集装箱技术的发展。</span><br><span class="line"></span><br><span class="line">　　Pouch Container的愿景是改善容器生态系统并促进容器标准OCI（开放容器计划），从而使容器技术成为云时代应用程序开发的基础。</span><br><span class="line"></span><br><span class="line">　　Pouch Container可以打包，交付和运行任何应用程序。它为应用程序提供了轻量级的运行时环境，具有强大的隔离性和最小的开销。Pouch Container将应用程序与变化的运行时环境隔离开来，并最大程度地减少了操作工作量。</span><br><span class="line"></span><br><span class="line">　　Pouch Container可以最大程度地减少应用程序开发人员编写本机应用程序或将旧版应用程序迁移到Cloud平台的工作。</span><br><span class="line"></span><br><span class="line">　　Pouch是一款轻量级的容器技术，拥有快速高效、可移植性高、资源占用少等特性，主要帮助阿里更快的做到内部业务的交付，同时提高超大规模下数据中心的物理资源利用率。</span><br><span class="line"></span><br><span class="line">　　温馨提示:</span><br><span class="line">　　　　上图是Pouch容器的内部实现架构图，下图是Pouch容器的生态系统图。</span><br><span class="line">　　　　在Pouch Container的路线图中，我们将拥抱生态系统作为主要目标。对于上层业务流程层，Pouch Container支持Kubernetes和Swarm。</span><br><span class="line">　　　　对于底层运行时层，Pouch Container支持runC，runV(该容器引擎由音速神童公司2015年5月左右发起的，同年发布的还有Intel公司发起的Clear Container)，runlxc等。为了使存储和网络大为补充，CNI和CSI就在其中。</span><br><span class="line"></span><br><span class="line">　　推荐阅读:</span><br><span class="line">　　　　https://github.com/alibaba/pouch</span><br><span class="line">　　　　https://github.com/opencontainers</span><br><span class="line">　　　　https://www.infoq.cn/article/alibaba-pouch</span><br><span class="line">　　　　https://github.com/alibaba/pouch/blob/master/docs/architecture.md</span><br><span class="line">　　　　https://github.com/opencontainers/runc</span><br><span class="line">　　　　https://github.com/hyperhq/runv</span><br><span class="line">　　　　https://github.com/containernetworking/cni</span><br><span class="line">　　　　https://github.com/container-storage-interface</span><br></pre></td></tr></table></figure>

<p><img src="Linux%E5%AE%B9%E5%99%A8(Container)%E5%8F%91%E5%B1%95%E5%8F%B2.assets/CA81AB020972443A8B9C492CB28783A6" alt="img"></p>
<h2 id="11-音速神童kata-containers"><a href="#11-音速神童kata-containers" class="headerlink" title="11.音速神童kata-containers"></a>11.音速神童kata-containers</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">技术创业公司音速神童成立于2015年，由两位中国开发者赵鹏和王旭创建。经过两年的发展，成长为全球容器行业的的重要技术和力量，</span><br><span class="line"></span><br><span class="line">　　2017年12月，音速神童在KubeCon上对外发布了Kata Containers安全容器项目，这个项目的两个前身是:音速神童的自研容器产品runV和Inter公司的容器产品Clear Container，而这两个项目均发布于2015年5月。</span><br><span class="line"></span><br><span class="line">　　kata COntainers其支持者包括99cloud、AWcloud、Canonical、中国移动、City Network、CoreOS、Dell/EMS、EasyStack、Fiberhome、谷歌、华为、京东、Mirantis、NetApp、Red Hat、SUSE、腾讯、Ucloud、UnitedStack 和中兴。</span><br><span class="line"></span><br><span class="line">　　自2017年12月启动以来，kata COntainers该社区成功地将Intel Clear Containers的最佳部分与Hyper.sh RunV合并，并进行了扩展，以包括对主要架构的支持，包括x86_64之外的AMD64，ARM，IBM p系列和IBM z系列。</span><br><span class="line"></span><br><span class="line">　　Kata Containers是一个开放源代码社区，致力于通过轻量级虚拟机来构建安全的容器运行时，这些虚拟机的感觉和性能类似于容器，但是使用硬件虚拟化技术作为第二防御层，可以提供更强的工作负载隔离。</span><br><span class="line">　　</span><br><span class="line">　　Kata Containers还支持多个虚拟机管理程序，包括QEMU，NEMU和Firecracker，并与其他容器化项目集成。</span><br><span class="line"></span><br><span class="line">　　Kata Containers社区由开放基础设施基金会管理，该基金会支持全球开放基础设施的开发和采用。该代码在Apache 2许可下托管在GitHub上。</span><br><span class="line"></span><br><span class="line">　　综上所述，Kata容器与容器一样轻便，快速，并与容器管理层集成在一起，包括流行的编排工具，如Docker和Kubernetes（k8s），同时还具有VM的安全优势。Kata Container具有以下几个优势：</span><br><span class="line">　　　　(1)安全:</span><br><span class="line">　　　　　　在专用内核中运行，提供网络，I/O和内存的隔离，并可以通过虚拟化VT扩展利用硬件强制隔离。</span><br><span class="line">　　　　(2)兼容性:</span><br><span class="line">　　　　　　支持行业标准，包括OCI容器格式，Kubernetes CRI接口以及旧版虚拟化技术。</span><br><span class="line">　　　　(3)性能:</span><br><span class="line">　　　　　　提供与标准Linux容器一致的性能；提高隔离度，而无需增加标准虚拟机的性能。</span><br><span class="line">　　　　(4)简单:</span><br><span class="line">　　　　　　消除了在完整的虚拟机内部嵌套容器的要求；标准接口使插入和入门变得容易。</span><br><span class="line"></span><br><span class="line">　　温馨提示:</span><br><span class="line">　　　　这一容器引擎其中一个特殊之处在于，它试图解决传统运维体验的问题，让容器可以像传统虚拟机一样操作。这其实就是VM与容器的结合，也正是Kata的用武之地。</span><br><span class="line">　　　　在之前，蚂蚁金服自研了一套技术来做到这点，而现在它们可以结合Kata的长处做到更好，同时又能保持和国内外主流技术保持同步。</span><br><span class="line">　　　　据InfoQ独家消息，技术创业公司音速神童创始人赵鹏王旭加入蚂蚁金服，打造虚拟机级别的安全容器技术。这也是为什么你所看到的pouch container是支持runV容器引擎的一个原因吧，因为runV研发团队核心成员已经入职阿里的蚂蚁金服!</span><br><span class="line">　　　　音速神童加入蚂蚁金服这件事在容器和云原生领域掀起新的波澜，它意味着云计算基础技术仍有可挖掘的的地方，而随着互联网大公司和云计算厂商的介入，未来的技术演进的竞争将更加激烈。</span><br><span class="line">　　</span><br><span class="line">　　参考链接:</span><br><span class="line">　　　　https://github.com/kata-containers/kata-containers</span><br><span class="line">　　　　https://github.com/hyperhq/runv</span><br><span class="line">　　　　https://katacontainers.io/</span><br><span class="line">　　　　https://katacontainers.io/learn/</span><br><span class="line">　　　　https://www.infoq.cn/article/OI-CCUqPe82xKUwtVoA2</span><br><span class="line">　　　　https://blog.csdn.net/weixin_44326589/article/details/103726445</span><br><span class="line">　　　　https://www.kubernetes.org.cn/tags/kubecon</span><br></pre></td></tr></table></figure>

<p><img src="Linux%E5%AE%B9%E5%99%A8(Container)%E5%8F%91%E5%B1%95%E5%8F%B2.assets/D4650DCC5B7F45929D163F18DE88498D" alt="img"></p>
<h2 id="12-podman"><a href="#12-podman" class="headerlink" title="12.podman"></a>12.<strong>podman</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Podman是一个无守护进程的容器引擎，用于在Linux系统上开发，管理和运行OCI容器。容器可以以root用户或无根模式运行。简而言之：alias docker = podman。</span><br><span class="line"></span><br><span class="line">2018年2月，PodMan的v0.2版本发布。Podman（POD管理器）是一种基于Apache-2.0 License开源工具，用于管理容器和镜像，安装在这些容器中的体积以及由容器组制成的容器。</span><br><span class="line"></span><br><span class="line">　　Podman基于libpod，libpod是一个用于容器生命周期管理的库，该库也包含在其中。libpod库提供用于管理容器，pod，容器映像和卷的API。</span><br><span class="line">　　</span><br><span class="line">　　推荐阅读:</span><br><span class="line">　　　　https://podman.io/</span><br><span class="line">　　　　https://github.com/containers/podman</span><br></pre></td></tr></table></figure>



<h1 id="三-容器技术改变了传统部署应用程序的方式"><a href="#三-容器技术改变了传统部署应用程序的方式" class="headerlink" title="三.容器技术改变了传统部署应用程序的方式"></a>三.容器技术改变了传统部署应用程序的方式</h1><h2 id="1-容器和虚拟机之间的架构差异"><a href="#1-容器和虚拟机之间的架构差异" class="headerlink" title="1.容器和虚拟机之间的架构差异"></a>1.容器和虚拟机之间的架构差异</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我们通常会说容器和虚拟化技术实现了一个互补，接下来我们来简单列举一下容器(Container)和虚拟机(virtual machine)直接的差别。</span><br><span class="line">　　　　启动速度:</span><br><span class="line">　　　　　　Docker Container只需加载镜像文件，通常情况下是秒级(除非你的镜像不在本地，而是在公网上，这需要一个下载镜像的过程)。</span><br><span class="line">　　　　　　而virtual machine需要启动宿主机,速度较慢。</span><br><span class="line">　　　　运行性能:</span><br><span class="line">　　　　　　接近原生物理系统，因为Docker Container和原生操作系统使用的是同一个kernel。</span><br><span class="line">　　　　　　而virtual machine使用的宿主机的虚拟kernel，这意味着需要将虚拟kernel的指令经过编译，翻译成机器码交由物理kernel取执行。因此会多占用一些资源。</span><br><span class="line">　　　　镜像体积:</span><br><span class="line">　　　　　　Docker Container镜像基本上都是MB级别。</span><br><span class="line">　　　　　　virtual machine就需要ISO镜像来安装，官方有900MB+(Minimal的ISO镜像),4GB+(DVD的ISO镜像)，10GB+(Everything的ISO镜像)等等。</span><br><span class="line">　　　　可管理性:</span><br><span class="line">　　　　　　Docker Container单进程(即进程级隔离)</span><br><span class="line">　　　　　　virtual machine是虚拟完整的系统管理(即系统级隔离，相对来隔离更彻底)</span><br><span class="line">　　　　资源利用率:</span><br><span class="line">　　　　　　一台物理机可以运行数百个容器Docker Container，但是一般只能运行数十多个virtual machine。</span><br><span class="line">　　　　封装程度:</span><br><span class="line">　　　　　　Docker Container只打包项目代码及其运行环境所依赖的关系</span><br><span class="line">　　　　　　virtual machine虚拟完整的操作系统。</span><br></pre></td></tr></table></figure>

<p><img src="Linux%E5%AE%B9%E5%99%A8(Container)%E5%8F%91%E5%B1%95%E5%8F%B2.assets/2E4759DCA4A144A4A307115113C633D2" alt="img"></p>
<h2 id="2-容器改变了部署方式"><a href="#2-容器改变了部署方式" class="headerlink" title="2.容器改变了部署方式"></a>2.容器改变了部署方式</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">传统部署时代： </span><br><span class="line">　　　　早期，组织在物理服务器上运行应用程序。无法为物理服务器中的应用程序定义资源边界，这会导致资源分配问题。</span><br><span class="line">　　　　例如，如果在物理服务器上运行多个应用程序，则可能会出现一个应用程序占用大部分资源的情况，结果，另一个应用程序的性能将下降。</span><br><span class="line">　　　　解决方案是在不同的物理服务器上运行每个应用程序。但是，这并没有随着资源利用不足而扩展，并且组织维护许多物理服务器的成本很高。</span><br><span class="line"></span><br><span class="line">　　虚拟化部署时代：</span><br><span class="line">　　　　作为解决方案，引入了虚拟化。</span><br><span class="line">　　　　它允许您在单个物理服务器的CPU上运行多个虚拟机（VM）。虚拟化允许在VM之间隔离应用程序，并提供安全级别，因为一个应用程序的信息不能被另一应用程序自由访问。</span><br><span class="line">　　　　虚拟化可以更好地利用物理服务器中的资源，并可以实现更好的可伸缩性，因为可以轻松地添加或更新应用程序，降低硬件成本等等。借助虚拟化，您可以将一组物理资源呈现为一组一次性虚拟机。</span><br><span class="line">　　　　每个VM都是一台完整的计算机，在虚拟化硬件之上运行所有组件，包括其自己的操作系统。</span><br><span class="line"></span><br><span class="line">　　容器部署时代：</span><br><span class="line">　　　　容器类似于VM，但是它们具有轻松的隔离属性，可以在应用程序之间共享操作系统（OS）。因此，容器被认为是轻质的。</span><br><span class="line">　　　　与VM相似，容器具有自己的文件系统，CPU，内存，进程空间等的共享。由于它们与基础架构分离，因此可以跨云和OS分发进行移植。</span><br><span class="line"></span><br><span class="line">　　参考连接:</span><br><span class="line">　　　　https://kubernetes.io/docs/concepts/overview/what-is-kubernetes/</span><br></pre></td></tr></table></figure>

<p><img src="Linux%E5%AE%B9%E5%99%A8(Container)%E5%8F%91%E5%B1%95%E5%8F%B2.assets/551FA84F4E074D1B8DD63780D89360EF" alt="img"></p>
<h1 id="四-chroot工具使用（了解即可）"><a href="#四-chroot工具使用（了解即可）" class="headerlink" title="四.chroot工具使用（了解即可）"></a>四.chroot工具使用（了解即可）</h1><h2 id="1-chroot概述"><a href="#1-chroot概述" class="headerlink" title="1.chroot概述"></a>1.chroot概述</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chroot(全称为:&quot;change root directory&quot;)命令用来在指定的根目录下运行指令。在linux系统中，系统默认的目录结构都是以/，即是以根(root)开始的。而在使用chroot之后，系统的目录结构将以指定的位置作为/位置。</span><br><span class="line"></span><br><span class="line">其实chroot的概念我们并不是第一次接触了，还记得我们讲解的kafka在zookeeper的元数据znode位置吗？我们也为其指定了根znode哟~</span><br><span class="line"></span><br><span class="line">在经过chroot之后，系统读取到的目录和文件将不在是旧系统根下的而是新根下(即被指定的新的位置)的目录结构和文件，因此它带来的好处大致有以下3个：</span><br><span class="line">	(1)增加了系统的安全性，限制了用户的权力；</span><br><span class="line">		在经过chroot之后，在新根下将访问不到旧系统的根目录结构和文件，这样就增强了系统的安全性。</span><br><span class="line">		这个一般是在登录(login)前使用chroot，以此达到用户不能访问一些特定的文件。</span><br><span class="line"></span><br><span class="line">	(2)建立一个与原系统隔离的系统目录结构，方便用户的开发；</span><br><span class="line">		使用chroot后，系统读取的是新根下的目录和文件，这是一个与原系统根下文件不相关的目录结构。</span><br><span class="line">		在这个新的环境中，可以用来测试软件的静态编译以及一些与系统不相关的独立开发。</span><br><span class="line"></span><br><span class="line">	(3)切换系统的根目录位置，引导Linux系统启动以及急救系统等。</span><br><span class="line">		chroot的作用就是切换系统的根位置，而这个作用最为明显的是在系统初始引导磁盘的处理过程中使用，从初始RAM磁盘 (initrd) 切换系统的根位置并执行真正的init。</span><br><span class="line">		另外，当系统出现一些问题时，我们也可以使用chroot来切换到一个临时的系统。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="2-centos测试"><a href="#2-centos测试" class="headerlink" title="2.centos测试"></a>2.centos测试</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@docker201.oldboyedu.com ~]# mkdir -pv oldboyedu/linux </span><br><span class="line">[root@docker201.oldboyedu.com ~]#</span><br><span class="line">[root@docker201.oldboyedu.com ~]# scp -r /usr/&#123;bin,lib64&#125; oldboyedu/linux/</span><br></pre></td></tr></table></figure>

<p><img src="Linux%E5%AE%B9%E5%99%A8(Container)%E5%8F%91%E5%B1%95%E5%8F%B2.assets/DBAA973F58584CE691A19000F3178114" alt="img"></p>
<h2 id="3-ubuntu测试"><a href="#3-ubuntu测试" class="headerlink" title="3.ubuntu测试"></a>3.ubuntu测试</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -pv oldboyedu/linux/&#123;bin,lib,lib64&#125;</span><br><span class="line"></span><br><span class="line">cp /bin/bash oldboyedu/linux/bin/</span><br><span class="line"> </span><br><span class="line">cp /lib/x86_64-linux-gnu/&#123;libtinfo.so.5,libdl.so.2,libc.so.6&#125; oldboyedu/linux/lib</span><br><span class="line"></span><br><span class="line">cp /lib/x86_64-linux-gnu/ld-linux-x86-64.so.2 oldboyedu/linux/lib64/</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="Linux%E5%AE%B9%E5%99%A8(Container)%E5%8F%91%E5%B1%95%E5%8F%B2.assets/67B91A6715A94E24A5E936B0FCAED97B" alt="image-20210629232129052"></p>
<h2 id="4-创建文件"><a href="#4-创建文件" class="headerlink" title="4.创建文件"></a>4.创建文件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash-4.2# echo &quot;oldboyedu linux 2021&quot; &gt; /oldboyedu.log </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="Linux%E5%AE%B9%E5%99%A8(Container)%E5%8F%91%E5%B1%95%E5%8F%B2.assets/E224146AF87A45F8841A40708B23B2B1" alt="image-20210629232454393"></p>
<h2 id="5-chroot的局限性"><a href="#5-chroot的局限性" class="headerlink" title="5.chroot的局限性"></a>5.chroot的局限性</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">从chroot的用法可以看出它的使用场景有一定的局限性，首先它依赖于一台现成的unix系统（根目录必须存在于某台现有系统上）。</span><br><span class="line"></span><br><span class="line">其次chroot仅仅是在系统目录上进行了隔离，并没有对进程、环境变量，网络等层面进行隔离。因此我们说chroot并不能完全保证系统安全。</span><br><span class="line"></span><br><span class="line">温馨提示:</span><br><span class="line">	(1)如下图所示，演示了进程和环境变量并没有实现隔离；</span><br><span class="line">	(2)此处的chroot中无法使用ping命令或者ifconfig相关的命令，否则就可以进一步验证网络也没有隔离哟~</span><br></pre></td></tr></table></figure>

<p><img src="Linux%E5%AE%B9%E5%99%A8(Container)%E5%8F%91%E5%B1%95%E5%8F%B2.assets/D467971654AB406093C01D555654D41F" alt="image-20210629232909485"></p>
<p><img src="Linux%E5%AE%B9%E5%99%A8(Container)%E5%8F%91%E5%B1%95%E5%8F%B2.assets/715783B7E3584337B5A4CF0A2AC4D7A9" alt="image-20210629233508001"></p>
<h1 id="五-LXC容器管理工具使用（了解即可）"><a href="#五-LXC容器管理工具使用（了解即可）" class="headerlink" title="五.LXC容器管理工具使用（了解即可）"></a>五.LXC容器管理工具使用（了解即可）</h1><h2 id="1-centos按照lxc，lxd-比较麻烦"><a href="#1-centos按照lxc，lxd-比较麻烦" class="headerlink" title="1.centos按照lxc，lxd(比较麻烦)"></a>1.centos按照lxc，lxd(比较麻烦)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@docker201.oldboyedu.com ~]# yum -y install lxc lxd</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">推荐阅读:</span><br><span class="line">	https://bbs.huaweicloud.com/blogs/150538</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">温馨提示:</span><br><span class="line">	lxc:</span><br><span class="line">		客户端。</span><br><span class="line">	lxd:</span><br><span class="line">		服务端。</span><br><span class="line">	</span><br></pre></td></tr></table></figure>



<h2 id="2-ubuntu安装lxc，lxd"><a href="#2-ubuntu安装lxc，lxd" class="headerlink" title="2.ubuntu安装lxc，lxd"></a>2.ubuntu安装lxc，lxd</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get -y install lxc lxd</span><br><span class="line"></span><br><span class="line">lxd:</span><br><span class="line">	服务端。</span><br><span class="line">	</span><br><span class="line">lxc:</span><br><span class="line">	客户端</span><br></pre></td></tr></table></figure>





<h2 id="3-检查内核对lxc的支持情况"><a href="#3-检查内核对lxc的支持情况" class="headerlink" title="3.检查内核对lxc的支持情况"></a>3.检查内核对lxc的支持情况</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@docker201.oldboyedu.com ~]# lxc-checkconfig </span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/CDBF782AD81F4AB9AC010A2BDB74F7BF?method=download&shareKey=bfb0b3276d7240854eb60679556a6cc7" alt="image-20210629234317680"></p>
<h2 id="4-下载镜像"><a href="#4-下载镜像" class="headerlink" title="4.下载镜像"></a>4.下载镜像</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lxc-create -t download --name my_alpine2021 -- --dist alpine --release lates</span><br><span class="line">t --arch adm64 --keyserver hkp://keyserver.ubuntu.com</span><br><span class="line"></span><br><span class="line">相关参数说明:</span><br><span class="line">	-t:</span><br><span class="line">　　　　指定模板名称，我们这里指定download模板，就会调用&quot;/usr/share/lxc/templates/lxc-download&quot;脚本，该脚本说明我们目前没有自己的模板，需要下载官方的模板。</span><br><span class="line">　　--name:</span><br><span class="line">　　　　指定容器名称，即为创建的容器命名。</span><br><span class="line">　　--:</span><br><span class="line">　　　　用来说明后面的参数是传递给download脚本的，告诉脚本需要下载什么养的模板。</span><br><span class="line">　　--dist:</span><br><span class="line">　　　　操作系统名称，即指定操作系统。</span><br><span class="line">　　--release:</span><br><span class="line">　　　　指定操作系统的发行版本。可以是各种Linux的变种。</span><br><span class="line">　　--arch:</span><br><span class="line">　　　　指定CPU架构，是x86还是arm，是32位还是64位。　</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="5-管理lxc容器命令"><a href="#5-管理lxc容器命令" class="headerlink" title="5.管理lxc容器命令"></a>5.管理lxc容器命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lxc-start my_alpine2021:</span><br><span class="line"> 	启动lxc容器。</span><br><span class="line"> 	</span><br><span class="line">lxc-attach my_alpine2021:</span><br><span class="line">	进入lxc容器。</span><br><span class="line">	</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="6-lxc启动容器依赖于模板"><a href="#6-lxc启动容器依赖于模板" class="headerlink" title="6.lxc启动容器依赖于模板"></a>6.lxc启动容器依赖于模板</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">　　lxc启动容器依赖于模板，清华模板源：</span><br><span class="line">　　　　https://mirrors.tuna.tsinghua.edu.cn/help/lxc-images/</span><br><span class="line"></span><br><span class="line">　　但是做模板相对较难，需要手动一步步构建文件系统，准备基础目录及可执行程序等，而且在大规模使用容器的场景很难横向扩展，另外后期代码升级也需要重新从头构建模板，基于以上种种原因便有了docker容器管理工具。</span><br></pre></td></tr></table></figure>





<h1 id="六-可能会遇到的报错"><a href="#六-可能会遇到的报错" class="headerlink" title="六.可能会遇到的报错"></a>六.可能会遇到的报错</h1><h2 id="1-chroot-failed-to-run-command-‘-bin-bash’-No-such-file-or-directory"><a href="#1-chroot-failed-to-run-command-‘-bin-bash’-No-such-file-or-directory" class="headerlink" title="1.chroot: failed to run command ‘/bin/bash’: No such file or directory"></a>1.chroot: failed to run command ‘/bin/bash’: No such file or directory</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">报错原因:</span><br><span class="line">	指定的chroot目录中没有‘/bin/bash’文件。</span><br><span class="line"></span><br><span class="line">解决方案:</span><br><span class="line">	如下图所示，拷贝‘/bin/bash’文件到指定的目录结构并将其依赖的库文件也要拷贝过去。此处我为了偷懒，就没进行拷贝。</span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/D871C9EE3C7948C8BEBF81A30E53DCD8?method=download&shareKey=899c49b50e6b59c7c900f3bdbf890e06" alt="image-20210629230138235"></p>
<h2 id="2-ERROR-Unable-to-fetch-GPG-key-from-keyserver"><a href="#2-ERROR-Unable-to-fetch-GPG-key-from-keyserver" class="headerlink" title="2.ERROR: Unable to fetch GPG key from keyserver"></a>2.ERROR: Unable to fetch GPG key from keyserver</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">故障原因:</span><br><span class="line">	无法从密钥服务器获取GPG密钥。</span><br><span class="line">	</span><br><span class="line">解决方案:</span><br><span class="line">	方案一:</span><br><span class="line">		vim ~/.bashrc</span><br><span class="line">		export DOWNLOAD_KEYSERVER=&quot;keyserver.ubuntu.com&quot;</span><br><span class="line">		</span><br><span class="line">	方案二:</span><br><span class="line">		DOWNLOAD_KEYSERVER=&quot;keyserver.ubuntu.com&quot; lxc-create -t download ...</span><br><span class="line">	</span><br><span class="line">	方案三:</span><br><span class="line">		lxc-create -t download ... --keyserver hkp://keyserver.ubuntu.com</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>云计算</category>
      </categories>
      <tags>
        <tag>Doker</tag>
      </tags>
  </entry>
</search>
