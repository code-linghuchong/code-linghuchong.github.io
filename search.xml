<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Docker的架构介绍及部署实战</title>
    <url>/uncategorized/Docker%E7%9A%84%E6%9E%B6%E6%9E%84%E4%BB%8B%E7%BB%8D%E5%8F%8A%E9%83%A8%E7%BD%B2%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>LVS负载均衡</title>
    <url>/Linux%E9%9B%86%E7%BE%A4%E6%9E%B6%E6%9E%84/LVS%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
    <content><![CDATA[<h1 id="LVS负载均衡"><a href="#LVS负载均衡" class="headerlink" title="LVS负载均衡"></a>LVS负载均衡</h1><h2 id="集群架构的概念"><a href="#集群架构的概念" class="headerlink" title="集群架构的概念"></a>集群架构的概念</h2><blockquote>
<p>集群就是一组相互独立的服务器，通过高速的网络组成一个服务器系统，每个集群节点都是运行其自己进程的一个独立服务器。对网络用户来讲，网站后端就是一个单一的系统，协同起来向用户提供系统资源，系统服务。</p>
</blockquote>
<span id="more"></span>

<h2 id="为什么使用集群架构"><a href="#为什么使用集群架构" class="headerlink" title="为什么使用集群架构"></a>为什么使用集群架构</h2><p><strong><font color='blue'> 1）集群的特点</font></strong></p>
<ul>
<li><p>高性能：</p>
<p>需要很强的运算处理能力比如天气预报，核试验等。这就不是几台服务器能够搞定的。这需要上千台一起来完成这个工作的。</p>
</li>
<li><p>经济有效性：</p>
<p>通常一套系统集群架构，只需要几台或数十台服务器主机即可，与动则上百万的专用超级服务器具有更高的性价比。</p>
</li>
<li><p>可伸缩性：</p>
<p>当服务器负载压力增长的时候，系统能够扩展来满足需求，且不降低服务质量。</p>
</li>
<li><p>高可用性：</p>
<p> 尽管部分硬件和软件发生故障，整个系统的服务必须是7*24小时运行的。</p>
</li>
</ul>
<p><strong><font color='blue'>2） 集群的优势</font></strong></p>
<ul>
<li><p>透明性：</p>
<p>如果一部分服务器宕机了业务不受影响，一般耦合度没有那么高，依赖关系没有那么高。比如NFS服务器宕机了其他就挂载不了了，这样依赖性太强。</p>
</li>
<li><p>高性能：</p>
<p>访问量增加，能够轻松扩展。</p>
</li>
<li><p>可管理型</p>
<p>整个系统可能在物理上很大，但很容易管理。</p>
</li>
<li><p>可编程性</p>
<p>在集群系统上，容易开发应用程序，门户网站会要求这个。</p>
</li>
</ul>
<p><strong><font color='blue'>2） 集群分类及不同的特点</font></strong></p>
<p>计算机集群架构按照功能和结构一般分成以下几类：</p>
<ol>
<li>负载均衡集群（Loadbalancingclusters）简称LBC</li>
<li> 高可用性集群（High-availabilityclusters）简称HAC</li>
<li> 高性能计算集群（High-perfomanceclusters）简称HPC</li>
<li> 网格计算（Gridcomputing）</li>
</ol>
<h2 id="负载均衡集群介绍"><a href="#负载均衡集群介绍" class="headerlink" title="负载均衡集群介绍"></a>负载均衡集群介绍</h2><p>负载均衡集群, 是一种将网络上的访问流量分布于各个节点，以降低服务器压力，更好的向客户端提供服务的一种方式。</p>
<p><strong><font color='blue'>负载均衡集群的作用：</font></strong></p>
<table><tr><td bgcolor=Beige>提供一种廉价、有效、透明的方法，来扩展网络设备和服务器的负载带宽、增加吞吐量，加强网络数据处理能力、提高网络的灵活性和可用性。</td></tr></table>

<p>简单来说,也就是:</p>
<blockquote>
<p>把单台计算机无法承受的大规模的并发访问或数据流量分担到多台节点设备上分别处理，减少用户等待响应的时间，提升用户体验。</p>
<p>单个重负载的运算分担到多台节点设备上做并行处理，每个节点设备处理结束后，将结果汇总，返回给用户，系统处理能力得到大幅度提高。</p>
<p>7*24小时的服务保证，任意一个或多个设备节点设备宕机，不能影响到业务。在负载均衡集群中，所有计算机节点都应该提供相同的服务，集群负载均衡获取所有对该服务的如站请求。</p>
</blockquote>
<p><strong><font color='blue'>常用的负载分为：</font></strong></p>
<ul>
<li>开源软件负载均衡：<strong>Nginx, LVS, Haproxy</strong> (<strong>Nginx</strong>和<strong>Haproxy</strong>通常做七层负载均衡, <strong>LVS</strong>做四层负载均衡. 但是<strong>Nginx</strong>也可以通过<strong>stream</strong>模块做四层负载均衡, <strong>Haproxy</strong>也可以做四层负载均衡 ) ;</li>
<li> 商业的硬件负载均衡: 设备F5、Netscale 。</li>
</ul>
<p><strong><font color='blue'>简单理解一下软件负载均衡:</font></strong></p>
<p>1） 所谓分层的负载均衡，都是以网络的模型来说的。四层就是基于IP和端口的负载均衡，七层就是基于URL等应用信息的负载均衡。所以简单的说四层负载均衡就是通过IP和端口接收请求再分发至真实的服务器，七层是通过URL或主机名接收请求，然后分发至真实的服务器。</p>
<p>2） 而七层的实现也是在四层的基础上是实现的，没有四层就不可能有七层。在第七层上可以做许多事情，比如可以根据七层的浏览器类别区分是手机还是PC，将WEB服务器分为2组，手机登陆专门的移动端网站。</p>
<p>3）对客户端来说，客户端好像是访问的同一台主机。其实为了有更好的用户体验，从智能DNS入手，根据客户端IP来源将域名解析到距离客户端最近的一台服务器或者访问最快速的一台服务器，但这些内容客户端都是感觉不到的，客户端感觉到的只能是访问网站很快。</p>
<p>​                      <img src="https://note.youdao.com/yws/api/personal/file/WEB4c1173b965fcc891e53e399791803f06?method=download&shareKey=8e16d58edd3de26fa824958e8cbf1b2d" alt="avatar">   </p>
<p>负载均衡的原理很简单，就是当客户端发起请求时，请求直接发给Director  Server（调度器），这时会根据设定的调度算法，将请求按照算法的规定智能的分发到真正的后台服务器。以达到将压力均摊。但是我们知道，http的连接时无状态的，假设这样一个场景，我登录某宝买东西，当我看上某款商品时，我将它加入购物车，但是我刷新了一下页面，这时由于负载均衡的原因，调度器又选了新的一台服务器为我提供服务，我刚才的购物车内容全都不见了，这样就会有十分差的用户体验。所以就还需要一个存储共享，这样就保证了用户请求的数据是一样的。所以LVS负载均衡分为三层架构(也就是LVS负载均衡主要组成部分)：</p>
<p><font color='purple'><strong>第一层</strong>：</font>&lt;负载调度器（load balancer/ Director），它是整个集群的总代理，它在有两个网卡，一个网卡面对访问网站的客户端，一个网卡面对整个集群的内部。负责将客户端的请求发送到一组服务器上执行，而客户也认为服务是来自这台主的。举个生动的例子，集群是个公司，负载调度器就是在外接揽生意，将接揽到的生意分发给后台的真正干活的真正的主机们。当然需要将活按照一定的算法分发下去，让大家都公平的干活。<br>      <font color='purple'> <strong>第二层</strong>：</font>服务器池（server pool/ Realserver），是一组真正执行客户请求的服务器，可以当做WEB服务器。就是上面例子中的小员工。<br>        <font color='purple'><strong>第三层</strong></font>：共享存储（shared storage），它为服务器池提供一个共享的存储区，这样很容易使得服务器池拥有相同的内容，提供相同的服务。一个公司得有一个后台账目吧，这才能协调。不然客户把钱付给了A，而换B接待客户，因为没有相同的账目。B说客户没付钱，那这样就不是客户体验度的问题了。</p>
<h2 id="LVS负载均衡-1"><a href="#LVS负载均衡-1" class="headerlink" title="LVS负载均衡"></a>LVS负载均衡</h2><h3 id="IPVS（LVS）发展史"><a href="#IPVS（LVS）发展史" class="headerlink" title="IPVS（LVS）发展史"></a>IPVS（LVS）发展史</h3><p>在linux2.2内核时，IPVS就已经以内核补丁的形式出现</p>
<p>从2.4。24版本以后IPVS已经成为linux内核官方标准内核的一部分</p>
<h3 id="LVS工作原理"><a href="#LVS工作原理" class="headerlink" title="LVS工作原理"></a>LVS工作原理</h3><p>LVS负载均衡调度技术是在linux内核中实现的，我们使用配置LVS时，不是直接配置内核中的IPVS，而是通过IPVS的管理工具IPVSADM来管理配置</p>
<p>LVS集群负载均衡器接受所有入站客户端的请求，并根据算法来决定由哪个集群的节点来处理请求</p>
<h3 id="LVS相关术语介绍"><a href="#LVS相关术语介绍" class="headerlink" title="LVS相关术语介绍"></a>LVS相关术语介绍</h3><ul>
<li>虚拟IP地址（VIP）  </li>
</ul>
<p>​       用于向客户端提供服务的IP地址（配置于负载均衡器上）</p>
<ul>
<li><p>真实的IP地址（RIP） </p>
<p>集群中节点服务器的IP地址</p>
</li>
<li><p>负载均衡器IP地址（DIP）</p>
<p>负载均衡器的IP地址，物理网卡上的IP，用与同外网连接的地址</p>
</li>
<li><p>客户端主机IP地址（CIP）</p>
<p> 终端请求用户的主机IP地址</p>
</li>
</ul>
<h2 id="LVS几种工作模式的介绍"><a href="#LVS几种工作模式的介绍" class="headerlink" title="LVS几种工作模式的介绍"></a>LVS几种工作模式的介绍</h2><h3 id="NAT网络地址转换模式（VS-NAT）"><a href="#NAT网络地址转换模式（VS-NAT）" class="headerlink" title="NAT网络地址转换模式（VS/NAT）"></a>NAT网络地址转换模式（VS/NAT）</h3><p> 通过网络地址转换，调度器LB重写请求报文的目标地址，根据算法将请求分配给后端的真实主机服务器，真实服务器响应处理报文后返回给调度器LB，经过LB的报文源地址被重写，再返回给请求的客户端用户。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB03f9c89dbb5637c2350f56cc00857e51?method=download&shareKey=bff8b56b7053b600ad043bd381fba50a" alt="avatar"></p>
<p><em><strong><font color='red'>过程详解：</font></strong></em></p>
<blockquote>
<p>1：客户端请求CIP（192.168.16.15:80)目标的地址是VIP(10.0.0.3:80);</p>
<p>2：数据经过LB，目的地址将被LB改写成后端服务器其中一个主机地址（RIP 172.168.1.7:80）</p>
<p>3：服务器接收到数据请求后返回应答信息（源地址：172.168.1.7:80，目的地址：10.0.0.3:80，因此处的网关地址需指向LB）给LB</p>
<p>4：LB需将源数据地址改写成VIP地址（10.0.0.3:80，但实际的源地址是RIP1的地址）</p>
<p>5：LB将数据返回给请求的客户端用户，完成整个流程的访问,因此WEB访问量很大的时候，LB就会有很大的负载压力，一般支持10-20台节点，但是这种模式支持IP和端口的转换功能，即192.168.16.15:80—-&gt;10.0.0.3:80—-&gt;172.168.1.7:80</p>
</blockquote>
<h3 id="DR模式（Direct-Routing）直接路由模式"><a href="#DR模式（Direct-Routing）直接路由模式" class="headerlink" title="DR模式（Direct Routing）直接路由模式"></a>DR模式（Direct Routing）直接路由模式</h3><p>DR模式也就是用直接路由技术实现虚拟服务器。它的连接调度和管理与VS/NAT和VS/TUN中的一样，但它的报文转发方法又有不同，VS/DR通过改写请求报文的MAC地址，将请求发送到Real Server，而Real  Server将响应直接返回给客户，免去了VS/TUN中的IP隧道开销。这种方式是三种负载调度机制中性能最高最好的，但是必须要求Director  Server与Real Server都有一块网卡连在同一物理网段上。</p>
<p>Director和RealServer必需在物理上有一个网卡通过不间断的局域网相连。  RealServer上绑定的VIP配置在各自Non-ARP的网络设备上(如lo或tunl),Director的VIP地址对外可见，而RealServer的VIP对外是不可见的。RealServer的地址即可以是内部地址，也可以是真实地址。</p>
<p>DR模式是通过改写请求报文的目标MAC地址，将请求发给真实服务器的，而真实服务器响应后的处理结果直接返回给客户端用户。同TUN模式一样，DR模式可以极大的提高集群系统的伸缩性。而且DR模式没有IP隧道的开销，对集群中的真实服务器也没有必要必须支持IP隧道协议的要求。但是要求调度器LB与真实服务器RS都有一块网卡连接到同一物理网段上，必须在同一个局域网环境。</p>
<p><strong>DR模式是互联网使用比较多的一种模式</strong>，DR模式原理图如下：</p>
<p>​                        <img src="https://note.youdao.com/yws/api/personal/file/WEB9d1c7fcee56cc40f9758bad3319261ab?method=download&shareKey=9643baccbc0de23b0f1459d5e96d3e28" alt="avatar"></p>
<p><strong>DR模式以上原理过程简述：</strong><br>VS/DR模式的工作流程图如上图所示，它的连接调度和管理与NAT和TUN中的一样，它的报文转发方法和前两种不同。DR模式将报文直接路由给目标真实服务器。在DR模式中，调度器根据各个真实服务器的负载情况，连接数多少等，动态地选择一台服务器，不修改目标IP地址和目标端口，也不封装IP报文，而是将请求报文的数据帧的目标MAC地址改为真实服务器的MAC地址。然后再将修改的数据帧在服务器组的局域网上发送。因为数据帧的MAC地址是真实服务器的MAC地址，并且又在同一个局域网。那么根据局域网的通讯原理，真实复位是一定能够收到由LB发出的数据包。真实服务器接收到请求数据包的时候，解开IP包头查看到的目标IP是VIP。（此时只有自己的IP符合目标IP才会接收进来，所以我们需要在本地的回环借口上面配置VIP。</p>
<p>另外:  由于网络接口都会进行ARP广播响应，但集群的其他机器都有这个VIP的lo接口，都响应就会冲突。所以我们需要把真实服务器的lo接口的ARP响应关闭掉。）然后真实服务器做成请求响应，之后根据自己的路由信息将这个响应数据包发送回给客户，并且源IP地址还是VIP。</p>
<p>其实整个DR模式都是停留在第二层的数据链路层, 直接修改MAC。实现报文的转发。再看下面的DR模式图:</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBb0dd5b7ea5d8acddec5896a570c900ad?method=download&shareKey=3ae24eb26c6d5ce0657f77cf841ab314" alt="img"></p>
<blockquote>
<p>1） 当用户请求到达Director Server，此时请求的数据报文会先到内核空间的PREROUTING链。 此时报文的源IP为CIP，目标IP为VIP;</p>
<p>2）PREROUTING检查发现数据包的目标IP是本机，将数据包送至INPUT链;</p>
<p>3）   IPVS比对数据包请求的服务是否为集群服务，若是，将请求报文中的源MAC地址修改为DIP的MAC地址，将目标MAC地址修改RIP的MAC地址，然后将数据包发至POSTROUTING链。 此时的源IP和目的IP均未修改，仅修改了源MAC地址为DIP的MAC地址，目标MAC地址为RIP的MAC地址;</p>
<p>4）由于DS和RS在同一个网络中，所以是通过二层来传输。POSTROUTING链检查目标MAC地址为RIP的MAC地址，那么此时数据包将会发至Real Server;</p>
<p>5）响应报文最终送达至客户端;</p>
</blockquote>
<p><strong>注：LB只能改写目的MAC地址，因此它不能改变请求报文的目的端口端口，LVS只支持unix和linux，但集群节点服务器可以是win系统，此种模式配置相当麻烦</strong></p>
<blockquote>
<p>1 在前端路由器做静态地址路由绑定，将对于VIP的地址仅路由 到Director Server<br>\2arptables：在arp的层次上实现在ARP解析时做防火墙规则，过滤RS响应ARP请求。修改RS上内核参数（arp_ignore和arp_announce）将RS上的VIP配置在网卡接口的别名上，并限制其不能响应对VIP地址解析请求。<br>3)RS可以使用私有地址；但也可以使用公网地址，此时可以直接通过互联网连入RS以实现配置、监控等；<br>4)RS的网关一定不能指向DIP；<br>5)RS跟Dirctory要在同一物理网络内（不能由路由器分隔）；<br>6)请求报文经过Directory，但响应报文一定不经过Director</p>
</blockquote>
<p>LVS的调度算法决定了如何在集群节点之间分配负载压力（访问请求）</p>
<p><strong>调度算法：</strong></p>
<p><strong>rr</strong>轮循调度：将请求依次分配给集群的节点，这种算法适用于各个节点处理能力基本相同的情况下</p>
<p><strong>wrr</strong>加权轮循调度：根据节点的权重来分配，权重较高的优先分配</p>
<p><strong>wlc</strong>加权最小连接数调度：按权重和连接数的数量来分配</p>
<p><strong>lc</strong>最小连接数调度：按连接数的数量来分配</p>
<p><strong>实际生产环境LVS调度算法选型</strong></p>
<p>一般网络服务，如HTTP、MAIL、MYSQL常用的调度算法有：rr、wlc、wrr</p>
<script src='https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/mouse_snow.min.js'></script>

]]></content>
      <categories>
        <category>Linux集群架构</category>
      </categories>
      <tags>
        <tag>LVS</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux基础命令</title>
    <url>/Linux%E5%9F%BA%E7%A1%80/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="Linux基础命令"><a href="#Linux基础命令" class="headerlink" title="Linux基础命令"></a>Linux基础命令</h1><p>Linux系统的基础命令可以说是数不胜数，所以我们分为以下几个分类去总结。</p>
<h2 id="系统目录结构"><a href="#系统目录结构" class="headerlink" title="系统目录结构"></a>系统目录结构</h2><p>⼏乎所有的计算机操作系统都是⽤⽬录结构组织⽂件。具体来说就是在⼀个⽬录中存放⼦⽬录和⽂件, ⽽在⼦⽬录中⼜会进⼀步存放⼦⽬录和⽂件，以此类推形成⼀个树状的⽂件结构，由于其结构很像⼀棵树的分⽀, 所以该结构⼜被称为“⽬录树”。Linux系统中也沿⽤了这种⽂件结构, 所有⽬录和⽂件都在 “根⽬录”下, ⽬录名为”/“。FHS（⽂件系统层次标准）定义了在根⽬录下的主要⽬录以及每个⽬录应该存放什么⽂件。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBf9d7b9b67a753782c35f78bfa90965de?method=download&shareKey=37a1114867c1dcb78edae25e163a8754" alt="img"></p>
<table>
<thead>
<tr>
<th>目录名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>/etc</td>
<td>系统重要配置文件，以及常用服务配置文件</td>
</tr>
<tr>
<td>/var</td>
<td>存放系统引导启动时产生的可变文件，文件通常动态改变，例如：缓存目录，日志文件</td>
</tr>
<tr>
<td>/run</td>
<td>系统启动后,    运⾏的程序产⽣的运⾏时数据，包括进程的pid⽂件,锁⽂件等</td>
</tr>
<tr>
<td>/home</td>
<td>普通⽤户的主⽬录，普通⽤户的家⽬录默认为/HOME/USERNAME</td>
</tr>
<tr>
<td>/root</td>
<td>超级管理员的主⽬录,    普通⽤户⽆权操作</td>
</tr>
<tr>
<td>/tmp</td>
<td>存放临时⽂件,    ⼀般存放超过10天以上都会⾃动删除,可以更改删除临时⽂件的期限</td>
</tr>
<tr>
<td>/boot</td>
<td>存放系统引导时候需要的⽂件</td>
</tr>
<tr>
<td>/dev</td>
<td>存放设备⽂件</td>
</tr>
<tr>
<td>/usr</td>
<td>安装的软件,    共享库</td>
</tr>
<tr>
<td>/usr/bin</td>
<td>⽤户命令⽬录</td>
</tr>
<tr>
<td>/usr/sbin</td>
<td>管理员命令⽬录</td>
</tr>
<tr>
<td>/usr/local</td>
<td>本地⾃定义安装的软件</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">##注意： </span></span><br><span class="line"><span class="comment">#在Linux7系统中, /bin, /sbin, /lib,	/lib64都以软链接的形式链接到/usr/⽬录下,例如:</span></span><br><span class="line">/bin --&gt; /usr/bin</span><br><span class="line">/sbin --&gt; /usr/sbin</span><br><span class="line">lib --&gt; usr/lib</span><br><span class="line">lib64 --&gt; usr/lib64</span><br></pre></td></tr></table></figure>

<h2 id="文件路径定位"><a href="#文件路径定位" class="headerlink" title="文件路径定位"></a>文件路径定位</h2><p>路径的作⽤:定位⽂件具体位置信息</p>
<p>你要在那⾥创建什么⽂件?</p>
<p>你要将什么⽂件复制到什么地⽅?</p>
<p>你要删除的⽂件在什么地⽅?</p>
<h3 id="特殊目录：-和"><a href="#特殊目录：-和" class="headerlink" title="特殊目录：(.)和(..)"></a>特殊目录：(.)和(..)</h3><p>在每个⽬录下, 都会固定存在两个特殊⽬录, 分别是⼀个点(.)和两个(..)的⽬录。⼀个点代表当的是当前⽬录, 两个点代表的是当前⽬录的上层⽬录。注意: 在Linux下所有以点开始的⽂件都是”隐藏⽂件”, 对于这类⽂件, 只使⽤命令 <em>ls    -l</em> 是看不到的, 必须要使⽤ <em>ls    -la</em> 才可以看到,如下所示:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@dennis.com /opt]$ ls -a</span><br><span class="line">.  ..</span><br></pre></td></tr></table></figure>

<h3 id="绝对路径"><a href="#绝对路径" class="headerlink" title="绝对路径"></a>绝对路径</h3><p>Linux系统采⽤了⽬录树的⽂件组织结构, 在Linux下每个⽬录或⽂件都可以从根⽬录处开始寻找,⽐如: /usr/bin ⽬录。这种从根⽬录开始的全路径被称为”绝对路径”, 绝对路径⼀定是以 “/” 开头的。</p>
<p>如何确认当前所在的⽬录, 可以使⽤ pwd 命令查看:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@dennis.com /]$ <span class="built_in">cd</span> tmp/</span><br><span class="line">[root@dennis.com /tmp]$ <span class="built_in">pwd</span></span><br><span class="line">/tmp</span><br></pre></td></tr></table></figure>

<h3 id="相对路径"><a href="#相对路径" class="headerlink" title="相对路径"></a>相对路径</h3><p>相对路径, 关键点在于当前在什么路径下。假设当前⽬录在 /usr/local 下, 那么它的上层⽬录(/usr⽬录)可以⽤ ../ 表示, ⽽` /usr/local 的下层⽬录(src)则可以⽤ ./src 表示。所谓的(.)和(..)⽬录实际上也是属于相对路径</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@dennis.com /tmp]$ <span class="built_in">cd</span> /opt/</span><br><span class="line">[root@dennis.com /opt]$ ls -la</span><br><span class="line">total 8</span><br><span class="line">drwxr-xr-x.  2 root root 4096 Apr 11  2018 .</span><br><span class="line">dr-xr-xr-x. 21 root root 4096 Jul 27 20:23 ..</span><br><span class="line"></span><br><span class="line"><span class="comment">#进⼊当前⽬录</span></span><br><span class="line">[root@dennis.com /opt]$ <span class="built_in">cd</span> .</span><br><span class="line">/<span class="comment">#显示当前⽬录</span></span><br><span class="line">[root@dennis.com /opt]$ <span class="built_in">pwd</span></span><br><span class="line">/opt</span><br><span class="line"></span><br><span class="line"><span class="comment">#进⼊当前⽬录的上层⽬录</span></span><br><span class="line">[root@dennis.com /opt]$ <span class="built_in">cd</span> ..</span><br><span class="line"><span class="comment">#进⼊上层⽬录,也就是/⽬录</span></span><br><span class="line">[root@dennis.com /]$ <span class="built_in">pwd</span></span><br><span class="line">/</span><br><span class="line">[root@dennis.com /]$ </span><br></pre></td></tr></table></figure>

<h3 id="cd-命令常见用法"><a href="#cd-命令常见用法" class="headerlink" title="cd 命令常见用法"></a><em>cd</em> 命令常见用法</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.	表示⽤户所处的当前⽬录</span><br><span class="line">..	表示上级⽬录;</span><br><span class="line">~	表示当前⽤户⾃⼰的家⽬录</span><br><span class="line"></span><br><span class="line">cd -	#切换上次所在⽬录</span><br><span class="line">cd ~	#切换当前用户家目录</span><br><span class="line">cd      #切换当前用户家目录</span><br><span class="line">cd .    #代表当前⽬录,⼀般在拷⻉、移动等情况下使⽤</span><br><span class="line">cd ..	#切换⾄当前⽬录的上级⽬录</span><br></pre></td></tr></table></figure>

<h2 id="目录管理命令"><a href="#目录管理命令" class="headerlink" title="目录管理命令"></a>目录管理命令</h2><h3 id="目录创建命令mkdir"><a href="#目录创建命令mkdir" class="headerlink" title="目录创建命令mkdir"></a>目录创建命令<em>mkdir</em></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#	mkdir dir1</span></span><br><span class="line"><span class="comment">#	mkdir /dir1	/home/xuliangwei/dir2</span></span><br><span class="line"><span class="comment">#	mkdir &#123;dir4,dir5&#125; -v</span></span><br><span class="line"><span class="comment">#	mkdir /dir6/dir6-1 -pv</span></span><br></pre></td></tr></table></figure>

<h3 id="以树状显示目录结构命令tree"><a href="#以树状显示目录结构命令tree" class="headerlink" title="以树状显示目录结构命令tree"></a>以树状显示目录结构命令<em>tree</em></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-L: 显示目录树的层级</span><br><span class="line"></span><br><span class="line"><span class="comment">#显示当前目录下的结构</span></span><br><span class="line">tree</span><br><span class="line"></span><br><span class="line"><span class="comment">#显示一级目录</span></span><br><span class="line">tree -L 1</span><br></pre></td></tr></table></figure>

<h2 id="文件管理命令"><a href="#文件管理命令" class="headerlink" title="文件管理命令"></a>文件管理命令</h2><p>Linux ⼀切皆为⽂件, 在对 Linux 进⾏配置时, 很⼤程度上就是处理⽂件的过程, 所以掌握⽂件的相关操作是⾮常有必要的。下⾯我们介绍如何对⽂件进⾏, 创建、删除、移动、重命名, 以及查看⽂件内容, ⾄于如何编辑⽂件, 在后⾯具体介绍编辑器的时候在做详细阐述。</p>
<h3 id="文件创建命令touch"><a href="#文件创建命令touch" class="headerlink" title="文件创建命令touch"></a>文件创建命令<em>touch</em></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">touch	filename</span><br><span class="line">touch	filename_1	filename_2</span><br><span class="line">touch	/home/xuliangwei/file5	file6</span><br><span class="line">touch	file&#123;1..10&#125;</span><br><span class="line">touch	file&#123;a,b,c&#125;</span><br><span class="line">touch	file&#123;a..z&#125;</span><br></pre></td></tr></table></figure>

<h3 id="文件时间stat"><a href="#文件时间stat" class="headerlink" title="文件时间stat"></a>文件时间<em>stat</em></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@dennis.com /]$ <span class="built_in">stat</span> /etc/passwd</span><br><span class="line">  File: ‘/etc/passwd’</span><br><span class="line">  Size: 1166      	Blocks: 8          IO Block: 4096   regular file</span><br><span class="line">Device: fd01h/64769d	Inode: 920061      Links: 1</span><br><span class="line">Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)</span><br><span class="line">Access: 2021-07-31 00:30:01.842102166 +0800</span><br><span class="line">Modify: 2021-07-13 00:20:38.628719887 +0800</span><br><span class="line">Change: 2021-07-13 00:20:38.629719911 +0800</span><br><span class="line"> Birth: -</span><br><span class="line"></span><br><span class="line">访问时间:atime，查看内容</span><br><span class="line">修改时间:mtime，修改内容</span><br><span class="line">改变时间:ctime，⽂件属性，⽐如权限</span><br><span class="line">删除时间:dtime，⽂件被删除的时间</span><br></pre></td></tr></table></figure>

<h3 id="⽂件⽬录复制命令-cp"><a href="#⽂件⽬录复制命令-cp" class="headerlink" title="⽂件⽬录复制命令 cp"></a>⽂件⽬录复制命令 <em>cp</em></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cp [OPTION]... [-T]	SOURCE DEST</span><br><span class="line">cp [OPTION]... SOURCE... DIRECTORY</span><br><span class="line">cp [OPTION]... -t DIRECTORY SOURCE...</span><br><span class="line"></span><br><span class="line">//将name⽂件复制⾄/tmp⽬录中</span><br><span class="line"><span class="comment"># cp name /tmp/name_copy</span></span><br><span class="line">//如果复制过想保持原⽂件名,不修改名称</span><br><span class="line"><span class="comment"># cp name /tmp/name</span></span><br><span class="line">//如果复制过想保持原来的属性, -p保持原⽂件或⽬录的属性</span><br><span class="line"><span class="comment"># cp -p name /tmp/name_p</span></span><br><span class="line">//复制⽬录只需要使⽤-r参数,递归复制</span><br><span class="line"><span class="comment"># mkdir name_name</span></span><br><span class="line"><span class="comment"># cp -r name_name/ /tmp/name_tmp</span></span><br><span class="line">//将多个⽂件拷⻉同⼀个⽬录</span><br><span class="line"><span class="comment"># cp -rv /etc/hosts /etc/hostname /tmp</span></span><br><span class="line"><span class="comment"># cp -rv /etc/hosts /etc/hostname ./</span></span><br><span class="line"></span><br><span class="line">//</span><br><span class="line"><span class="comment"># cp -rv /etc/hosts /etc/hosts.bak</span></span><br><span class="line"><span class="comment"># cp -rv /etc/&#123;hosts,hosts.bak&#125;</span></span><br><span class="line"><span class="comment"># cp -rv /etc/hosts&#123;,-org&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="⽂件⽬录移动命令-mv"><a href="#⽂件⽬录移动命令-mv" class="headerlink" title="⽂件⽬录移动命令 mv"></a>⽂件⽬录移动命令 <em>mv</em></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mv [OPTION]... [-T]	SOURCE DEST</span><br><span class="line">mv [OPTION]... SOURCE... DIRECTORY</span><br><span class="line">mv [OPTION]... -t DIRECTORY SOURCE...</span><br><span class="line"></span><br><span class="line">//移动⽂件⾄tmp⽬录</span><br><span class="line"><span class="comment"># mv file /tmp/</span></span><br><span class="line"></span><br><span class="line">//移动⽂件⾄tmp⽬录并修改名称为file_test</span><br><span class="line"><span class="comment"># mv file /tmp/file_test</span></span><br><span class="line"></span><br><span class="line">//移动⽬录⾄/tmp⽬录下</span><br><span class="line"><span class="comment"># mv dir/ /tmp/</span></span><br><span class="line"></span><br><span class="line">//移动多个⽂件或多个⽬录⾄同⼀个⽬录</span><br><span class="line"><span class="comment"># touch file&#123;1..3&#125;</span></span><br><span class="line"><span class="comment"># mv file1 file2 file3 /opt/</span></span><br><span class="line"><span class="comment"># mkdir dir&#123;1..3&#125;</span></span><br><span class="line"><span class="comment"># mv dir1/ dir2/ dir3/ /opt</span></span><br></pre></td></tr></table></figure>

<h3 id="文件目录删除命令rm"><a href="#文件目录删除命令rm" class="headerlink" title="文件目录删除命令rm"></a>文件目录删除命令<em>rm</em></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rm OPTION]... FILE...</span><br><span class="line">-r 递归</span><br><span class="line">-f 强制删除</span><br><span class="line">-v 详细过程</span><br><span class="line"></span><br><span class="line"><span class="comment">#删除⽂件,默认会提醒是否删除⽂件</span></span><br><span class="line">rm anan</span><br><span class="line"></span><br><span class="line"><span class="comment">#强制删除⽂件,不提醒</span></span><br><span class="line">rm anan -f</span><br><span class="line"></span><br><span class="line"><span class="comment">#强制删除目录，会提醒</span></span><br><span class="line">rm -r dir/</span><br><span class="line"></span><br><span class="line"><span class="comment">#强制删除目录，不提醒</span></span><br><span class="line">rm -rf dir/</span><br><span class="line"></span><br><span class="line"><span class="comment">#示例</span></span><br><span class="line">mkdir /home/dir10</span><br><span class="line">touch /home/dir10/&#123;file2,file3,.file4&#125;</span><br><span class="line">rm -rf /home/dir10/* <span class="comment">#不包括隐藏⽂件</span></span><br><span class="line">ls /home/dir10/	-a</span><br><span class="line">.	..	.file4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//示例2</span><br><span class="line">touch file&#123;1..10&#125;</span><br><span class="line">touch &#123;1..10&#125;.pdf</span><br><span class="line">rm -rf file*	</span><br><span class="line">rm -rf *.pdf</span><br></pre></td></tr></table></figure>

<h3 id="文件查看命令"><a href="#文件查看命令" class="headerlink" title="文件查看命令"></a>文件查看命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat	 //查看⽂件内容</span><br><span class="line">示例：cat /etc/passwd</span><br><span class="line">示例：cat -n /etc/passwd <span class="comment">#-n参数⾏号</span></span><br><span class="line">示例：cat &gt;&gt; aa.txt &lt;&lt;<span class="string">EOF #追加数据</span></span><br><span class="line"><span class="string">         &gt;&gt; test</span></span><br><span class="line"><span class="string">		 &gt;&gt; EOF</span></span><br><span class="line"></span><br><span class="line">head <span class="comment">#查看⽂件头部内容，默认前⼗⾏</span></span><br><span class="line">示例：head	/etc/passwd				</span><br><span class="line">示例：head	-n5 /etc/passwd  <span class="comment">#-n参数指定查看头⼏⾏</span></span><br><span class="line"></span><br><span class="line">tail <span class="comment">#查看⽂件尾部内容，默认最后⼗⾏</span></span><br><span class="line">示例：tail	/etc/passwd				</span><br><span class="line">示例：tail	-f /var/<span class="built_in">log</span>/messages  <span class="comment">#-f参数跟随尾部输出⽽变化</span></span><br><span class="line"></span><br><span class="line">more <span class="comment">#按空格可翻⻚查看⽂件内容，按q可推出</span></span><br><span class="line">示例：more	/etc/passwd</span><br><span class="line">less //和more类似</span><br><span class="line">示例：less	/etc/passwd</span><br></pre></td></tr></table></figure>

<h3 id="文件下载命令"><a href="#文件下载命令" class="headerlink" title="文件下载命令"></a>文件下载命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget /<span class="comment">#⽂件下载</span></span><br><span class="line">-O <span class="comment">#指定下载地址,更改名称		</span></span><br><span class="line">-T <span class="comment">#超时时间</span></span><br><span class="line">-q <span class="comment">#安静下载(关闭wget输出)</span></span><br><span class="line">--spider <span class="comment">#⽹络爬⾍		</span></span><br><span class="line">示例：wget	http://www.baidu.com</span><br><span class="line">curl <span class="comment">#⽂件下载</span></span><br><span class="line">示例：curl -o http://www.baidu.com</span><br><span class="line">yum	install lrzsz</span><br><span class="line">rz <span class="comment">#⽂件上传</span></span><br><span class="line">sz <span class="comment">#⽂件下载</span></span><br><span class="line">示例：sz filename</span><br></pre></td></tr></table></figure>

<h3 id="命令查找命令"><a href="#命令查找命令" class="headerlink" title="命令查找命令"></a>命令查找命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">locate	<span class="comment">#查找⽂件或者⽬录</span></span><br><span class="line">示例：locate /etc/sh <span class="comment">#搜索etc⽬录下所有以sh开头的⽂件</span></span><br><span class="line">示例：locate -i /etc/sh <span class="comment">#搜索etc⽬录下，所有以sh开头的⽂件，忽略⼤⼩写</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">which</span> <span class="comment">#查找系统PATH变量⽬录下的命令(绝对路径)</span></span><br><span class="line">示例：<span class="built_in">which</span> ls</span><br><span class="line"></span><br><span class="line">whereis	<span class="comment">#查找⽂件索引数据库下的命令、源⽂件、man⽂件。⾮PATH变量查找，所以查找的⾯⽐which要⼴ -b, -m</span></span><br><span class="line">示例：whereis ls</span><br><span class="line">示例：whereis -b ls</span><br></pre></td></tr></table></figure>

<h2 id="字符处理命令"><a href="#字符处理命令" class="headerlink" title="字符处理命令"></a>字符处理命令</h2><h3 id="使用sort排序"><a href="#使用sort排序" class="headerlink" title="使用sort排序"></a>使用<em>sort</em>排序</h3><p>很多情况下需要对无序的数据排序，这是需要用到sort排序了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sort [OPTION]... [FILE]...</span><br><span class="line">-r：倒序</span><br><span class="line">-n：按数字排序</span><br><span class="line">-t：指定分隔符(默认空格)</span><br><span class="line">-k：指定第⼏列, 指定⼏列⼏字符（指定1.1, 3.1, 3.3）</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#演示soft的⽤法, ⾸先创建⼀个⽂件:</span></span><br><span class="line">[root@dennis.com ~]<span class="comment"># cat &gt;&gt; sort.txt &lt;&lt;EOF</span></span><br><span class="line">b:3</span><br><span class="line">c:2</span><br><span class="line">a:4</span><br><span class="line">e:5</span><br><span class="line">d:1</span><br><span class="line">f:11</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment">#下⾯对输出的内容进⾏排序:</span></span><br><span class="line">[root@dennis.com ~]<span class="comment"># sort sort.txt</span></span><br><span class="line">a:4</span><br><span class="line">b:3</span><br><span class="line">c:2</span><br><span class="line">d:1</span><br><span class="line">e:5</span><br><span class="line">f:11</span><br><span class="line"></span><br><span class="line"><span class="comment">#可观察到,	sort⽂件具有⼀个特点,第⼀个字符是字⺟,第三个字符是数字,中间是⽤冒号隔开。</span></span><br><span class="line"><span class="comment">#这样我们可以使⽤-t指定分隔符,	使⽤-k指定⽤于排序的列了。</span></span><br><span class="line">[root@dennis.com ~]<span class="comment"># sort -t &quot;:&quot; -k2 sort.txt</span></span><br><span class="line">d:1</span><br><span class="line">f:11 <span class="comment">#第⼆⾏为什么是11？不应该按照顺序排列？</span></span><br><span class="line">c:2</span><br><span class="line">b:3</span><br><span class="line">a:4</span><br><span class="line">e:5</span><br><span class="line"></span><br><span class="line"><span class="comment">#按照排序的⽅式,	只会看到第⼀个字符,11的第⼀个字符是1,	按照字符来排序确实⽐2⼩。</span></span><br><span class="line"><span class="comment">#如果想要按照数字的⽅式进⾏排序, 需要使⽤-n参数。</span></span><br><span class="line">[root@dennis.com ~]<span class="comment"># sort -t &quot;:&quot; -n -k2 sort.txt</span></span><br><span class="line">d:1</span><br><span class="line">c:2</span><br><span class="line">b:3</span><br><span class="line">a:4</span><br><span class="line">e:5</span><br><span class="line">f:11</span><br><span class="line"></span><br><span class="line"><span class="comment">#测试案例,对下⾯内容进⾏排序</span></span><br><span class="line">192.168.3.1 00:0F:AF:81:19:1F</span><br><span class="line">192.168.3.2 00:0F:AF:85:6C:25</span><br><span class="line">192.168.3.3 00:0F:AF:85:70:42</span><br><span class="line">192.168.2.20 00:0F:AF:85:55:DE</span><br><span class="line">192.168.2.21 00:0F:AF:85:6C:09</span><br><span class="line">192.168.2.22 00:0F:AF:85:5C:41</span><br><span class="line">192.168.0.151 00:0F:AF:85:6C:F6</span><br><span class="line">192.168.0.152 00:0F:AF:83:1F:65</span><br><span class="line">192.168.0.153 00:0F:AF:85:70:03</span><br><span class="line">192.168.1.10 00:30:15:A2:3B:B6</span><br><span class="line">192.168.1.11 00:30:15:A3:23:B7</span><br><span class="line">192.168.1.12 00:30:15:A2:3A:A1</span><br><span class="line">192.168.1.1 00:0F:AF:81:19:1F</span><br><span class="line">192.168.2.2 00:0F:AF:85:6C:25</span><br><span class="line">192.168.3.3 00:0F:AF:85:70:42</span><br><span class="line">192.168.2.20 00:0F:AF:85:55:DE</span><br><span class="line">192.168.1.21 00:0F:AF:85:6C:09</span><br><span class="line">192.168.2.22 00:0F:AF:85:5C:41</span><br><span class="line">192.168.0.151 00:0F:AF:85:6C:F6</span><br><span class="line">192.168.1.152 00:0F:AF:83:1F:65</span><br><span class="line">192.168.0.153 00:0F:AF:85:70:03</span><br><span class="line">192.168.3.10 00:30:15:A2:3B:B6</span><br><span class="line">192.168.1.11 00:30:15:A3:23:B7</span><br><span class="line">192.168.3.12 00:30:15:A2:3A:A1</span><br><span class="line"><span class="comment">#针对第三列的第⼀个字符,第四列的第⼀个字符到第三个字符排序才是正确</span></span><br><span class="line">[root@dennis.com ]<span class="comment"># sor -t. -k3.1,3.1nr -k4.1,4.3nr test.txt使⽤uniq删除重复内容</span></span><br></pre></td></tr></table></figure>

<h3 id="使用uniq删除重复内容"><a href="#使用uniq删除重复内容" class="headerlink" title="使用uniq删除重复内容"></a>使用<em>uniq</em>删除重复内容</h3><p>如果⽂件中有多⾏完全相同的内容, 当前是希望能删除重复的⾏，同时还可以统计出完全相同的行出现的总次数, 那么就可以使⽤ uniq 命令解决这个问题(但是必须配合 sort 使⽤)。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">uniq [OPTION]... [INPUT [OUTPUT]]</span><br><span class="line">-c 计算重复的⾏</span><br><span class="line"></span><br><span class="line">//演示uniq的⽤法,⾸先创建⼀个⽂件:</span><br><span class="line">[root@dennis.com~]<span class="comment">#	cat	uniq.txt</span></span><br><span class="line">abc</span><br><span class="line">123</span><br><span class="line">abc</span><br><span class="line">123</span><br><span class="line">//uniq需要和sort⼀起使⽤, 先使⽤sort排序,让重复内容连续在⼀起</span><br><span class="line">[root@dennis.com~]<span class="comment">#	cat	uniq.txt | sort</span></span><br><span class="line">123</span><br><span class="line">123</span><br><span class="line">abc</span><br><span class="line">abc</span><br><span class="line">//使⽤uniq去除相邻重复的⾏</span><br><span class="line">[root@dennis.com ~]<span class="comment"># cat uniq.txt | sort | uniq</span></span><br><span class="line">123</span><br><span class="line">abc</span><br><span class="line">//使⽤-c参数,能统计出⽂件中每⾏内容重复的次数</span><br><span class="line">[root@dennis.com ~]<span class="comment"># cat uniq.txt | sort | uniq	-c</span></span><br><span class="line">2 123</span><br><span class="line">2 abc</span><br></pre></td></tr></table></figure>

<h3 id="使用cut命令截取某一个字段"><a href="#使用cut命令截取某一个字段" class="headerlink" title="使用cut命令截取某一个字段"></a>使用cut命令截取某一个字段</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cut	OPTION... [FILE]...</span><br><span class="line">-d：指定分隔符</span><br><span class="line">-f：数字,取第⼏列 –f3,6三列和6列</span><br><span class="line">-c：按字符取(空格也算)</span><br><span class="line"></span><br><span class="line">//测试数据,	过滤出⽂件⾥ xuliangwei以及552408925</span><br><span class="line"><span class="comment">#echo “Im xuliangwei, is QQ 552408925” &gt; xuliangwei.com</span></span><br><span class="line"></span><br><span class="line">//实践思路</span><br><span class="line">sed <span class="string">&#x27;s#,# #g&#x27;</span> xuliangwei.txt | cut -d <span class="string">&quot; &quot;</span> -f2,6</span><br><span class="line">sed <span class="string">&#x27;s#,# #g&#x27;</span> xuliangwei.txt | awk -F <span class="string">&quot; &quot;</span> <span class="string">&#x27;&#123;print $2 &quot; &quot; $5&#125;&#x27;</span></span><br><span class="line">awk -F <span class="string">&#x27;[, ]+&#x27;</span> <span class="string">&#x27;&#123;print $2,$5&#125;&#x27;</span> xuliangwei.txt	</span><br><span class="line">awk <span class="string">&#x27;&#123;print $2 $5&#125;&#x27;</span> xuliangwei.txt | awk -F	<span class="string">&quot;,&quot;</span>	<span class="string">&#x27;&#123;print $1&quot;	&quot;$2&#125;&#x27;</span></span><br><span class="line">awk -F <span class="string">&quot;[, ]&quot;</span> <span class="string">&#x27;&#123;print $2 &quot; &quot; $6&#125;&#x27;</span>	xuliangwei.txt	</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">此类问题是运维⼯作中最常⻅的问题。可以演变成分析⽇志，查看TCP各个状态连接数，查看单IP接数排名等</span><br><span class="line">[root@dennis.com]<span class="comment">#	cat	web.log</span></span><br><span class="line">http://www.xuliangwei.com/index.html</span><br><span class="line">http://www.xuliangwei.com/1.html</span><br><span class="line">http://post.xuliangwei.com/index.html</span><br><span class="line">http://mp3.xuliangwei.com/index.html</span><br><span class="line">http://www.xuliangwei.com/3.html</span><br><span class="line">http://post.xuliangwei.com/2.html</span><br><span class="line"></span><br><span class="line">[root@dennis.com ]<span class="comment">#	awk -F &#x27;/&#x27; &#x27;&#123;print $3&#125;&#x27; web.log | sort -rn | uniq –c</span></span><br><span class="line">3 www.xuliangwei.comxuliangwei.com</span><br><span class="line">2 post.xuliangwei.comxuliangwei.com</span><br><span class="line">1 mp3.xuliangwei.comxuliangwei.com</span><br><span class="line"></span><br><span class="line">[root@dennis.com ]<span class="comment">#	cut	-d / -f3 web.log | sort -rn | uniq –c</span></span><br><span class="line">3 www.xuliangwei.comxuliangwei.com</span><br><span class="line">2 post.xuliangwei.comxuliangwei.com</span><br><span class="line">1 mp3.xuliangwei.comxuliang</span><br></pre></td></tr></table></figure>

<h3 id="使用wc统计"><a href="#使用wc统计" class="headerlink" title="使用wc统计"></a>使用wc统计</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wc - <span class="built_in">print</span> newline,	word, and byte counts <span class="keyword">for</span> each file显示⽂件的⾏、单词与字节统计信息</span><br><span class="line"></span><br><span class="line"><span class="comment">#统计fstab有多少⾏</span></span><br><span class="line">[root@dennis.com ~]<span class="comment"># wc -l /etc/fstab</span></span><br><span class="line">15 /etc/fstab</span><br><span class="line"></span><br><span class="line"><span class="comment">#显示/etc/services	⽂件⾏号</span></span><br><span class="line">[root@dennis.com ~]<span class="comment"># wc -l /etc/services	</span></span><br><span class="line">10774 /etc/services</span><br><span class="line"></span><br><span class="line"><span class="comment">#扩展⽅法</span></span><br><span class="line">[root@dennis.com ~]<span class="comment"># grep -n &quot;.&quot; /etc/services | tail -1</span></span><br><span class="line">[root@dennis.com ~]<span class="comment"># awk &#x27;&#123;print NR	$0&#125;&#x27; /etc/services | tail -1</span></span><br><span class="line">[root@dennis.com ~]<span class="comment"># cat -n /etc/services | tail -1</span></span><br><span class="line">[root@dennis.com ~]<span class="comment"># sed &#x27;=&#x27; /etc/services | tail -2</span></span><br></pre></td></tr></table></figure>







































<script src='https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/mouse_snow.min.js'></script>

]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
      <tags>
        <tag>命令</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux用户管理</title>
    <url>/Linux%E5%9F%BA%E7%A1%80/Linux%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h1><span id="more"></span>

<hr>
<h2 id="1-用户和用户组的概念"><a href="#1-用户和用户组的概念" class="headerlink" title="1 用户和用户组的概念"></a>1 用户和用户组的概念</h2><ol>
<li><strong>用户概念：</strong></li>
</ol>
<p>在linux中一切都是文件（文件夹和硬件设备是特殊的文件)，如果有可能尽量使用文本文件。文本文件是人和机器能理解的文件，也成为人和机器进行交流的最好途径。由于所有的配置文件都是文本，所以你只需要一个最简单的编辑器就可以修改。由于修改文本文件如此简单，所以Linux系统本身肯定要加以规范。这就引出了用户(组)和权限这2个概念。而这2个概念的引入，完美的保证了Linux的安全性，同时没有添加复杂性。由于一切皆为文件。所以Linux引入了3个文件来管理用户（组）， /etc/passwd存放用户信息，/etc/shadow存放用户密码信息，/etc/group存放组信息，然后在文件系统中的每个文件的文件头里面添加了用户和文件之间的关系信息。</p>
<ol start="2">
<li><p><strong>用户、组、文件有三种关系：</strong></p>
<ul>
<li><p>用户和文件的关系只有2种：拥有和不拥有。</p>
</li>
<li><p>组合文件的关系只有2种：拥有和不拥有。</p>
</li>
<li><p>组和用户的关系只有2种：属于和不属于。</p>
</li>
</ul>
</li>
<li><p><strong>将这三种关系叠加，用户和文件的最终关系可以归纳为3类：</strong></p>
<ul>
<li><p>用户拥有该文件。</p>
</li>
<li><p>用户属于哪个组，某个组拥有该文件（既用户通过属于某个组拥有该文件）。</p>
</li>
<li><p>用户不拥有该文件。</p>
</li>
</ul>
</li>
<li><p><strong>用户分类：</strong></p>
</li>
</ol>
<table>
<thead>
<tr>
<th>用户分类</th>
<th>作用</th>
<th>特定</th>
</tr>
</thead>
<tbody><tr>
<td>超级用户root (uid == 0)</td>
<td>管理维护整个系统</td>
<td>最高管理权限</td>
</tr>
<tr>
<td>普通用户(uid &gt;= 1000)</td>
<td>只能查看和管理自己的一亩三分地</td>
<td>管理特定服务,为了安全</td>
</tr>
<tr>
<td>程序用户(uid&gt;200 &amp;&amp; uid&lt;1000)</td>
<td>让Linux下面服务正常运行所需要</td>
<td>为了服务正常运行所需要并不需要登录到系统设置密码切换密、切换用户</td>
</tr>
</tbody></table>
<ol start="5">
<li><strong>用户组概念</strong>：</li>
</ol>
<p>每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同Linux 系统对用户组的规定有所不同，如Linux下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。</p>
<ol start="6">
<li><strong>用户组的分类:</strong><ul>
<li>默认组： 创建与用户组同名的组；</li>
</ul>
</li>
</ol>
<ul>
<li>基本组：主要的组；    -g 指定；<ul>
<li>附加组：额外指定的组；    -G 指定；</li>
</ul>
</li>
</ul>
<hr>
<h2 id="2-用户和用户组信息的查看"><a href="#2-用户和用户组信息的查看" class="headerlink" title="2. 用户和用户组信息的查看"></a>2. 用户和用户组信息的查看</h2><table>
<thead>
<tr>
<th>用户分类</th>
<th>作用</th>
<th>特定</th>
</tr>
</thead>
<tbody><tr>
<td>超级用户root (uid == 0)</td>
<td>管理维护整个系统</td>
<td>最高管理权限</td>
</tr>
<tr>
<td>普通用户(uid &gt;= 1000)</td>
<td>只能查看和管理自己的一亩三分地</td>
<td>管理特定服务,为了安全</td>
</tr>
<tr>
<td>程序用户(uid&gt;200 &amp;&amp; uid&lt;1000)</td>
<td>让Linux下面服务正常运行所需要</td>
<td>为了服务正常运行所需要并不需要登录到系统设置密码切换密、切换用户</td>
</tr>
</tbody></table>
<ol>
<li><strong>查看用户信息命令：<em>cat /etc/passwd</em></strong></li>
</ol>
<ul>
<li><p>/etc/passwd;  用户信息;</p>
</li>
<li><p>root:X:0:0:root:/root:/bin/bash  以冒号为分隔符;</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">字段1：用户名  --&gt; root</span><br><span class="line">字段2：密码占位符  --&gt; x （这里都是用x代替）</span><br><span class="line">字段3：uid，用户id  --&gt; 0</span><br><span class="line">字段4：gid ，组id --&gt; 0</span><br><span class="line">字段5：用户描述信息  --&gt; root</span><br><span class="line">字段6：家目录  --&gt;  /root</span><br><span class="line">字段7：登录 shell（用户登陆shell ，当为/bin/bash表示可以登陆，/sbin/nologin表示不被授权登陆）</span><br></pre></td></tr></table></figure>

<p><font color='red'>注：</font>一般来说，只有 root 用户的 uid 是为0的。如果黑客把一个普通用户的 uid 修改为0的话，那么他只要以普通用户的用户名和密码登录，系统就会自动切换到root用户。所以，系统加固的时候一定要过滤出有哪些用户的UID为0</p>
<ol start="2">
<li><strong>查看用户密码信息命令：<em>cat/etc/shadow</em></strong></li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/etc/shadow;  密码信息;</span><br><span class="line">bin:*:18353:0:99999:7:::</span><br><span class="line">字段1：用户名</span><br><span class="line">字段2：通过sha-512加密(二次加密，在经过第一次加密后，第二次加入随机数再次加密)的密码</span><br><span class="line">字段3：最后一次修改密码距离1970年1月1日的天数间隔</span><br><span class="line">字段4：密码最短有效期</span><br><span class="line">字段5：密码最长有效期</span><br><span class="line">字段6：密码过期前几天进行警告</span><br><span class="line">字段7：账户过期后，被锁定的天数</span><br><span class="line">字段8：账号失效时间距离1970年1月1日的天数间隔</span><br><span class="line">字段9：未分配功能</span><br><span class="line"></span><br><span class="line">ps: 字段2是用户的密码位，如果是 * 表示该用户禁用，!! 表示用户密码未初始化，如果为空，表示空密码的</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>查看用户组信息的命令：<em>cat/etc/group</em></strong></li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">组信息的显示有四个字段:</span><br><span class="line">字段1：组名称 --&gt; root</span><br><span class="line">字段2：组密码占位符  --&gt; x</span><br><span class="line">字段3：gid --&gt; 0</span><br><span class="line">字段4：组成员</span><br></pre></td></tr></table></figure>

<p><font color='red'>ps</font>:一个用户只能有一个主要组，最多可以有31个附加组。主要组是用户创建文件时默认的所有组，附加组主要用于权限管理。不论用户属于哪个组，用户都能拥有该组的权限。</p>
<p><font color='blue'><strong>特殊组wheel</strong></font>：在Linux中有一个特殊组<font color='red'>wheel</font>，wheel组就类似于一个管理员的组。在linux中，即使我们有系统管理员root的权限，也不推荐用root用户登录。一般情况下用普通用户登录就可以了，在需要root权限执行一些操作时，再su登录成为root用户。但是，任何人只要知道了root用户的密码，就都可以通过su命令来登录为root用户–这无疑为系统带来了安全隐患。所以，将普通用户加入到wheel组中，被加入的这个普通用户就成了管理员组内的用户了，然后可以修改配置文件使得只有wheel组内的用户可以切换到root用户。</p>
<hr>
<h2 id="3-用户和用户组的管理"><a href="#3-用户和用户组的管理" class="headerlink" title="3. 用户和用户组的管理"></a>3. 用户和用户组的管理</h2><h3 id="3-1用户的创建、删除和修改"><a href="#3-1用户的创建、删除和修改" class="headerlink" title="3.1用户的创建、删除和修改"></a>3.1用户的创建、删除和修改</h3><p><strong><font color='blue'>新建用户系统会做这三件事:</font></strong></p>
<ol>
<li>新建用户时，系统会将 /etc/skel 中的目录及文件拷贝到新建用户的家目录中。</li>
<li>在 /var/spool/mail 中，新建用户名的邮箱 。</li>
<li>在 /etc下的 passwd 、shadow 、group文件中，增加用户信息</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">whoami #我是谁</span><br><span class="line">useradd #创建用户</span><br><span class="line">		-u:	指定UID;</span><br><span class="line">		-c: 指定注释;</span><br><span class="line">		-s: 指定登录shell类型; /bin/bash  /sbin/nologin;</span><br><span class="line">		-G: 指定附加组;</span><br><span class="line">		-a: 追加;</span><br><span class="line">		-g: 指定基本组;</span><br><span class="line">		-r: 指定为系统用户 (UID 201-999)</span><br><span class="line">		-M: 不创建用户的家目录;</span><br><span class="line">		-d：指定其家目录；</span><br><span class="line">usermod: #修改用户;选项参照useradd</span><br><span class="line">userdel: </span><br><span class="line">		 1.#删除用户</span><br><span class="line">			-r: 同时删除用户以及用户家目录;</span><br><span class="line">		 2.# 有进程正在使用该用户,所以无法删除; 只有进程退出后;用户没有被占用,才可以处理;</span><br><span class="line">			kill -9 [要干掉的进程ID]</span><br><span class="line">			userdel username</span><br><span class="line">		 3.# 不加 -r 参数，只删除 passwd、shadow 和 group 文件中的用户信息，/home 目录下的文件不删除，/var/spool/mail/ 下的文件不删除</span><br><span class="line">		   # 加 -r 参数，删除 passwd、shadow 和 group 文件中的用户信息，同时删除用户的家目录和邮箱		   	</span><br><span class="line">			userdel -r username</span><br></pre></td></tr></table></figure>

<p>以下这条命令直接生成一个具有root权限的用户：venus，密码为：123qwe 。前提是这条命令的执行需要root权限。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">useradd -p `openssl passwd -1 -salt &#x27;user&#x27; 123qwe` -u 0 -o -g root  -G root -s /bin/bash -d /home/user venus</span><br></pre></td></tr></table></figure>

<p><font color='red'>注</font>：用户创建时，默认的属性（比如UID，GID，是否创建家目录，创建邮箱等）都是通过/etc/login.defs文件控制的，修改此文件的属性，会影响以后创建的所有用户。也可以创建用户时指定参数修改，这样只对当前创建用户有效</p>
<p><strong><font color='blue'>删除用户：</font></strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">userdel  -r  james  #删除用户一定记得加 -r 参数 ！！</span><br></pre></td></tr></table></figure>

<ol>
<li>不加 -r 参数，只删除 passwd、shadow 和 group 文件中的用户信息，/home 目录下的文件不删除，/var/spool/mail/ 下的文件不删除。</li>
<li>加 -r 参数，删除 passwd、shadow 和 group 文件中的用户信息，同时删除用户的家目录和邮箱。</li>
</ol>
<p><strong><font color='blue'>修改用户属性：</font></strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">usermod   参数   james</span><br><span class="line"></span><br><span class="line">-s 修改用户的登陆shell   usermod -s /sbin/nologin james </span><br><span class="line">-L 账户锁定  (可以通过 passwd -S  账户名 查看账户的状态)</span><br><span class="line">-U 解锁账户</span><br><span class="line">-g  修改账户所在组   例：将bob所在组改成james：usermod  -g  james   bob   </span><br><span class="line">-G  给账户添加附加组  例：给bob添加一个附加组john：usermod  -G  john  bob；从附加组john中删除用户bob：gpasswd -d  bob  john</span><br><span class="line">-a  默认情况下，当用户已经存在附加组时，再添加附加组则会把之前的附加组给替换了，加 -a 参数，则不替换原来的附加组，意味着该用户可以有多个附加组。</span><br></pre></td></tr></table></figure>

<p><strong><font color='blue'>锁定和解锁用户：</font></strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">锁定用户：usermod -L www    或   passwd -l www</span><br><span class="line">解锁用户：usermod -U www   或   passwd -u www</span><br><span class="line">查看用户状态：passwd -S www</span><br><span class="line"></span><br><span class="line">注：虽然 usermod 和 passwd 这两个命令都可以锁定和解锁用户，但是还是有区别的。区别之一就是passwd命令操作完后会有提示。还有一个区别就是 passwd 的权限比 usermod 大，使用 usermod 锁定的用户可以用 passwd 来解锁，但是使用 passwd 锁定的用户不能用 usermod 来解锁</span><br></pre></td></tr></table></figure>

<h3 id="3-2-用户密码修改"><a href="#3-2-用户密码修改" class="headerlink" title="3.2 用户密码修改"></a>3.2 用户密码修改</h3><ul>
<li><p>修改命令使用passwd来实现：</p>
<p>1.超级管理员:</p>
<pre><code>        1.1) 随意修改任何人的密码;
        1.2) 密码强度可以随意;
</code></pre>
<p>2.普通用户执行:</p>
<pre><code>        2.1) 仅修改自己的密码,不可以修改其他人;
        2.2) 密码强度必须满足8个字符及以上;
</code></pre>
<p>3.passwd使用方法:</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1.交互式修改密码：</span><br><span class="line">	passwd username</span><br><span class="line">2.非交互式修改密码：</span><br><span class="line">	echo &quot;passwd&quot; | passwd --stdin username</span><br><span class="line">	Changing password for user jack.</span><br><span class="line">	passwd: all authentication tokens updated successfully.	</span><br><span class="line">如果想要设置强度较高的密码需要安装 </span><br><span class="line"><span class="meta">	#</span><span class="bash">yum install -y expect</span> </span><br><span class="line"><span class="meta">			#</span><span class="bash"> -l 长度</span></span><br><span class="line"><span class="meta">			#</span><span class="bash"> -d 数字</span></span><br><span class="line"><span class="meta">			#</span><span class="bash"> -c 小写</span></span><br><span class="line"><span class="meta">			#</span><span class="bash"> -C 大写</span></span><br><span class="line"><span class="meta">			#</span><span class="bash"> -s 特殊字符</span></span><br><span class="line">			mkpasswd -l 10 -d 3 -c 3 -C 3 -s 1</span><br><span class="line">			Y44ssjSG0,</span><br><span class="line">	echo &quot;$(mkpasswd -l 10 -d 3 -c 3 -C 3 -s 1)&quot; | tee ok.txt | passwd --stdin tom</span><br><span class="line">	Changing password for user jack.</span><br><span class="line">	passwd: all authentication tokens updated successfully.</span><br><span class="line">	[root@tom /]# cat ok.txt </span><br><span class="line">1hNOp*H63y</span><br><span class="line"><span class="meta">	#</span><span class="bash">tee -a //追加</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">生成密码的方法</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">方法1</span> </span><br><span class="line"> mkpasswd -l 16  #16位密码</span><br><span class="line"><span class="meta"> </span></span><br><span class="line"><span class="meta"> #</span><span class="bash">方法2</span></span><br><span class="line"> echo  $RANDOM|md5sum |head -c16</span><br><span class="line"> RANDOM 系统变量(环境变量) 生成随机数字 </span><br><span class="line"><span class="meta"> </span></span><br><span class="line"><span class="meta"> #</span><span class="bash">方法3 date</span> </span><br><span class="line"> date +%N |md5sum  |head -c16</span><br><span class="line"><span class="meta"> </span></span><br><span class="line"><span class="meta"> #</span><span class="bash">方法4  了解</span></span><br><span class="line"> [root@oldboyedu ~]# echo  123  |tr 123 abc</span><br><span class="line">abc</span><br><span class="line">[root@oldboyedu ~]# </span><br><span class="line">[root@oldboyedu ~]# echo  123123  |tr 123 abc</span><br><span class="line">abcabc</span><br><span class="line">[root@oldboyedu ~]# echo  112233  |tr 123 abc</span><br><span class="line">aabbcc</span><br><span class="line">[root@oldboyedu ~]# #1对1的替换 </span><br><span class="line">[root@oldboyedu ~]# #tr 替换  </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">tr 生成随机字符 (删除)</span></span><br><span class="line">-d 删除</span><br><span class="line">-c 取反</span><br><span class="line">tr -cd  &#x27;0-9&#x27;  &lt;/dev/urandom |head -c16</span><br><span class="line">tr -cd  &#x27;a-zA-Z0-9&#x27;  &lt;/dev/urandom |head -c16</span><br></pre></td></tr></table></figure>

<p>注：借助chage指令，可以修改用户的密码策略，也可通过编辑 /etc/shadow (不建议)</p>
<p>​        比如：chage  -l  bob，查看用户bob的密码策略</p>
<p>​       chage -M 90 bob，将用户bob的密码有效期修改为90天</p>
<p>​        脚本实现修改用户的密码策略</p>
<ul>
<li><font color='red'><strong>练习：</strong></font></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1.#批量创建10个用户oldboy01..oldboy10,并设置123456为密码(不能用循环等语句,如for,while等)</span><br><span class="line">echo oldboy&#123;01..10&#125;|xargs -n1|sed -r &#x27;s#(.*)#useradd \1; echo 123456|passwd --stdin \1#g&#x27;|bash</span><br><span class="line"></span><br><span class="line">2.#批量创建10个用户oldboy01..oldboy10,并设置随机8为密码(不能用循环等语句,如for,while等)</span><br><span class="line">echo oldboy&#123;11..20&#125; |xargs -n1|sed -r &#x27;s#(.*)#useradd \1;p=`mkpasswd -l 8`;echo $p|passwd --stdin \1;echo \1 $p&gt;&gt;/root/pass.txt#g&#x27; |bash</span><br></pre></td></tr></table></figure>

<h3 id="3-3用户组管理"><a href="#3-3用户组管理" class="headerlink" title="3.3用户组管理"></a>3.3用户组管理</h3><p><strong><font color='blue'>添加组：</font></strong> groupadd www</p>
<ol>
<li> -g, –gid                      为新组使用 GID，例 groupadd -g 2000 xie  创建新组xie，并且gid设置为2000</li>
<li> -K, –key                    不使用 /etc/login.defs 中的默认值</li>
<li> -o, –non-unique      允许创建有重复 GID 的组</li>
<li> -p, –password         为新组使用此加密过的密码</li>
<li> -r, –system               创建一个系统账户</li>
</ol>
<p><strong><font color='blue'>删除组：</font></strong> groupdel www</p>
<p> -r , –remove                    删除主目录和邮件池</p>
<p><strong><font color='blue'>修改组的属性： </font></strong> groupmod www</p>
<p> -g, –gid GID                    将组 ID 改为 GID<br>         -n, –new-name             改名为 NEW_GROUP<br>         -o, –non-unique           允许使用重复的 GID</p>
<p><strong><font color='blue'>修改组中的用户：groupmems： </font></strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">groupmems   -a  john  -g  www    将用户john加到www组中</span><br><span class="line">groupmems   -d  john  -g  www    将用户john从xie组中移除 或 gpasswd -d  john  www</span><br></pre></td></tr></table></figure>











]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
      <tags>
        <tag>用户</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux系统Bash初识</title>
    <url>/Linux%E5%9F%BA%E7%A1%80/Linux%E7%B3%BB%E7%BB%9FBash%E5%88%9D%E8%AF%86%E5%88%AB/</url>
    <content><![CDATA[<h2 id="Linux系统终端"><a href="#Linux系统终端" class="headerlink" title="Linux系统终端"></a>Linux系统终端</h2><p>服务器终端切换：Ctrl + Alt +F1 … F6</p>
<p>虚拟机终端切换： Ctrl + Shift + Alt + F1 … F6</p>
<p>虚拟终端由<em>mingetty</em>程序生成</p>
<span id="more"></span>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//物理机执行为本地终端</span><br><span class="line">[root@dennis.com ~]$ tty</span><br><span class="line">/dev/tty1</span><br><span class="line"></span><br><span class="line">//通过网路使用模拟终端远程连接Linux, 日常运维中就是这种方式</span><br><span class="line">[root@dennis.com ~]$ tty</span><br><span class="line">/dev/pts/0</span><br></pre></td></tr></table></figure>

<h2 id="Linux系统Bash系统管理"><a href="#Linux系统Bash系统管理" class="headerlink" title="Linux系统Bash系统管理"></a>Linux系统Bash系统管理</h2><p>​                                              <img src="https://img1.baidu.com/it/u=404627178,1930063483&fm=15&fmt=auto&gp=0.jpg" alt="img" style="zoom: 50%;" /></p>
<p>简单的说, Shell是系统的⽤户界⾯，提供了⽤户与内核进⾏交互操作的⼀种接⼝。它接收⽤户输</p>
<p>⼊的命令并把它送⼊内核去执⾏。</p>
<p>​                                                <img src="https://images2017.cnblogs.com/blog/1222491/201801/1222491-20180128195658115-361387611.png" alt="img" style="zoom:50%;" /></p>
<p>实际上Shell是⼀个命令解释器，它解释由⽤户输⼊的命令并且把它们送到内核。</p>
<blockquote>
<p>BASH Shell: 是⼀个为GNU计划编写的Unix shell, 是许多Linux发⾏版的默认Shell</p>
<p>C Shell: 是SUN公司Shell的BSD版本。</p>
<p>Z Shell: 它集成了bash、ksh的重要特性，同时⼜增加了⾃⼰独有的特性。</p>
<p>还有许多传统UNIX上⽤的Shell，例如tcsh、csh、ash、bsh、ksh等, Shell Script⼤致都类</p>
<p>同，当您学会⼀种Shell以后，其它的Shell很快就上⼿, ⼤多数的时候, ⼀个Shell脚本 通常可</p>
<p>以在很多种Shell上使⽤。</p>
</blockquote>
<p>查看当前使用的shell</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@dennis.com ~]$ <span class="built_in">echo</span> <span class="variable">$SHELL</span></span><br><span class="line">/bin/bash</span><br></pre></td></tr></table></figure>

<p>查看 Linux 可⽤的 shell</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@dennis.com ~]$ cat /etc/shells </span><br><span class="line">/bin/sh</span><br><span class="line">/bin/bash</span><br><span class="line">/usr/bin/sh</span><br><span class="line">/usr/bin/bash</span><br><span class="line">/sbin/nologin</span><br></pre></td></tr></table></figure>

<p>Bash Shell 提示符</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$PS1</span></span><br><span class="line">[\[\e[34;1m\]\u@\[\e[0m\]\[\e[32;1m\]\H\[\e[0m\] \[\e[31;1m\]\w\[\e[0m\]]\\$</span><br><span class="line"></span><br><span class="line">[root@dennis.com ~]$ date</span><br><span class="line">Sun Jul 25 21:53:32 CST 2021</span><br></pre></td></tr></table></figure>

<h2 id="基础命令语法结构"><a href="#基础命令语法结构" class="headerlink" title="基础命令语法结构"></a>基础命令语法结构</h2><ul>
<li><p>命令 选型 参数：</p>
<ul>
<li>命令：命令主题功能；</li>
<li>选项：用来调节命令的输出；</li>
<li>参数； 对应要操作的文件或目录。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//等待⽤户输⼊,执⾏命令,	$	=	普通⽤户,	<span class="comment">#	=	root⽤户(超级管理员)</span></span><br><span class="line">[student@desktop0	~]$</span><br><span class="line"></span><br><span class="line">//bash	Shell	执⾏命令</span><br><span class="line">//命令		选项		参数</span><br><span class="line"><span class="built_in">command</span>	[-options]	[arguments]</span><br><span class="line">[root@dennis.com ~]$ ls				<span class="comment">#命令</span></span><br><span class="line">[root@dennis.com ~]$ ls	-a			<span class="comment">#命令+选项</span></span><br><span class="line">[root@dennis.com ~]$ ls	-a	/tmp/	<span class="comment">#命令+选项+参数</span></span><br><span class="line"></span><br><span class="line">命令:	命令的主体</span><br><span class="line">				⼀个命令有多个选项,	多个选项可以合并在⼀起</span><br><span class="line">选项:	⽤于调节命令的具体功能</span><br><span class="line">				以	“-”引导短格式选项（单个字符），例如“-l”</span><br><span class="line">				以“--”引导⻓格式选项（多个字符），例如“--color”</span><br><span class="line">				多个短格式选项可以写在⼀起，只⽤⼀个“-”引导，例如“-al”</span><br><span class="line">参数:	命令操作的对象，如⽂件、⽬录名等</span><br><span class="line"><span class="comment">#	命令必须开头， 选项和参数位置可以发⽣变化</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Bash特性-自带功能"><a href="#Bash特性-自带功能" class="headerlink" title="Bash特性-自带功能"></a>Bash特性-自带功能</h2><ol>
<li><p>命令补全</p>
<ul>
<li>命令补全；</li>
<li>路径补全；</li>
<li><font color='red'>注意</font>: 当tab一下不行,就两下,如果两下不行,就说明路径不对,或输入的命令不对;</li>
</ul>
<p><strong>tab</strong>键以实现命令补全, 路径补全和命令实现⽅式⼀致, ⼯作中我们经常⽤到 tab 补全, 减少执⾏命令以及路径出错率。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//查看ip时忘记具体了命令</span><br><span class="line">[root@dennis.com ~]$ ifcon</span><br><span class="line">//按下tab键会⾃动补全</span><br><span class="line">[root@dennis.com ~]$ ifconfig</span><br><span class="line"></span><br><span class="line">//按⼀下tab键没有反应,	按两下tab键列出所有<span class="keyword">if</span>开头的命令</span><br><span class="line">[root@dennis.com ~]$ <span class="keyword">if</span></span><br><span class="line"><span class="keyword">if</span>         ifcfg      ifconfig   ifdown     ifenslave  ifnames    ifstat     iftop      ifup</span><br><span class="line"></span><br><span class="line">//linux路径较深,	经常使⽤tab键进⾏补全,	如果路径出错是没有办法补全</span><br><span class="line">[root@dennis.com ~]$ ls	/etc/sysconfig/network-scripts/</span><br></pre></td></tr></table></figure></li>
<li><p>快捷键</p>
<p>快捷键可以帮助我们提升工作效率。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Ctrl	+	A				//光标跳转⾄正在输⼊的命令⾏的⾸部</span><br><span class="line">Ctrl	+	E				//光标跳转⾄正在输⼊的命令⾏的尾部</span><br><span class="line">Ctrl	+	C				//终⽌前台运⾏的程序</span><br><span class="line">Ctrl	+	D				//在shell中，ctrl-d表示推出当前shell。</span><br><span class="line">Ctrl	+	Z				//将任务暂停，挂⾄后台</span><br><span class="line">Ctrl	+	L				//清屏，和clear命令等效。</span><br><span class="line">Ctrl	+	K				//删除从光标到⾏末的所有字符</span><br><span class="line">Ctrl	+	U				//删除从光标到⾏⾸的所有字符</span><br><span class="line">Ctrl	+	R				//搜索历史命令,	利⽤关键字</span><br><span class="line">//在命令⾏前加⾯加	<span class="string">&quot;#&quot;</span>	则该命令不会被执⾏</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>让我先来看看linux中常用的一些简单命令：</p>
<h3 id="History命令"><a href="#History命令" class="headerlink" title="History命令"></a>History命令</h3><p>history 查看系统命令历史, 追溯之前发⽣情况</p>
<blockquote>
<p>命令选项</p>
<p>-w 保存命令历史到历史⽂件</p>
<p>-c 清空命令历史记录, 不会清空⽂件</p>
<p>-d 删除命令历史的第 N 条⾏</p>
</blockquote>
<p>history 命令历史相关快捷键</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//使⽤双	!!	可执⾏上⼀条命令</span><br><span class="line">[root@dennis.com ~]$ ls</span><br><span class="line">hello.txt</span><br><span class="line">[root@dennis.com ~]$ !!</span><br><span class="line">ls</span><br><span class="line">hello.txt</span><br><span class="line"></span><br><span class="line">//输⼊!6,	执⾏<span class="built_in">history</span>命令历史中第 6 ⾏命令</span><br><span class="line">[root@dennis.com ~]$ !6</span><br><span class="line">ls</span><br><span class="line">hello.txt</span><br><span class="line"></span><br><span class="line">//使⽤!cat,	调⽤<span class="built_in">history</span>命令历史最近⼀次执⾏过的cat命令</span><br><span class="line">[root@dennis.com ~]$ cat /etc/sysconfig/network-scripts/ifcfg-eth0</span><br><span class="line">[root@dennis.com ~]$ !cat</span><br><span class="line">cat	/etc/sysconfig/network-scripts/ifcfg-eth0</span><br><span class="line"></span><br><span class="line">[root@dennis.com ~]$ ls	/etc/passwd</span><br><span class="line">//调⽤上⼀条命令的最后参数或选项,	按下ESC松开,	然后按下 <span class="string">&quot;.&quot;</span></span><br><span class="line">[root@dennis.com ~]$ cat</span><br><span class="line">[root@dennis.com ~]$ cat	/etc/passwd</span><br><span class="line">//第⼆种⽅式,	输⼊!$</span><br><span class="line">[root@dennis.com ~]$ ls	!$</span><br><span class="line">ls	/etc/passwd</span><br><span class="line">/etc/passwd</span><br></pre></td></tr></table></figure>

<h3 id="Alias命令别名"><a href="#Alias命令别名" class="headerlink" title="Alias命令别名"></a>Alias命令别名</h3><p>命令别名将⽤户经常使⽤的复杂命令简单化, 可以⽤ “alias    别名名称=命令” 命令创建属于⾃⼰的</p>
<p>命令别名, 若要取消⼀个命令别名，则是⽤ unalias    别名名称 命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//1.定义临时别名,	if1为查看eth0⽹卡别名</span><br><span class="line">[root@dennis.com ~]$ <span class="built_in">alias</span> if0=<span class="string">&#x27;ifconfig eth0&#x27;</span></span><br><span class="line">[root@dennis.com ~]$ if0</span><br><span class="line">eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.25.183.186  netmask 255.255.240.0  broadcast 172.25.191.255</span><br><span class="line"></span><br><span class="line">//如果定义命令本身,	会执⾏什么?</span><br><span class="line">[root@dennis.com ~]$ <span class="built_in">alias</span>	ifconfig=<span class="string">&#x27;ifconfig	eth0&#x27;</span></span><br><span class="line">//绝对路径执⾏,	调⽤命令本身</span><br><span class="line">[root@dennis.com ~]$ /sbin/ifconfig</span><br><span class="line">//通过\转义字符,	调⽤命令本身</span><br><span class="line">[root@dennis.com ~]$ \ifconfig</span><br><span class="line"></span><br><span class="line">//2.定义系统永久⽣效别名,	将命令别名添加⾄当前⽤户环境配置⽂件</span><br><span class="line">[root@dennis.com ~]$ <span class="built_in">echo</span> <span class="string">&quot;alias ifconfig=&#x27;ifconfig	eth0&#x27;&quot;</span>	&gt;&gt;	~/.bashrc</span><br><span class="line"></span><br><span class="line">//3.取消临时别名</span><br><span class="line">[root@dennis.com ~]$ <span class="built_in">unalias</span> ifconfig	</span><br></pre></td></tr></table></figure>

<h2 id="Bash特性-命令流程"><a href="#Bash特性-命令流程" class="headerlink" title="Bash特性:命令流程"></a>Bash特性:命令流程</h2><p>当我们执⾏⼀个命令, 整个命令执⾏流程如下:</p>
<ol>
<li><p>判断命令是否通过绝对路径执⾏</p>
</li>
<li><p>判断命令是否存在别名</p>
</li>
<li><p>判断⽤户输⼊的是内部命令还是外部命令</p>
</li>
<li><p>内部命令直接执⾏, 外部命令检测是否存在缓存</p>
</li>
<li><p>检测 PATH 路径, 有执⾏, ⽆报错</p>
</li>
</ol>
<blockquote>
<p>内部命令: shell程序⾃带的命令。</p>
<p>外部命令: 在系统PATH变量的某个路径下的可执⾏程序。</p>
</blockquote>
<p>使⽤ type 命令检测⽤户输⼊的命令属于内部命令还是外部命令&gt;。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//<span class="built_in">cd</span>命令属于shell内部命令</span><br><span class="line">[root@dennis.com ~]$ <span class="built_in">type</span> -a <span class="built_in">cd</span></span><br><span class="line"><span class="built_in">cd</span> is a shell <span class="built_in">builtin</span></span><br><span class="line"><span class="built_in">cd</span> is /usr/bin/<span class="built_in">cd</span></span><br><span class="line"></span><br><span class="line">//ping属于外部命令,	同时会打印当前命令路径</span><br><span class="line">[root@dennis.com ~]$ <span class="built_in">type</span> -a ping</span><br><span class="line">ping is /usr/bin/ping</span><br></pre></td></tr></table></figure>

<p>PATH 变量定义的路径, 作⽤是告诉 Bash 执⾏的外部命令存放的位置， Bash 会在这些路径中进⾏逐个扫描</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//<span class="built_in">echo</span>所⻅即所得</span><br><span class="line">[root@dennis.com ~]$ <span class="built_in">echo</span> <span class="string">&quot;123&quot;</span></span><br><span class="line">123</span><br><span class="line">[root@dennis.com ~]$ <span class="built_in">echo</span> -e <span class="string">&quot;123 \n456&quot;</span></span><br><span class="line">123 </span><br><span class="line">456</span><br><span class="line"></span><br><span class="line">//打印当前环境变量⽬录</span><br><span class="line">[root@dennis.com ~]$ <span class="built_in">echo</span> <span class="variable">$PATH</span></span><br><span class="line">/app/node/bin:/usr/<span class="built_in">local</span>/sbin:/usr/<span class="built_in">local</span>/bin:/usr/sbin:/usr/bin:/root/bin</span><br><span class="line"></span><br><span class="line">//PATH由多个路径组成，每个路径值之间⽤冒号间隔，对这些路径的增加和删除操作都将影响到Bash解释器对Linux命令的查找。</span><br><span class="line"></span><br><span class="line">//修改PATH变量</span><br><span class="line">[root@dennis.com ~]$ PATH=/soft/bin:<span class="variable">$PATH</span></span><br><span class="line">//写⼊/etc/profile配置⽂件永久⽣效</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export	PATH=/soft/bin:$PATH&#x27;</span>	&gt;&gt;	/etc/profile</span><br></pre></td></tr></table></figure>

<p>事实上执⾏过的外部命令都会保存在内存缓存中, 当再次执⾏相同的命令, 会通过缓存调取执⾏,也就意味着不会搜索 PATH 路径。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@dennis.com ~]$ <span class="built_in">hash</span></span><br><span class="line">hits	<span class="built_in">command</span></span><br><span class="line">   1	/usr/sbin/ifconfig</span><br><span class="line">   2	/usr/bin/cat</span><br><span class="line">   </span><br><span class="line">//已缓存命令,如果移动位置会导致⽆法找到该命令</span><br><span class="line">[root@dennis.com ~]$	mv	/sbin/ifconfig	/bin/</span><br><span class="line">[root@dennis.com ~]$	ifconfig</span><br><span class="line">-bash:	/sbin/ifconfig:	No	such	file	or	</span><br><span class="line"></span><br><span class="line">//删除缓存过的ifconfig命令,	即可执⾏[root@xuliangwei	~]<span class="comment">#	hash	-d	ifconfig</span></span><br><span class="line">[root@dennis.com ~]$ ifconfig</span><br><span class="line"></span><br><span class="line">//当然可以清空缓存表</span><br><span class="line">[root@dennis.com ~]$ <span class="built_in">hash</span> -r</span><br><span class="line">[root@dennis.com ~]$ <span class="built_in">hash</span> -d ifconfig</span><br><span class="line">[root@dennis.com ~]$ ifconfig</span><br><span class="line"></span><br><span class="line">//当然可以清空缓存表</span><br><span class="line">[root@dennis.com ~]$ <span class="built_in">hash</span> -r</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//命令缓存<span class="built_in">hash</span>需要注意如下情况:</span><br><span class="line">1.如果执⾏外部命令1次就会对该命令进⾏缓存</span><br><span class="line">2.如果将命令移动了位置</span><br><span class="line">				a.使⽤绝对路径执⾏</span><br><span class="line">				b.删除<span class="built_in">hash</span>表的缓存指令</span><br></pre></td></tr></table></figure>

<p>总结, 当我们执⾏了⼀个 ping 命令之后, 整个命令执⾏的流程步骤如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1.检查执⾏的是否是绝对路径执⾏</span><br><span class="line">2.检查该ping命令是否存在别名</span><br><span class="line">3.检查该ping命令是内部命令还是外部命令</span><br><span class="line">4.如果是内部指令直接执⾏, 如果是外部命令</span><br><span class="line">5.检测该命令是否有缓存,如果没有,查找PATH变量</span><br><span class="line">6.检查PATH路径直到查找到该命令然后执⾏</span><br><span class="line">7.如果没有找到该命令则返回错误。<span class="built_in">command</span> not found</span><br></pre></td></tr></table></figure>

<h2 id="Bash特性：路径展开"><a href="#Bash特性：路径展开" class="headerlink" title="Bash特性：路径展开"></a>Bash特性：路径展开</h2><p>Linux    Shell 下路径展开⽤花括号包括, 逗号分隔, 这样花括号⾥的内容会被展开形成列表。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@dennis.com ~]$ mkdir /tmp/zz/a/b /tmp/a/b -pv</span><br><span class="line">mkdir: created directory ‘/tmp/zz’</span><br><span class="line">mkdir: created directory ‘/tmp/zz/a’</span><br><span class="line">mkdir: created directory ‘/tmp/zz/a/b’</span><br><span class="line">mkdir: created directory ‘/tmp/a’</span><br><span class="line">mkdir: created directory ‘/tmp/a/b’</span><br><span class="line"></span><br><span class="line">//删除⽬录</span><br><span class="line">[root@dennis.com ~]$	rm	-rf	/tmp/&#123;zz,yy&#125;</span><br><span class="line">//通过路径展开⽅式创建⽬录</span><br><span class="line">[root@dennis.com ~]$	mkdir	/tmp/&#123;zz,yy&#125;/a/b	-pv</span><br><span class="line">mkdir:	created	directory	`/tmp/zz<span class="string">&#x27;</span></span><br><span class="line"><span class="string">mkdir:	created	directory	`/tmp/zz/a&#x27;</span></span><br><span class="line">mkdir:	created	directory	`/tmp/zz/a/b<span class="string">&#x27;</span></span><br><span class="line"><span class="string">mkdir:	created	directory	`/tmp/yy</span></span><br></pre></td></tr></table></figure>

<h2 id="Bash特性：转义字符"><a href="#Bash特性：转义字符" class="headerlink" title="Bash特性：转义字符"></a>Bash特性：转义字符</h2><p>Shell解释器提供了⾮常丰富的转义字符, 来实现字符处理以及命令替换。</p>
<p><font color='purple'><strong>四类常用转义字符</strong></font>：</p>
<ul>
<li>反斜杠（\）：使反斜杠后⾯的⼀个变量变为字符串。</li>
<li>单引号（’’）：转义其中所有的变量为单纯的字符串。</li>
<li>双引号（””）：保留其中的变量属性，不进⾏转义处理。</li>
<li>反引号（``）：把其中的命令执⾏后返回结果。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@dennis.com /]$ <span class="built_in">echo</span> <span class="string">&quot;shoping is <span class="variable">$500</span>&quot;</span></span><br><span class="line">shoping is 00</span><br><span class="line">[root@dennis.com /]$ <span class="built_in">echo</span> <span class="string">&quot;shoping is \$500&quot;</span></span><br><span class="line">shoping is <span class="variable">$500</span></span><br><span class="line"></span><br><span class="line">//转义其中特殊字符为普通字符串</span><br><span class="line">[root@dennis.com /]$ <span class="built_in">echo</span> <span class="string">&#x27;shoping is $500&#x27;</span></span><br><span class="line">shoping is <span class="variable">$500</span></span><br><span class="line"></span><br><span class="line">//使⽤$()实现命令替换</span><br><span class="line">[root@dennis.com ~]$ <span class="built_in">echo</span> <span class="string">&quot;The Directory is <span class="subst">$(pwd)</span>&quot;</span></span><br><span class="line">The Directory is /root</span><br><span class="line"></span><br><span class="line">//使⽤``实现命令替换</span><br><span class="line">[root@dennis.com ~]$ <span class="built_in">echo</span> <span class="string">&quot;The Directory is `pwd`&quot;</span></span><br><span class="line">The	Directory is /root</span><br><span class="line"></span><br><span class="line">//转义其中所有的变量为单纯的字符串</span><br><span class="line"></span><br><span class="line">[root@dennis.com ~]$ touch file-`date +%F-%H-%S`</span><br><span class="line">[root@dennis.com ~]$ ls</span><br><span class="line">file-2021-03-26-09-47</span><br><span class="line"></span><br><span class="line">[root@dennis.com ~]$ touch <span class="string">&#x27;file-`date +%F-%H-%S`&#x27;</span></span><br><span class="line">[root@dennis.com ~]$ ls</span><br><span class="line">file-2021-07-26-09-47  file-`date +%F-%H-%S`</span><br></pre></td></tr></table></figure>

<p>Bash特性：获取帮助</p>
<p>1.通过man命令获取帮助</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">⼿册的常⻅级别:	1(普通⽤户命令⼿册)	,	5(配置⽂件⼿册),	8(管理员命令⼿册) g	:	回到⼿册的顶部</span><br><span class="line">G	:	去到⽂档的底部</span><br><span class="line">/	:	输⼊要搜索的关键字,进⾏⽂档搜索</span><br><span class="line">q:	退出⽂档</span><br><span class="line">回⻋:	往下滚动⼀⾏</span><br><span class="line">空格键:	往下翻⼀⻚</span><br><span class="line">man	-a	passwd</span><br><span class="line">man		5	passwd</span><br><span class="line">man		1	passwd</span><br><span class="line">man	-k	passw		找到所有的包含passwd关键字的⼿册并且列出来</span><br></pre></td></tr></table></figure>

<p>2.通过 info 或 pinfo 获得帮助</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">⾸⻚寻找Textinfo⽂档,如果没有,强制打开对应的Man⽂档</span><br><span class="line">				与vi⻛格类似,快捷键:</span><br><span class="line">								空格:翻⻚</span><br><span class="line">								HOME:	返回⻚⾯顶部</span><br><span class="line">								END:返回⻚⾯底部</span><br><span class="line">								上箭头:	光标上移动⼀⾏</span><br><span class="line">								下箭头:	光标下移动以⾏</span><br><span class="line">								左箭头:	返回上⼀章节</span><br><span class="line">								右箭头:	浏览光标所在章节</span><br><span class="line">								d:	回到⼿册⾸⻚</span><br><span class="line">								q:	退出⼿册</span><br><span class="line">				</span><br><span class="line">强制打开指定级别的man⽂档</span><br><span class="line">$	pinfo	-m	5	passwd</span><br></pre></td></tr></table></figure>













































<script src='https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/mouse_snow.min.js'></script>

]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
      <tags>
        <tag>Bash</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux系统压缩打包</title>
    <url>/Linux%E5%9F%BA%E7%A1%80/Linux%E7%B3%BB%E7%BB%9F%E5%8E%8B%E7%BC%A9%E6%89%93%E5%8C%85/</url>
    <content><![CDATA[<p><code>windows</code> 下我们接触最多的压缩⽂件就是 .rar 格式, 但 Linux 有⾃⼰所特有的压缩⼯具。如果希望<code>windows</code>和<code>Linux</code>互相能使⽤的压缩⼯具, 建议 .zip 格式。</p>
<p>压缩的好处主要有：</p>
<ul>
<li>节省磁盘空间占用率</li>
<li>节省网络传输带宽的消耗</li>
<li>网络传输更加快捷</li>
</ul>
<h2 id="tar命令"><a href="#tar命令" class="headerlink" title="tar命令"></a>tar命令</h2><p>在 Linux 操作系统中默认自带两个原始的压缩工具分别是 <code>gzip</code> 和 <code>bzip2</code>, 但是它们都有先天的缺陷，<font color='orange'>不能打包压缩文件, 每个文件都会生成一个单独的压缩包</font>, 并且压缩之后不会保留原文件， 这是一件叔能忍婶也不能忍的事情。</p>
<p>Linux 中自带一个打包工具，叫做 <code>tar</code>, 默认情况下该工具是不能进行压缩操作的，在这种情况下 <code>tar</code> 和 <code>gzip</code>, <code>bzip2</code> 就联姻了，各自发挥各自的优势，Linux 下最强大的打包压缩工具至此诞生。</p>
<p>我们在使用 tar 进行压缩和解压缩的时候，只需要指定相对用的参数，在其内部就会调用对应的压缩工具 <code>gzip</code> 或者 <code>bzip2</code> 完成指定的操作。</p>
<h3 id="压缩-tar-gz-tar-bz2-tgz"><a href="#压缩-tar-gz-tar-bz2-tgz" class="headerlink" title="压缩 (.tar.gz .tar.bz2 .tgz)"></a>压缩 (.tar.gz .tar.bz2 .tgz)</h3><blockquote>
<p>如果使用 <code>tar</code> 完成文件压缩，涉及的参数如下，在使用过程中参数没有先后顺序:</p>
</blockquote>
<ul>
<li><code>c</code>: 创建压缩文件</li>
<li><code>z</code>: 使用 <code>gzip</code> 的方式进行文件压缩</li>
<li><code>j</code>: 使用 <code>bzip2</code> 的方式进行文件压缩</li>
<li><code>v</code>: 压缩过程中显示压缩信息，可以省略不写</li>
<li><code>f</code>: 指定压缩包的名字</li>
</ul>
<blockquote>
<p>一般认为 <code>.tgz</code> 文件就等同于 <code>.tar.gz</code> 文件，因此它们的压缩方式是相同的。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 语法: </span></span><br><span class="line">$ tar 参数 生成的压缩包的名字 要压缩的文件(文件或者目录)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 备注: 关于生成的压缩包的名字, 建议使用标准后缀, 方便识别:</span></span><br><span class="line">	- 压缩使用 gzip 方式,  标准后缀格式为: .tar.gz</span><br><span class="line">	- 压缩使用 bzip2 方式, 标准后缀格式为: .tar.bz2	</span><br></pre></td></tr></table></figure>

<blockquote>
<p>举例：使用 <code>gzip</code> 的方式进行文件压缩</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看目录内容</span></span><br><span class="line">[root@VM-8-14-centos ~/luffy]<span class="comment"># ls</span></span><br><span class="line">get  onepiece.txt  robin.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 压缩目录中所有文件, 如果要压缩某几个文件, 直接指定文件名即可</span></span><br><span class="line">[root@VM-8-14-centos ~/luffy]<span class="comment"># tar zcvf all.tar.gz *</span></span><br><span class="line">get/                     <span class="comment"># ....... 压缩信息</span></span><br><span class="line">get/link.lnk             <span class="comment"># ....... 压缩信息</span></span><br><span class="line">get/onepiece/            <span class="comment"># ....... 压缩信息</span></span><br><span class="line">get/onepiece/haha.txt</span><br><span class="line">get/link.txt</span><br><span class="line">onepiece.txt</span><br><span class="line">robin.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看目录文件, 多了一个压缩文件 all.tar.gz</span></span><br><span class="line">[root@VM-8-14-centos ~/luffy]<span class="comment"># ls</span></span><br><span class="line">all.tar.gz  get  onepiece.txt  robin.txt</span><br></pre></td></tr></table></figure>

<blockquote>
<p>举例：使用 <code>bzip2</code> 的方式进行文件压缩</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看目录内容</span></span><br><span class="line">[root@VM-8-14-centos ~/luffy]<span class="comment"># ls</span></span><br><span class="line">all.tar.gz  get  onepiece.txt  robin.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 压缩目录中除 all.tar.gz 的文件和目录</span></span><br><span class="line">[root@VM-8-14-centos ~/luffy]<span class="comment"># tar jcvf part.tar.bz2 get onepiece.txt robin.txt </span></span><br><span class="line">get/                   <span class="comment"># ....... 压缩信息</span></span><br><span class="line">get/link.lnk           <span class="comment"># ....... 压缩信息</span></span><br><span class="line">get/onepiece/          <span class="comment"># ....... 压缩信息</span></span><br><span class="line">get/onepiece/haha.txt</span><br><span class="line">get/link.txt</span><br><span class="line">onepiece.txt</span><br><span class="line">robin.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看目录信息, 多了一个压缩文件 part.tar.bz2</span></span><br><span class="line">[root@VM-8-14-centos ~/luffy]<span class="comment"># ls</span></span><br><span class="line">all.tar.gz  get  onepiece.txt  part.tar.bz2  robin.txt</span><br></pre></td></tr></table></figure>

<h2 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h2><blockquote>
<p><code>zip</code> 格式的压缩包在 Linux 中也是很常见的，在某些版本中需要安装才能使用</p>
</blockquote>
<ul>
<li><p>Ubuntu</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt install zip    	<span class="comment"># 压缩</span></span><br><span class="line">$ sudo apt install unzip	<span class="comment"># 解压缩</span></span><br></pre></td></tr></table></figure></li>
<li><p>CentOS</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 因为 centos 可以使用 root 用户登录, 基于 root 用户安装软件, 不需要加 sudo</span></span><br><span class="line">$ sudo yum install zip    	<span class="comment"># 压缩</span></span><br><span class="line">$ sudo yum install unzip	<span class="comment"># 解压缩</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>压缩(.zip)</p>
<blockquote>
<p>用 <code>zip</code> 压缩目录需要注意一点，必须要添加参数 -r, 这样才能将子目录中的文件一并压缩，如果要压缩的文件中没有目录，该参数就可以不写了。</p>
<p>另外使用 <code>zip</code> 压缩文件，会自动生成文件后缀.zip, 因此就不需要额外指定了。</p>
</blockquote>
<blockquote>
<p>举例：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看目录文件信息</span></span><br><span class="line">[root@VM-8-14-centos ~/luffy]<span class="comment"># ls</span></span><br><span class="line">get  onepiece.txt  robin.txt  temp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 压缩目录 get 和文件 onepiece.txt robin.txt 得到压缩包 all.zip(不需要指定后缀, 自动添加)</span></span><br><span class="line">[root@VM-8-14-centos ~/luffy]<span class="comment"># zip all onepiece.txt robin.txt get/ -r</span></span><br><span class="line">  adding: onepiece.txt (stored 0%)</span><br><span class="line">  adding: robin.txt (stored 0%)</span><br><span class="line">  adding: get/ (stored 0%)</span><br><span class="line">  adding: get/link.lnk (stored 0%)             <span class="comment"># 子目录中的文件也被压缩进去了</span></span><br><span class="line">  adding: get/onepiece/ (stored 0%)            <span class="comment"># 子目录中的文件也被压缩进去了</span></span><br><span class="line">  adding: get/onepiece/haha.txt (stored 0%)    <span class="comment"># 子目录中的文件也被压缩进去了</span></span><br><span class="line">  adding: get/link.txt (stored 0%)             <span class="comment"># 子目录中的文件也被压缩进去了</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 查看目录文件信息, 多了一个压缩包文件 all.zip</span></span><br><span class="line">[root@VM-8-14-centos ~/luffy]<span class="comment"># ls</span></span><br><span class="line">all.zip  get  onepiece.txt  robin.txt  temp</span><br></pre></td></tr></table></figure>

<p>解压缩（.zip）</p>
<blockquote>
<p>对应 zip 格式的文件解压缩，必须要使用 unzip 命令，和压缩的时候使用的命令是不一样的。如果压缩包中的文件要解压到指定目录需要指定参数 -d, 默认是解压缩到当前目录中。<font color='orange'><strong>unzip也可以解压java程序的war包。</strong></font></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 语法1: 解压到当前目录中 </span></span><br><span class="line">$ unzip 压缩包名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 语法: 解压到指定目录, 需要添加参数 -d</span></span><br><span class="line">$ unzip 压缩包名 -d 解压目录</span><br></pre></td></tr></table></figure>

<blockquote>
<p>举例：</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看目录文件信息</span></span><br><span class="line">[root@VM-8-14-centos ~/luffy]# ls</span><br><span class="line">all.zip  get  onepiece.txt  robin.txt  temp</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除 temp 目录中的所有文件</span></span><br><span class="line">[root@VM-8-14-centos ~/luffy]# rm temp/* -rf</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将 all.zip 解压缩到 temp 目录中</span></span><br><span class="line">[root@VM-8-14-centos ~/luffy]# unzip all.zip -d temp/</span><br><span class="line">Archive:  all.zip</span><br><span class="line"> extracting: temp/onepiece.txt           # 释放压缩的子目录中的文件            </span><br><span class="line"> extracting: temp/robin.txt              # 释放压缩的子目录中的文件            </span><br><span class="line">   creating: temp/get/</span><br><span class="line"> extracting: temp/get/link.lnk       </span><br><span class="line">   creating: temp/get/onepiece/</span><br><span class="line"> extracting: temp/get/onepiece/haha.txt  # 释放压缩的子目录中的文件</span><br><span class="line"> extracting: temp/get/link.txt      </span><br><span class="line"><span class="meta"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 temp 目录中的文件信息</span> </span><br><span class="line">[root@VM-8-14-centos ~/luffy]# ls temp/</span><br><span class="line">get  onepiece.txt  robin.txt</span><br></pre></td></tr></table></figure>

<h2 id="rar"><a href="#rar" class="headerlink" title="rar"></a>rar</h2><blockquote>
<p><code>rar</code> 这种压缩格式在 Linux 中并不常用，这是 Windows 常用的压缩格式，如果想要在 Linux 压缩和解压这种格式的文件需要额外安装对应的工具，不同版本的 Linux 安装方式也是不同的。</p>
</blockquote>
<ul>
<li><p>Ubuntu</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行在线下载命令即可</span></span><br><span class="line">$ sudo apt install rar</span><br></pre></td></tr></table></figure></li>
<li><p>CentOS</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 需要下载安装包, 官方地址: https://www.rarlab.com/download.htm</span></span><br><span class="line"><span class="comment"># 从下载页面找到 Linux 版本的下载链接并复制链接地址, 使用 wget 下载到本地</span></span><br><span class="line">$ wget https://www.rarlab.com/rar/rarlinux-x64-6.0.0.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将下载得到的 rarlinux-x64-6.0.0.tar.gz 压缩包解压缩, 得到解压目录 rar</span></span><br><span class="line">$ tar zxvf rarlinux-x64-6.0.0.tar.gz </span><br><span class="line"></span><br><span class="line"><span class="comment"># 将得到的解压目录移动到 /opt 目录中 (因为/opt软件安装目录, 移动是为了方便管理, 不移动也没事儿)</span></span><br><span class="line"><span class="comment"># 该操作需要管理员权限, 我是使用 root 用户操作的</span></span><br><span class="line">$ mv ./rar /opt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给 /opt/rar 目录中的可执行程序添加软连接, 方便命令解析器可以找到该压缩命令</span></span><br><span class="line">$ ln -s /opt/rar/rar /usr/<span class="built_in">local</span>/bin/rar</span><br><span class="line">$ ln -s /opt/rar/unrar /usr/<span class="built_in">local</span>/bin/unrar</span><br></pre></td></tr></table></figure>

<table><tr><td bgcolor=Beige>该方法在任何版本的 Linux 系统中都适用</td></tr></table></li>
</ul>
<h3 id="压缩（-rar）"><a href="#压缩（-rar）" class="headerlink" title="压缩（.rar）"></a>压缩（.rar）</h3><blockquote>
<p>使用 <code>rar</code> 压缩过程中的注意事项和 <code>zip</code> 是一样的，<code>如果压缩的是目录, 需要指定参 -r</code>, 如果只压缩文件就不需要添加了。压缩过程中需要使用参数 <code>a (archive)</code>, 压缩归档的意思。</p>
<p><code>rar</code> 工具在生成压缩包的时候也会自动添加后缀，名字为<code>.rar</code>, 因此我们只需要指定压缩包的名字。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 文件压缩, 需要使用参数 a, 压缩包名会自动添加后缀 .rar</span></span><br><span class="line"><span class="comment"># 如果压缩了目录, 需要加参数 -r</span></span><br><span class="line"><span class="comment"># 语法: </span></span><br><span class="line">$ rar a 压缩包名 要压缩的文件 [-r]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 举例</span></span><br><span class="line"><span class="comment"># 查看目录文件信息</span></span><br><span class="line">[root@VM-8-14-centos ~/luffy]<span class="comment"># ls</span></span><br><span class="line">get  onepiece.txt  robin.txt  temp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 压缩文件 onepiece.txt, robin.txt 和目录 get/ 到要是文件 all.rar 中</span></span><br><span class="line">[root@VM-8-14-centos ~/luffy]<span class="comment"># rar a all onepiece.txt get/ robin.txt -r </span></span><br><span class="line"></span><br><span class="line">RAR 6.00   Copyright (c) 1993-2020 Alexander Roshal   1 Dec 2020</span><br><span class="line">Trial version             Type <span class="string">&#x27;rar -?&#x27;</span> <span class="keyword">for</span> <span class="built_in">help</span></span><br><span class="line"></span><br><span class="line">Evaluation copy. Please register.</span><br><span class="line"></span><br><span class="line">Creating archive all.rar</span><br><span class="line"></span><br><span class="line">Adding    onepiece.txt                     OK </span><br><span class="line">Adding    get/link.lnk                     OK        <span class="comment"># 子目录中的文件也被压缩了 </span></span><br><span class="line">Adding    get/onepiece/haha.txt            OK        <span class="comment"># 子目录中的文件也被压缩了</span></span><br><span class="line">Adding    get/link.txt                     OK        <span class="comment"># 子目录中的文件也被压缩了  </span></span><br><span class="line">Adding    robin.txt                        OK </span><br><span class="line">Adding    get/onepiece                     OK         </span><br><span class="line">Done</span><br><span class="line">[root@VM-8-14-centos ~/luffy]<span class="comment"># ls</span></span><br><span class="line">all.rar  get  onepiece.txt  robin.txt  temp</span><br></pre></td></tr></table></figure>

<h3 id="解压缩（-rar）"><a href="#解压缩（-rar）" class="headerlink" title="解压缩（.rar）"></a>解压缩（.rar）</h3><blockquote>
<p>解压缩.rar 格式的文件的时候，可以使用 rar 也可以使用 unrar, 操作方式是一样的，需要添加参数 x, 默认是将压缩包内容释放到当前目录中，如果要释放到指定目录直接指定解压目录名即可，不需要使用任何参数。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 解压缩: 需要参数 x</span></span><br><span class="line"><span class="comment"># 语法: 解压缩到当前目录中</span></span><br><span class="line">$ rar/unrar x 压缩包名字</span><br><span class="line"></span><br><span class="line"><span class="comment"># 语法: 解压缩到指定目录中</span></span><br><span class="line">rar/unrar x 压缩包名字 解压目录</span><br></pre></td></tr></table></figure>

<blockquote>
<p>举例：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看目录文件信息</span></span><br><span class="line">[root@VM-8-14-centos ~/luffy]<span class="comment"># ls</span></span><br><span class="line">all.rar  get  onepiece.txt  robin.txt  temp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除 temp 目录中的所有文件</span></span><br><span class="line">[root@VM-8-14-centos ~/luffy]<span class="comment"># rm temp/* -rf</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 all.rar 中的文件解压缩到 temp 目录中</span></span><br><span class="line">[root@VM-8-14-centos ~/luffy]<span class="comment"># rar x all.rar temp/ </span></span><br><span class="line"></span><br><span class="line">RAR 6.00   Copyright (c) 1993-2020 Alexander Roshal   1 Dec 2020</span><br><span class="line">Trial version             Type <span class="string">&#x27;rar -?&#x27;</span> <span class="keyword">for</span> <span class="built_in">help</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Extracting from all.rar</span><br><span class="line"></span><br><span class="line">Extracting  temp/onepiece.txt               OK </span><br><span class="line">Creating    temp/get                        OK</span><br><span class="line">Extracting  temp/get/link.lnk               OK          <span class="comment"># 子目录文件也被释放出来了</span></span><br><span class="line">Extracting  temp/get/link.lnk               OK          <span class="comment"># 子目录文件也被释放出来了</span></span><br><span class="line">Extracting  temp/get/link.lnk               OK          <span class="comment"># 子目录文件也被释放出来了</span></span><br><span class="line">Creating    temp/get/onepiece               OK                    </span><br><span class="line">Extracting  temp/get/link.lnk               OK          <span class="comment"># 子目录文件也被释放出来了 </span></span><br><span class="line">Extracting  temp/get/link.lnk               OK          <span class="comment"># 子目录文件也被释放出来了 </span></span><br><span class="line">Extracting  temp/get/onepiece/haha.txt      OK</span><br><span class="line">Extracting  temp/get/link.txt               OK </span><br><span class="line">Extracting  temp/robin.txt                  OK </span><br><span class="line">All OK</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 temp 目录中文件信息</span></span><br><span class="line">[root@VM-8-14-centos ~/luffy]<span class="comment"># ls temp/</span></span><br><span class="line">get  onepiece.txt  robin.txt</span><br></pre></td></tr></table></figure>

<h2 id="xz"><a href="#xz" class="headerlink" title="xz"></a>xz</h2><blockquote>
<p>.xz 格式的文件压缩和解压缩都相对比较麻烦，通过一个命令是完不成对应的操作的，需要通过两步操作才行。并且操作过程中需要使用 tar 工具进行打包，压缩使用的则是 xz 工具。</p>
</blockquote>
<h3 id="压缩（-tar-xz）"><a href="#压缩（-tar-xz）" class="headerlink" title="压缩（.tar.xz）"></a>压缩（.tar.xz）</h3><blockquote>
<p>创建文件的步骤如下，首先 将需要压缩的文件打包 tar cvf xxx.tar files, 然后再对打包文件进行压缩 xz -z xxx.tar, 这样我们就可以得到一个打包之后的压缩文件了。</p>
<p>使用 xz 工具压缩文件的时候需要添加参数 -z</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 语法:</span></span><br><span class="line"><span class="comment"># 第一步</span></span><br><span class="line">$ tar cvf xxx.tar 要压缩的文件</span><br><span class="line"><span class="comment"># 第二步, 最终得到一个xxx.tar.xz 格式的压缩文件</span></span><br><span class="line">$ xz -z xxx.tar</span><br></pre></td></tr></table></figure>

<blockquote>
<p>举例：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看目录文件信息</span></span><br><span class="line">[root@VM-8-14-centos ~/luffy]<span class="comment"># ls</span></span><br><span class="line">get  onepiece.txt  robin.txt  temp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将文件 onepiece.txt, robin.txt 和目录 get 打包到 all.tar 中</span></span><br><span class="line">[root@VM-8-14-centos ~/luffy]<span class="comment"># tar cvf all.tar onepiece.txt robin.txt get/</span></span><br><span class="line">onepiece.txt</span><br><span class="line">robin.txt</span><br><span class="line">get/</span><br><span class="line">get/link.lnk</span><br><span class="line">get/onepiece/</span><br><span class="line">get/onepiece/haha.txt</span><br><span class="line">get/link.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看目录文件信息, 多了一个打包文件 all.tar</span></span><br><span class="line">[root@VM-8-14-centos ~/luffy]<span class="comment"># ls</span></span><br><span class="line">all.tar  get  onepiece.txt  robin.txt  temp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 xz 工具压缩打包文件 all.tar</span></span><br><span class="line">[root@VM-8-14-centos ~/luffy]<span class="comment"># xz -z all.tar </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 最终得到了压缩之后的打包文件 all.tar.xz</span></span><br><span class="line">[root@VM-8-14-centos ~/luffy]<span class="comment"># ls</span></span><br><span class="line">all.tar.xz  get  onepiece.txt  robin.txt  temp</span><br></pre></td></tr></table></figure>

<h3 id="解压缩（tar-xz）"><a href="#解压缩（tar-xz）" class="headerlink" title="解压缩（tar.xz）"></a>解压缩（tar.xz）</h3><blockquote>
<p>解压缩的步骤和压缩的步骤相反，需要先解压缩，然后将文件包中的文件释放出来。</p>
<p>使用 xz 工具解压需要使用参数 -d</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 语法:</span></span><br><span class="line"><span class="comment"># 第一步： 压缩包解压缩, 得到 xxx.tar</span></span><br><span class="line">$ xz -d xxx.tar.xz</span><br><span class="line"><span class="comment"># 第二步: 将 xxx.tar 中的文件释放到当前目录</span></span><br><span class="line">$ tar xvf xxx.tar 			</span><br></pre></td></tr></table></figure>

<blockquote>
<p>举例：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看目录中文件信息, 有一个 all.tar.xz</span></span><br><span class="line">[root@VM-8-14-centos ~/luffy]<span class="comment"># ls</span></span><br><span class="line">all.tar.xz  get  onepiece.txt  robin.txt  temp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 all.tar.xz 解压缩, 得到 all.tar</span></span><br><span class="line">[root@VM-8-14-centos ~/luffy]<span class="comment"># xz -d all.tar.xz </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看目录文件, 得到了 all.tar</span></span><br><span class="line">[root@VM-8-14-centos ~/luffy]<span class="comment"># ls</span></span><br><span class="line">all.tar  get  onepiece.txt  robin.txt  temp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 释放 all.tar 到当前目录</span></span><br><span class="line">[root@VM-8-14-centos ~/luffy]<span class="comment"># tar xvf all.tar </span></span><br><span class="line">onepiece.txt</span><br><span class="line">robin.txt</span><br><span class="line">get/</span><br><span class="line">get/link.lnk</span><br><span class="line">get/onepiece/</span><br><span class="line">get/onepiece/haha.txt</span><br><span class="line">get/link.txt</span><br></pre></td></tr></table></figure>

<script src='https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/mouse_snow.min.js'></script>

]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
      <tags>
        <tag>压缩</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux系统管理</title>
    <url>/Linux%E5%9F%BA%E7%A1%80/Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="系统调试"><a href="#系统调试" class="headerlink" title="系统调试"></a>系统调试</h1><span id="more"></span>
<h2 id="1-linux开机启动流程"><a href="#1-linux开机启动流程" class="headerlink" title="1. linux开机启动流程"></a>1. linux开机启动流程</h2><h3 id="1-1-centos6开机启动流程"><a href="#1-1-centos6开机启动流程" class="headerlink" title="1.1 centos6开机启动流程"></a>1.1 centos6开机启动流程</h3><p>linux启动时我们会看到许多启动信息。</p>
<p>Linux系统的启动过程并不是大家想象中的那么复杂，其过程可以分为5个阶段：</p>
<ul>
<li>内核的引导。</li>
<li>运行 init。</li>
<li>系统初始化。</li>
<li>建立终端 。</li>
<li>用户登录系统。</li>
</ul>
<p>init程序的类型：</p>
<ul>
<li><strong>SysV:</strong> init, CentOS 5之前, 配置文件： /etc/inittab。</li>
<li><strong>Upstart:</strong> init,CentOS 6, 配置文件： /etc/inittab, /etc/init/*.conf。</li>
<li><strong>Systemd：</strong> systemd, CentOS 7,配置文件： /usr/lib/systemd/system、 /etc/systemd/system。</li>
</ul>
<hr>
<h4 id="1-内核引导"><a href="#1-内核引导" class="headerlink" title="1. 内核引导"></a>1. 内核引导</h4><p> 当计算机打开电源后，首先是BIOS开机自检，按照BIOS中设置的启动设备（通常是硬盘）来启动。</p>
<p>操作系统接管硬件以后，首先读入 /boot 目录下的内核文件。</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2014/06/bg2013081702.png" alt="img"></p>
<h4 id="2-运行init"><a href="#2-运行init" class="headerlink" title="2. 运行init"></a>2. 运行init</h4><p>init 进程是系统所有进程的起点，你可以把它比拟成系统所有进程的老祖宗，没有这个进程，系统中任何进程都不会启动。</p>
<p>init 程序首先是需要读取配置文件 /etc/inittab。</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2014/06/bg2013081703.png" alt="img"></p>
<h4 id="3-运行级别"><a href="#3-运行级别" class="headerlink" title="3. 运行级别"></a>3. 运行级别</h4><p>许多程序需要开机启动。它们在Windows叫做”服务”（service），在Linux就叫做”守护进程”（daemon）。</p>
<p>init进程的一大任务，就是去运行这些开机启动的程序。</p>
<p>但是，不同的场合需要启动不同的程序，比如用作服务器时，需要启动Apache，用作桌面就不需要。</p>
<p>Linux允许为不同的场合，分配不同的开机启动程序，这就叫做”运行级别”（runlevel）。也就是说，启动时根据”运行级别”，确定要运行哪些程序。</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2014/06/bg2013081704.png" alt="img"></p>
<h4 id="4-系统初始化"><a href="#4-系统初始化" class="headerlink" title="4. 系统初始化"></a>4. 系统初始化</h4><p>在init的配置文件中有这么一行： si::sysinit:/etc/rc.d/rc.sysinit　它调用执行了/etc/rc.d/rc.sysinit，而rc.sysinit是一个bash shell的脚本，它主要是完成一些系统初始化的工作，rc.sysinit是每一个运行级别都要首先运行的重要脚本。</p>
<p>它主要完成的工作有：激活交换分区，检查磁盘，加载硬件模块以及其它一些需要优先执行任务。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">l5:5:wait:/etc/rc.d/rc 5</span><br><span class="line">这一行表示以5为参数运行/etc/rc.d/rc，/etc/rc.d/rc是一个Shell脚本，它接受5作为参数，去执行/etc/rc.d/rc5.d/目录下的所有的rc启动脚本，/etc/rc.d/rc5.d/目录中的这些启动脚本实际上都是一些连接文件，而不是真正的rc启动脚本，真正的rc启动脚本实际上都是放在/etc/rc.d/init.d/目录下。</span><br><span class="line">而这些rc启动脚本有着类似的用法，它们一般能接受start、stop、restart、status等参数。</span><br><span class="line">/etc/rc.d/rc5.d/中的rc启动脚本通常是K或S开头的连接文件，对于以 S 开头的启动脚本，将以start参数来运行。</span><br><span class="line">而如果发现存在相应的脚本也存在K打头的连接，而且已经处于运行态了(以/var/lock/subsys/下的文件作为标志)，则将首先以stop为参数停止这些已经启动了的守护进程，然后再重新运行。</span><br><span class="line">这样做是为了保证是当init改变运行级别时，所有相关的守护进程都将重启。</span><br><span class="line">至于在每个运行级中将运行哪些守护进程，用户可以通过chkconfig或setup中的&quot;System Services&quot;来自行设定。</span><br></pre></td></tr></table></figure>

<p><img src="https://www.runoob.com/wp-content/uploads/2014/06/bg2013081705.png" alt="img"></p>
<h4 id="5-建立终端"><a href="#5-建立终端" class="headerlink" title="5. 建立终端"></a>5. 建立终端</h4><p>rc执行完毕后，返回init。这时基本系统环境已经设置好了，各种守护进程也已经启动了。</p>
<p>init接下来会打开6个终端，以便用户登录系统。在inittab中的以下6行就是定义了6个终端：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1:2345:respawn:/sbin/mingetty tty1</span><br><span class="line">2:2345:respawn:/sbin/mingetty tty2</span><br><span class="line">3:2345:respawn:/sbin/mingetty tty3</span><br><span class="line">4:2345:respawn:/sbin/mingetty tty4</span><br><span class="line">5:2345:respawn:/sbin/mingetty tty5</span><br><span class="line">6:2345:respawn:/sbin/mingetty tty6</span><br></pre></td></tr></table></figure>

<p>从上面可以看出在2、3、4、5的运行级别中都将以respawn方式运行mingetty程序，mingetty程序能打开终端、设置模式。</p>
<p>同时它会显示一个文本登录界面，这个界面就是我们经常看到的登录界面，在这个登录界面中会提示用户输入用户名，而用户输入的用户将作为参数传给login程序来验证用户的身份。</p>
<h4 id="6-用户登录系统"><a href="#6-用户登录系统" class="headerlink" title="6. 用户登录系统"></a>6. 用户登录系统</h4><p>一般来说，用户的登录方式有三种：</p>
<ul>
<li>（1）命令行登录</li>
<li>（2）ssh登录</li>
<li>（3）图形界面登录</li>
</ul>
<p><img src="https://www.runoob.com/wp-content/uploads/2014/06/bg2013081706.png" alt="img"></p>
<hr>
<h3 id="1-2-centos7开机启动流程"><a href="#1-2-centos7开机启动流程" class="headerlink" title="1.2 centos7开机启动流程"></a>1.2 centos7开机启动流程</h3><h4 id="1-开机自检"><a href="#1-开机自检" class="headerlink" title="1. 开机自检"></a>1. 开机自检</h4><h4 id="2-MBR-GPT引导系统启动"><a href="#2-MBR-GPT引导系统启动" class="headerlink" title="2. MBR/GPT引导系统启动"></a>2. MBR/GPT引导系统启动</h4><h4 id="3-加载GRUB2菜单"><a href="#3-加载GRUB2菜单" class="headerlink" title="3. 加载GRUB2菜单"></a>3. 加载GRUB2菜单</h4><p>（选择内核版本）</p>
<h4 id="4-加载内核选项"><a href="#4-加载内核选项" class="headerlink" title="4. 加载内核选项"></a>4. 加载内核选项</h4><h4 id="5-内核初始化使用systemd进程"><a href="#5-内核初始化使用systemd进程" class="headerlink" title="5. 内核初始化使用systemd进程"></a>5. 内核初始化使用<em>systemd</em>进程</h4><p>（启动的linux系统的第一个进程systemd）</p>
<h4 id="6-读取运行级别"><a href="#6-读取运行级别" class="headerlink" title="6. 读取运行级别"></a>6. 读取运行级别</h4><p>(桌面模式,命令模式)(/etc/systemd/system/default.target)</p>
<h4 id="7-初始化系统"><a href="#7-初始化系统" class="headerlink" title="7. 初始化系统"></a>7. 初始化系统</h4><p>(/usr/lib/systemd/system/sysinit.target)（挂载，启动网络，主机名……）</p>
<h4 id="8-根据运行级-别、并行启动服务"><a href="#8-根据运行级-别、并行启动服务" class="headerlink" title="8. 根据运行级 别、并行启动服务"></a>8. 根据运行级 别、并行启动服务</h4><p>(网络服务，ssh服务，定时任务……)</p>
<h4 id="9-显示login界面-输入用户和密码"><a href="#9-显示login界面-输入用户和密码" class="headerlink" title="9. 显示login界面 (输入用户和密码)"></a>9. 显示<em>login</em>界面 (输入用户和密码)</h4><p>(/usr/lib/systemd/system/getty.target)</p>
<hr>
<h2 id="2-linux关机相关操作"><a href="#2-linux关机相关操作" class="headerlink" title="2. linux关机相关操作"></a>2. linux关机相关操作</h2><h4 id="2-1-shutdown"><a href="#2-1-shutdown" class="headerlink" title="2.1 shutdown"></a>2.1 shutdown</h4><p>shutdown 会给系统计划一个时间关机。它可以被用于停止、关机、重启机器。shutdown 会给系统计划一个时间关机。它可以被用于停止、关机、重启机器。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shutdown -p now  ### 关闭机器</span><br><span class="line">shutdown -H now  ### 停止机器      </span><br><span class="line">shutdown -r 09:35 ### 在 09:35am 重启机器</span><br></pre></td></tr></table></figure>

<p>要取消即将进行的关机，只要输入下面的命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shutdown -c</span><br></pre></td></tr></table></figure>

<h4 id="2-2-halt"><a href="#2-2-halt" class="headerlink" title="2.2 halt"></a>2.2 halt</h4><p>halt 命令通知硬件来停止所有的 CPU 功能，但是仍然保持通电。你可以用它使系统处于低层维护状态。注意在有些情况会它会完全关闭系统。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">halt             ### 停止机器</span><br><span class="line">halt -p          ### 关闭机器、关闭电源</span><br><span class="line">halt --reboot    ### 重启机器</span><br></pre></td></tr></table></figure>

<h4 id="2-3-poweroff"><a href="#2-3-poweroff" class="headerlink" title="2.3 poweroff"></a>2.3 poweroff</h4><p>poweroff 会发送一个 ACPI 信号来通知系统关机。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">poweroff           ### 关闭机器、关闭电源</span><br><span class="line">poweroff --halt    ### 停止机器</span><br><span class="line">poweroff --reboot  ### 重启机器</span><br></pre></td></tr></table></figure>

<h4 id="2-4-reboot"><a href="#2-4-reboot" class="headerlink" title="2.4 reboot"></a>2.4 reboot</h4><p>reboot 命令 reboot 通知系统重启。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">reboot           ### 重启机器</span><br><span class="line">reboot --halt    ### 停止机器</span><br><span class="line">reboot -p        ### 关闭机器</span><br></pre></td></tr></table></figure>

<h2 id="3-linux系统运行级别"><a href="#3-linux系统运行级别" class="headerlink" title="3. linux系统运行级别"></a>3. linux系统运行级别</h2><h4 id="3-1-centos6"><a href="#3-1-centos6" class="headerlink" title="3.1 centos6"></a>3.1 centos6</h4><p>Linux系统有7个运行级别(runlevel)：</p>
<ul>
<li>运行级别0：系统停机状态，系统默认运行级别不能设为0，否则不能正常启动</li>
<li>运行级别1：单用户工作状态，root权限，用于系统维护，禁止远程登陆</li>
<li>运行级别2：多用户状态(没有NFS)</li>
<li>运行级别3：完全的多用户状态(有NFS)，登陆后进入控制台命令行模式</li>
<li>运行级别4：系统未使用，保留</li>
<li>运行级别5：X11控制台，登陆后进入图形GUI模式</li>
<li>运行级别6：系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动</li>
</ul>
<h4 id="3-2-centos7"><a href="#3-2-centos7" class="headerlink" title="3.2 centos7"></a>3.2 centos7</h4><ul>
<li>运行级别0：系统停机状态，系统默认运行级别不能设为0，否则不能正常启动</li>
<li>运行级别1：救援模式，root权限，用于系统维护，禁止远程登陆</li>
<li>运行级别2：多用户状态</li>
<li>运行级别3：多用户状态</li>
<li>运行级别4：多用户状态</li>
<li>运行级别5：X11控制台，登陆后进入图形GUI模式</li>
<li>运行级别6：系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">centos6系统</span></span><br><span class="line">runlevel #查看运行级别</span><br><span class="line">N 3 #如果N是其他数字,代表上一次运行级别</span><br><span class="line">init 3   #切换运行级别</span><br><span class="line">/etc/inittab #永久修改运行级别存放的配置文件</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">centos7系统</span></span><br><span class="line">systemctl get-default #查看系统默认启动运行级别</span><br><span class="line">systemctl set-default TARGET.target   #</span><br><span class="line">修改默认启动运行级别（永久生效）</span><br><span class="line">multi-user.target: analogous to runlevel 3</span><br><span class="line">graphical.target: analogous to runlevel 5</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-系统的systemd"><a href="#4-系统的systemd" class="headerlink" title="4.系统的systemd"></a>4.系统的systemd</h2><ul>
<li><p>什么是关闭/开启<strong>正在运行</strong>的服务/软件 systemctl stop/start sshd</p>
</li>
<li><p>什么是关闭/开启 <strong>开机自启动</strong>项 ?? systemctl disable/enable sshd</p>
</li>
</ul>
<h4 id="1-systemd的由来"><a href="#1-systemd的由来" class="headerlink" title="1.systemd的由来"></a><strong><em>1.systemd</em>的由来</strong></h4><p><em>Linux</em>一直以来都是采用<em>init</em>进程作为祖宗进程，但是<em>init</em>有两个缺点： </p>
<p><em>1</em>、<strong>启动时间长</strong>。<em>Init</em>进程是串行启动，只有前一个进程启动完，才会启动下一 </p>
<p>个进程。 </p>
<p><em>2</em>、<strong>启动脚本复杂</strong>，初始化完成后系统会加载很多脚本，脚本都会处理各自的 </p>
<p>情况，这会让脚本多而复杂。 </p>
<p><em>Centos5</em> 是启动速度最慢的，串行启动过程，无论进程相互之间有无依赖关系。</p>
<p><em>Centos6</em> 相对启动速度有所改进。有依赖的进程之间依次启动而其他与之没有依赖关系的则并行同步启动。</p>
<p><em>Centos7</em> 所有进程无论有无依赖关系则都是并行启动（当然很多时候进程没有真正启动而是只有一个信号或者说是标记而已，在真正利用的时候才会真正启 动）</p>
<img src="../AppData/Roaming/Typora/typora-user-images/image-20210406205736481.png" alt="image-20210406205736481" style="zoom: 80%;" />



<h4 id="2-什么是systemd"><a href="#2-什么是systemd" class="headerlink" title="2.什么是systemd"></a><strong>2.什么是systemd</strong></h4><p><em>systemd</em>即为<strong>system daemon</strong>守护进程，<em>systemd</em>主要解决上文的问题而诞 </p>
<p>生，<em>systemd</em>的目标是，为系统的启动和管理提供一套完整的解决方案。</p>
<p><strong>3.systemd的优势</strong></p>
<p><em>1</em>、最新系统都采用<em>systemd</em>管理（<em>RedHat7,CentOS7,Ubuntu15</em>等） <em>systemctl</em> </p>
<p><em>2</em>、<em>Centos7</em>支持开机并行启动服务，显著提高开机启动效率。 </p>
<p><em>3</em>、<em>Centos7</em>关机只关闭正在运行的服务，而<em>Centos6</em>全部都关闭一次。 </p>
<p><em>4</em>、<em>Centos7</em>服务的启动与停止不在使用脚本进行管理*,C7<em>下面都是配置</em>(/usr/lib/systemd/system/xxxx.service)<em>，也就是</em>/etc/init.d(CentOS 6)*下不在有脚 </p>
<p>本。</p>
<p><em>5</em>、<em>Centos7</em>使用<em>systemd</em>解决原有模式缺陷，比如原有<em>service</em>不会关闭程序产生的子进程。</p>
<h4 id="3-systemd相关配置文件"><a href="#3-systemd相关配置文件" class="headerlink" title="3.systemd相关配置文件"></a><strong>3.systemd相关配置文件</strong></h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/usr/lib/systemd/system/ #记录这一个就</span><br><span class="line">ok. 类似Centos6系统的启动脚本，/etc/init.d/</span><br><span class="line">/etc/systemd/system/    #系统配置存放,了解         </span><br><span class="line">\#类似Centos6系统的/etc/rc.d/rcN.d/</span><br><span class="line">/etc/systemd/system/multi-user.target.wants/*  #系统配置存放,了解</span><br></pre></td></tr></table></figure>

<h4 id="4-systemd管理服务相关命令"><a href="#4-systemd管理服务相关命令" class="headerlink" title="4.systemd管理服务相关命令"></a><strong>4.systemd管理服务相关命令</strong></h4><ul>
<li><em>systemctl</em>管理服务的启动、重启、停止、重载、查看状态等常用命令</li>
</ul>
<table>
<thead>
<tr>
<th>System Vinit（6系统）</th>
<th>systemctl命令（7系统）</th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td>service crond start   <br>/etc/init.dcrond start</td>
<td>systemctl start crond.service</td>
<td>启动服务当前运行</td>
</tr>
<tr>
<td>service crond stop</td>
<td>systemctl stop crond.service</td>
<td>停止服务</td>
</tr>
<tr>
<td>service crond restart</td>
<td>systemctl restart crond.service</td>
<td>重启服务</td>
</tr>
<tr>
<td>service crond reload</td>
<td>systemctl reload crond.service</td>
<td>优雅的重启重新加载配置<br>(不终止服务，不影响正在处理的请求的用户)</td>
</tr>
<tr>
<td>service crond status</td>
<td>systemctl status crond.service</td>
<td>查看服务运行状态</td>
</tr>
<tr>
<td></td>
<td>systemctl is-active crond.service</td>
<td>查看服务是否在运行中</td>
</tr>
<tr>
<td></td>
<td>systemctl mask  crond.service</td>
<td>禁止服务运行</td>
</tr>
<tr>
<td></td>
<td>systemctl unmask crond.service</td>
<td>取消禁止服务运行</td>
</tr>
</tbody></table>
<ul>
<li>systemctl 设置服务<strong>开机启动</strong>、不启动、查看各级别下服务启动状态等常用命令</li>
</ul>
<table>
<thead>
<tr>
<th>System Vinit（6系统）</th>
<th>systemctl命令（7系统）</th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td>chkconfig crond on</td>
<td>systemctl <strong>enable</strong> crond.service</td>
<td>开机自动启动</td>
</tr>
<tr>
<td>chkconfig crond off</td>
<td>systemctl disable crond.service</td>
<td>关闭开机自启动</td>
</tr>
<tr>
<td>chkconfig –list</td>
<td>systemctl list-unit-files</td>
<td>查看各个级别下服务的<br>启动与禁用</td>
</tr>
<tr>
<td>chkconfig –list crond</td>
<td>systemctl is-enabled crond.service</td>
<td>产看指定服务是否为开机自启动</td>
</tr>
<tr>
<td>chkconfig –add crond</td>
<td>systemctl daemon-reload</td>
<td>创建新服务文件或者变设置</td>
</tr>
</tbody></table>
<ul>
<li>systemctl 服务状态说明</li>
</ul>
<table>
<thead>
<tr>
<th><strong>服务状态</strong></th>
<th><strong>状态说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>loaded</td>
<td>服务单元的配置文件已经被处理, 配置放在了/usr/lib/systemd/system/</td>
</tr>
<tr>
<td>active(running)</td>
<td>服务的一个或多个进程在运行中 最常见的状态 start</td>
</tr>
<tr>
<td>active(exited)</td>
<td><strong>一次性</strong>运行的服务成功被执行并退出(服务运行后完成任务,相关进程会自动退出)</td>
</tr>
<tr>
<td>active(waiting)</td>
<td>服务已经运行但在等待某个事件</td>
</tr>
<tr>
<td>inactive</td>
<td>服务没有在运行 stop</td>
</tr>
<tr>
<td>enabled</td>
<td>服务设定为开机运行</td>
</tr>
<tr>
<td>disabled</td>
<td>服务设定为开机不运行</td>
</tr>
<tr>
<td>static</td>
<td>服务不能被设定开机启动,但可以由其他服务启动该服务</td>
</tr>
</tbody></table>
<ul>
<li><em>systemctl</em>的<em>journalctl</em>日志 </li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">服务启动或管理,排错流程</span></span><br><span class="line">systemctl 启动/重启/关闭 服务失败,报错   </span><br><span class="line">journalctl -xe   #-e按页显示   -x进行一些翻译,指出一些故障提示</span><br><span class="line">找error 或 err 或warn 或fail </span><br><span class="line">故障模拟 修改网卡配置文件, IPADDR</span><br><span class="line"></span><br><span class="line">journalctl -n 20    #查看最后20行</span><br><span class="line">journalctl -f       #动态查看日志 ※※※</span><br><span class="line">journalctl -p err   #查看日志的级别</span><br><span class="line">journalctl -u crond #查看某个服务的单元的日志</span><br></pre></td></tr></table></figure>

<p> “auto_save_delay_in_seconds”: 0.15,</p>
<p>netstat -tupln | grep id 查看进程端口</p>
]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
      <tags>
        <tag>system</tag>
      </tags>
  </entry>
  <entry>
    <title>定时任务</title>
    <url>/Linux%E5%9F%BA%E7%A1%80/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</url>
    <content><![CDATA[<h1 id="Linux定时任务"><a href="#Linux定时任务" class="headerlink" title="Linux定时任务"></a>Linux定时任务</h1><h2 id="定时任务基本概述"><a href="#定时任务基本概述" class="headerlink" title="定时任务基本概述"></a>定时任务基本概述</h2><ul>
<li><p>crond简介</p>
<p>Linux系统上面有很多计划性的工作，比如在某个时间点需要执行某个动作，在Linux中，一般使用crontab命令来实现控制计划任务，通过crontab 命令，我们可以在固定的间隔时间执行指定的系统指令或 shell script脚本。时间间隔的单位可以是分钟、小时、日、月、周及以上的任意组合。这个命令非常设合周期性的日志分析或数据备份等工作。crontab命令是基于crond这个系统服务的，crond服务是安装Linux系统时自动安装的，它会检查当前系统中是否有要执行的任务。</p>
<p>Crond服务会定期（默认每分钟检查一次）检查系统中是否有要执行的任务工作，如果有，便会根据其预先设定的定时任务规则自动执行该定时任务工作，这个crond定时任务服务就相当于我们平时早起使用的闹钟一样。</p>
</li>
<li><p>Linux下的任务调度分为系统层面的任务调度和用户自定义的任务调度。</p>
</li>
</ul>
<ol>
<li><p><strong>系统级别的定时任务</strong></p>
<p>比如写缓存数据到硬盘、临时文件清理、系统信息采集、日志文件切割。</p>
<p>在/etc目录下有一个crontab文件，这个就是系统任务调度的配置文件。打开/etc目录，我们可以看到有很多cron相关的目录，如下：    </p>
<img src="AppData/Roaming/Typora/typora-user-images/image-20210413155628596.png" alt="image-20210413155628596" style="zoom:150%;" />

<p>cron.deny表示该文件中所列的用户不允许使用crontab命令;</p>
<p>cron.daily表示每天都要按照计划完成的任务；</p>
<p>cron.hourly表示每个小时都要按照计划完成的任务；</p>
<p>cron.weekly表示每个小时都要按照计划完成的任务；</p>
</li>
<li><p><strong>用户级别的定时任务</strong></p>
<p>定时向互联网同步时间、定时备份系统配置文件、定时备份数据库的数据。</p>
<p>*/var/spool/cron/*目录是所有crontab文件存放的目录，以用户名命名</p>
<p>如centos7.9下：/var/spool/cron/root </p>
</li>
</ol>
<hr>
<h2 id="crontab配置文件"><a href="#crontab配置文件" class="headerlink" title="crontab配置文件"></a>crontab配置文件</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/crontab</span><br><span class="line">SHELL=/bin/bash</span><br><span class="line">PATH=/sbin:/bin:/usr/sbin:/usr/bin</span><br><span class="line">MAILTO=root</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> For details see man 4 crontabs</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Example of job definition:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> .---------------- minute (0 - 59)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> |  .------------- hour (0 - 23)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> |  |  .---------- day of month (1 - 31)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> |  |  |  |  |</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> *  *  *  *  * user-name  <span class="built_in">command</span> to be executed</span></span><br><span class="line"></span><br><span class="line">备注：</span><br><span class="line">1） *  表示任意的(分、时、日、月、周)时间都执行</span><br><span class="line">2） -  表示一个时间范围段, 如5-7点</span><br><span class="line">3） ,  表示分隔时段, 如6,0,4表示周六、日、四</span><br><span class="line">4） /  表示每隔n单位时间, 如*/10 每10分钟</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="设置定时任务"><a href="#设置定时任务" class="headerlink" title="设置定时任务"></a>设置定时任务</h2><h3 id="crontab-命令选项："><a href="#crontab-命令选项：" class="headerlink" title="crontab 命令选项："></a>crontab 命令选项：</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-e                    #编辑定时任务</span><br><span class="line">-l                     #查看定时任务</span><br><span class="line">-r                     #删除定时任务</span><br><span class="line">-u                    #指定其他用户</span><br><span class="line">-i                     #在删除用户的crontab文件时给确认提示。</span><br></pre></td></tr></table></figure>

<p><strong>服务操作说明</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">需提前安装软件包</span></span><br><span class="line">yum install -y ntpdate</span><br><span class="line">服务操作说明：</span><br><span class="line"></span><br><span class="line">/sbin/service crond start //启动服务</span><br><span class="line"></span><br><span class="line">/sbin/service crond stop //关闭服务</span><br><span class="line"></span><br><span class="line">/sbin/service crond restart //重启服务</span><br><span class="line"></span><br><span class="line">/sbin/service crond reload //重新载入配置</span><br><span class="line"></span><br><span class="line">/sbin/service crond status //启动服务</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-2-任务实例："><a href="#3-2-任务实例：" class="headerlink" title="3.2 任务实例："></a>3.2 任务实例：</h3><p><strong>示例一：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">示例1：使用root用户每2分钟执行一次时间同步</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">先在Linux系统上查看命令是否正确</span></span><br><span class="line">[root@tom ~]# ntpdate ntp1.aliyun.com</span><br><span class="line">12 Apr 12:59:18 ntpdate[69500]: adjust time server 120.25.115.20 offset 0.024905 sec</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">配置定时任务</span></span><br><span class="line"><span class="meta">#</span><span class="bash">编辑定时任务</span></span><br><span class="line">[root@tom  ~]# crontab -e -u root</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">每2分钟执行一次时间同步 by wxg At 2021.04.12</span></span><br><span class="line">*/2 * * * * /usr/sbin/ntpdate ntp1.aliyun.com &amp;&gt;/dev/null</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">查看定时任务</span></span><br><span class="line">[root@tom  ~]# crontab -l -u root</span><br><span class="line"><span class="meta">#</span><span class="bash">每2分钟执行一次时间同步 by wxg At 2021.04.12</span></span><br><span class="line">*/2 * * * * /usr/sbin/ntpdate ntp1.aliyun.com &amp;&gt;/dev/null</span><br></pre></td></tr></table></figure>

<p><strong>示例二</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">示例2：每天凌晨6点做一次备份 打包备份/etc/ 备份到/tmp中并命名当天日期</span><br><span class="line">crontab -e -u root</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">每天凌晨3点做一次备份？ 打包备份/etc/</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  % 在crontab中比较特殊应用 \ 转义</span></span><br><span class="line">00 06 * * * tar zcf /tmp/`date +\%F_\%w`_etc.tar.gz /etc    </span><br><span class="line"></span><br><span class="line">pr 12 13:09:01 tom CRON[69714]: (tom) CMD (sudo tar ar zcf /tmp/`date +%F`_etc.tar.gz /etc   )</span><br></pre></td></tr></table></figure>

<h3 id="3-3-crond拒绝某个用户使用"><a href="#3-3-crond拒绝某个用户使用" class="headerlink" title="3.3 crond拒绝某个用户使用"></a>3.3 crond拒绝某个用户使用</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">1.使用root将需要拒绝的用户加入/etc/cron.deny</span></span><br><span class="line">[root@tom  ~]# echo &quot;Jerry&quot; &gt;&gt; /etc/cron.deny</span><br><span class="line"><span class="meta">#</span><span class="bash">2.登陆该普通用户，测试是否能编写定时任务</span></span><br><span class="line">[oldboy@tom  ~]$ crontab -e</span><br><span class="line">You (Jerry) are not allowed to use this program </span><br><span class="line">(crontab)</span><br><span class="line">See crontab(1) for more information</span><br></pre></td></tr></table></figure>

<h3 id="crond注意的事项"><a href="#crond注意的事项" class="headerlink" title="crond注意的事项"></a>crond注意的事项</h3><ol>
<li><p>给定时任务注释</p>
</li>
<li><p>将需要定期执行的任务写入<em>Shell</em>脚本中，避免直接使用命令无法执行的情况<em>tar date</em></p>
</li>
<li><p>定时任务的结尾一定要有*&amp;&gt;/dev/null*或者将结果追加重定向&gt;&gt;/tmp/date.log文件</p>
<p>每条任务调度执行完毕，系统都会将任务输出信息通过电子邮件的形式发送给当前系统用户，这样日积月累，日志信息会非常大，可能会影响系统的正常运行，因此，将每条任务进行重定向处理非常重要。</p>
</li>
<li><p>注意有些命令是无法成功执行的 <em>echo “123” &gt;&gt;/tmp/test.log &amp;&gt;/dev/null</em></p>
</li>
<li><p>如果一定要是用命令，命令必须使用绝对路径</p>
</li>
</ol>
<h3 id="crontab备份"><a href="#crontab备份" class="headerlink" title="crontab备份"></a>crontab备份</h3><p>通过查找*/var/log/cron*中执行的记录，去推算任务执行的时间</p>
<p>定时的备份*/var/spool/cron/{username}*</p>
<h2 id="定时任务安全项目实战练习"><a href="#定时任务安全项目实战练习" class="headerlink" title="定时任务安全项目实战练习"></a>定时任务安全项目实战练习</h2><ul>
<li><p>项目名称: XXXXX网站安全检查项目</p>
</li>
<li><p>项目背景: 网站因为安全配置导致病毒入侵,如何快速排查出哪些是病毒(被感染的文件或命令)</p>
</li>
<li><p>项目步骤: </p>
<p><img src="AppData/Roaming/Typora/typora-user-images/image-20210414211016694.png" alt="image-20210414211016694"></p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">将系统中/etc/目录下的文件做指纹，指纹结果定向到file.md5中</span></span><br><span class="line">find /etc/ -type f | xargs md5sum &gt;&gt; /file.md5</span><br><span class="line"><span class="meta">#</span><span class="bash">进行校验</span></span><br><span class="line"><span class="meta">#</span><span class="bash">若无文件被修改 则输出ok ，若有则输出filed</span></span><br><span class="line">md5sum -c  file.md5</span><br><span class="line"><span class="meta">#</span><span class="bash">使被篡改的文件输出</span></span><br><span class="line">md5sum -c --quiet file.md5</span><br></pre></td></tr></table></figure>



<h2 id="错误排查"><a href="#错误排查" class="headerlink" title="错误排查"></a>错误排查</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">crontab -e</span><br><span class="line">no crontab <span class="keyword">for</span> root - using an empty one</span><br><span class="line">/bin/sh: /usr/bin/vi: No such file or directory</span><br><span class="line">crontab: <span class="string">&quot;/usr/bin/vi&quot;</span> exited with status 127</span><br><span class="line"></span><br><span class="line">发生这种情况是因为没有正确定义编辑器。为此，您必须指定二进制文件的完整路径：</span><br><span class="line"><span class="built_in">export</span> EDITOR=/usr/bin/vim</span><br><span class="line">或者</span><br><span class="line"><span class="built_in">export</span> EDITOR=/usr/bin/vi</span><br></pre></td></tr></table></figure>

<script src='https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/mouse_snow.min.js'></script>





]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
      <tags>
        <tag>cron</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟化和云计算的区别</title>
    <url>/%E4%BA%91%E8%AE%A1%E7%AE%97/%E8%99%9A%E6%8B%9F%E5%8C%96%E5%92%8C%E4%BA%91%E8%AE%A1%E7%AE%97%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="一-Docker架构分析"><a href="#一-Docker架构分析" class="headerlink" title="一.Docker架构分析"></a>一.Docker架构分析</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如下图所示，Docker采用的是 Client/Server 架构。客户端向服务器发送请求，服务器负责构建、运行和分发容器。</span><br><span class="line"></span><br><span class="line">　　客户端和服务器可以运行在同一个 Host 上，客户端也可以通过socket或 REST API与远程的服务器通信。</span><br><span class="line">　　</span><br><span class="line">　　推荐阅读:</span><br><span class="line">	https://docs.docker.com/get-started/overview/</span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/WEB3031069c14b2641550ed11dbcbbc4fc1?method=download&shareKey=983cfe4b6cdf65ec627e1c390c4e6932" alt="img"></p>
<h2 id="1-Client"><a href="#1-Client" class="headerlink" title="1.Client"></a>1.Client</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">　　Docker客户端，最常用的Docker客户端是docker命令。通过docker我们可以方便地在Host上构建和运行容器。</span><br><span class="line">　　    </span><br><span class="line">　　docker支持很多操作(docker命令行工具)，用户也可以通过REST API与服务器通信。</span><br><span class="line">　　    </span><br><span class="line">　　Client和Docker daemon通信可使用https/http协议进行通信，为了安全起见，默认使用的就是https协议。</span><br></pre></td></tr></table></figure>



<h2 id="2-Docker-Host"><a href="#2-Docker-Host" class="headerlink" title="2.Docker-Host"></a>2.Docker-Host</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Docker daemon： 　</span><br><span class="line">　　　　Docker daemon是服务器组件，即Docker守护进程服务器，以Linux后台服务的方式运行。</span><br><span class="line">　　　　Docker daemon运行在Docker host上，负责创建、运行、监控容器，构建、存储镜像。默认配置下，Docker daemon只能响应来自本地Host的客户端请求。如果要允许远程客户端请求，需要在配置文件中打开TCP监听（支持IPV4和IPV6）。</span><br><span class="line">       </span><br><span class="line">　　Containers： 　　</span><br><span class="line">　　　　Docker容器，用于加载Docker镜像。换句话说，Docker容器就是Docker镜像的运行实例。我们知道镜像(Image)是只读的，在启动一个Container时，其实就是基于Image来新建一个专用的可写仓供用户使用。</span><br><span class="line">       </span><br><span class="line">　　Image： 　　</span><br><span class="line">　　　　可将Docker镜像看成只读模板(它类似于虚拟机使用的ISO镜像文件)，通过它可以创建Docker容器。例如某个镜像可能包含一个Ubuntu操作系统、一个Apache HTTP Server以及用户开发的Web应用。</span><br><span class="line">　　　　镜像有多种生成方法：</span><br><span class="line">　　　　　　(1)可以从无到有开始创建镜像；</span><br><span class="line">　　　　　　(2)也可以下载并使用别人创建好的现成的镜像</span><br><span class="line">　　　　　　(3)还可以在现有镜像上创建新的镜像</span><br><span class="line">　　　　　　(4)我们可以将镜像的内容和创建步骤描述在一个文本文件中，这个文件被称作Dockerfile，通过执行docker build &lt;docker-file&gt;命令可以构建出Docker镜像。</span><br><span class="line">　　　　公开的镜像仓库有很多种，如下所示: </span><br><span class="line">　　　　　　Docker官方镜像地址：</span><br><span class="line">　　　　　　　　https://hub.docker.com/。</span><br><span class="line">　　　　　　阿里的docker镜像地址：</span><br><span class="line">　　　　　　　　https://mirrors.aliyun.com/docker-ce/linux/</span><br><span class="line">　　　　　　清华大学docker镜像地址：</span><br><span class="line">　　　　　　 https://mirrors.tuna.tsinghua.edu.cn/docker-ce/</span><br><span class="line"></span><br><span class="line">　　温馨提示:</span><br><span class="line">　　　　生产环境中，我们通常在公司内部部署有私有镜像仓库。如使用Harbor，Docker Registry等等。在后续的文章我们会逐一对其进行讲解。</span><br></pre></td></tr></table></figure>



<h2 id="3-Registry"><a href="#3-Registry" class="headerlink" title="3.Registry"></a>3.Registry</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我们去构建镜像时，镜像做好之后应该有一个统一存放位置，我们称之为Docker仓库，Registry是存放Docker镜像的仓库（官方默认仓库在&quot;https://hub.docker.com&quot;），Registry分私有和公有两种。</span><br><span class="line"></span><br><span class="line">Images和Registry之间默认使用的时https协议，当然如果你非要指定为http协议也是可以的。</span><br><span class="line"></span><br><span class="line">启动容器时，docker daemon会试图从本地获取相关的镜像；本地镜像不存在时，其将从Registry中下载该镜像并保存到本地。　　</span><br><span class="line"></span><br><span class="line">Registry用于保存docker镜像，包括镜像的层次结构和元数据。用户可自建Registry，也可使用官方的Docker Hub。　　</span><br><span class="line"></span><br><span class="line">Docker Registry中的镜像通常由开发人员制作，而后推送至&quot;公共&quot;或&quot;私有&quot;Registry上保存，供其它人员使用，例如&quot;部署&quot;到生产环境。</span><br><span class="line"></span><br><span class="line">Docker Registry可分为以下几类:　　　　</span><br><span class="line">　　　　Sponsor Registry:</span><br><span class="line">　　　　　　第三方的registry，供客户端和Docker社区使用。　　　　</span><br><span class="line">　　　　Mirror Registry:</span><br><span class="line">　　　　　　第三方的registry，只让客户使用。　　　　</span><br><span class="line">　　　　Vendor Registry:</span><br><span class="line">　　　　　　由发布Docker镜像的供应商提供的registry。　　　　</span><br><span class="line">　　　　Private Registry:</span><br><span class="line">　　　　　　通过设有防火墙和额外的安全层的私有实体提供的registry。　　</span><br><span class="line"></span><br><span class="line">Registry包括Repository和Index，详细说明如下：　　　　</span><br><span class="line">	Repository:　　　　　　</span><br><span class="line">		由某特定的docker镜像的所有迭代版本组成的镜像仓库；</span><br><span class="line">		一个Registry中可以存在多个Repository：　　　　　　　　</span><br><span class="line">		Repository可分为&quot;顶层仓库&quot;和&quot;用户仓库&quot;；　　　　　　　　</span><br><span class="line">		用户仓库名称格式为&quot;用户名/仓库名&quot;。　　　　　　</span><br><span class="line">		每个仓库可以包含多个Tag(标签)，每个标签对应一个镜像；　　　　</span><br><span class="line">	Index：　　　　　　</span><br><span class="line">		维护用户账户，镜像的校验以及公共命名空间的信息；　　　　　　</span><br><span class="line">		相当于为Registry提供了一个完成用户认证等功能的检索接口。</span><br></pre></td></tr></table></figure>



<h2 id="4-镜像名称判断"><a href="#4-镜像名称判断" class="headerlink" title="4.镜像名称判断"></a>4.镜像名称判断</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">官方仓库:</span><br><span class="line">	官方镜像:</span><br><span class="line">       	nginx:1.20.1</span><br><span class="line">       用户上传镜像:</span><br><span class="line">       	jasonyin2020/oldboyedu_birds:v1</span><br><span class="line">       	</span><br><span class="line">第三方仓库:</span><br><span class="line">	用户上传镜像:</span><br><span class="line">		tuv7rqqq.mirror.aliyuncs.com/library/nginx:latest</span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/WEB619ede23fe543e8ad87fc3167b989033?method=download&shareKey=50ed40d4e7be6b8498105cdff2e8fc4d" alt="image-20210609221448005"></p>
<h2 id="5-docker、containerd的关系"><a href="#5-docker、containerd的关系" class="headerlink" title="5.docker、containerd的关系"></a>5.docker、containerd的关系</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">为了防止docker一家独大，docker当年的实现被拆分出了几个标准化的模块，标准化的目的是模块是可被其他实现替换的，不由任何一个厂商控制。</span><br><span class="line"></span><br><span class="line">docker由docker-client,dockerd,containerd,docker-shim,runc组成，所以containerd是docker的基础组件之一，下面是从containerd引过来的一张图。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">推荐阅读:</span><br><span class="line">	https://containerd.io/</span><br><span class="line">	https://cloud.tencent.com/document/product/457/35747</span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/WEB9ae043893800198f4cfd20c83d42606e?method=download&shareKey=4d6e228352542fb79aaf6d93dfa1b491" alt="image-20210624151140220"></p>
<h1 id="二-部署docker环境"><a href="#二-部署docker环境" class="headerlink" title="二.部署docker环境"></a>二.部署docker环境</h1><h2 id="1-关闭并禁用防火墙"><a href="#1-关闭并禁用防火墙" class="headerlink" title="1.关闭并禁用防火墙"></a>1.关闭并禁用防火墙</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@docker201.oldboyedu.com ~]# systemctl stop firewalld</span><br><span class="line">[root@docker201.oldboyedu.com ~]# </span><br><span class="line">[root@docker201.oldboyedu.com ~]# systemctl disable firewalld</span><br><span class="line">Removed symlink /etc/systemd/system/multi-user.target.wants/firewalld.service.</span><br><span class="line">Removed symlink /etc/systemd/system/dbus-org.fedoraproject.FirewallD1.service.</span><br><span class="line">[root@docker201.oldboyedu.com ~]# </span><br></pre></td></tr></table></figure>



<h2 id="2-停用并禁用selinux"><a href="#2-停用并禁用selinux" class="headerlink" title="2.停用并禁用selinux"></a>2.停用并禁用selinux</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@docker201.oldboyedu.com ~]# getenforce </span><br><span class="line">Enforcing</span><br><span class="line">[root@docker201.oldboyedu.com ~]# </span><br><span class="line">[root@docker201.oldboyedu.com ~]# setenforce 0</span><br><span class="line">[root@docker201.oldboyedu.com ~]# </span><br><span class="line">[root@docker201.oldboyedu.com ~]# grep ^SELINUX= /etc/selinux/config</span><br><span class="line">SELINUX=enforcing</span><br><span class="line">[root@docker201.oldboyedu.com ~]# </span><br><span class="line">[root@docker201.oldboyedu.com ~]# sed -ri s&#x27;#(SELINUX=)enforcing#\1disabled#&#x27; /etc/selinux/config</span><br><span class="line">[root@docker201.oldboyedu.com ~]# </span><br><span class="line">[root@docker201.oldboyedu.com ~]# grep ^SELINUX= /etc/selinux/config</span><br><span class="line">SELINUX=disabled</span><br><span class="line">[root@docker201.oldboyedu.com ~]# </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="3-卸载docker较旧的依赖项-如果您的操作系统是刚刚安装完成的状态，或者当前服务器没有安装过docker环境，则可以跳过该步骤"><a href="#3-卸载docker较旧的依赖项-如果您的操作系统是刚刚安装完成的状态，或者当前服务器没有安装过docker环境，则可以跳过该步骤" class="headerlink" title="3.卸载docker较旧的依赖项(如果您的操作系统是刚刚安装完成的状态，或者当前服务器没有安装过docker环境，则可以跳过该步骤)"></a>3.卸载docker较旧的依赖项(如果您的操作系统是刚刚安装完成的状态，或者当前服务器没有安装过docker环境，则可以跳过该步骤)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum -y remove docker docker-client docker-client-latest docker-common docker-lastest docker-lastest-logrotate docker-logrotate  docker-engine</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">温馨提示:</span><br><span class="line">　　(1)现在将Docker Engine软件包称为docker-ce，较旧的Docker Engine版本称为docker或docker-engine。如果已安装这些程序，请卸载它们以及相关的依赖项，因为新老docker版本并不相互兼容哟;</span><br><span class="line">　　(2)如果您在之前没有安装过docker环境，则无需做当前步骤，如果您非要做该步骤，可能会出现如下图所示的情况，属于正常现象！</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/WEB7a08da595901182122b042d0086d7216?method=download&shareKey=65d6999a105b014572ad817c35e72072" alt="image-20210608230633881"></p>
<h2 id="4-Docker-engine常见的安装方法概述"><a href="#4-Docker-engine常见的安装方法概述" class="headerlink" title="4.Docker engine常见的安装方法概述"></a>4.Docker engine常见的安装方法概述</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">您可以根据需要以不同的方式安装Docker Engine：</span><br><span class="line">　　　　(1)大多数用户会 设置Docker的存储库并从中进行安装，以简化安装和升级任务。这是推荐的方法。</span><br><span class="line">　　　　(2)一些用户下载并手动安装RPM软件包，并完全手动管理升级。这在诸如在无法访问互联网的空白系统上安装Docker的情况下非常有用。</span><br><span class="line">　　　　(3)在测试和开发环境中，一些用户选择使用自动便利脚本来安装Docker。　　</span><br><span class="line">　　　　</span><br><span class="line">　　　　温馨提示:　　　　</span><br><span class="line">　　　　	本篇博客是基于存储库(需要配置软件源)的方式进行安装，即在新主机上首次安装Docker Engine之前，需要设置Docker存储库。之后，您可以从存储库安装和更新Docker。</span><br></pre></td></tr></table></figure>



<h2 id="5-切换国内的软件源-本案例切换的是阿里源，当然，您也可以考虑使用其它的公网软件源哟"><a href="#5-切换国内的软件源-本案例切换的是阿里源，当然，您也可以考虑使用其它的公网软件源哟" class="headerlink" title="5.切换国内的软件源(本案例切换的是阿里源，当然，您也可以考虑使用其它的公网软件源哟)"></a>5.切换国内的软件源(本案例切换的是阿里源，当然，您也可以考虑使用其它的公网软件源哟)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(1)备份CentOS官网的软件源</span><br><span class="line">mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup</span><br><span class="line"></span><br><span class="line">(2)下载阿里云的软件源</span><br><span class="line">curl -o /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-7.repo </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(3)非阿里云ESC产品推荐操作该步骤</span><br><span class="line">sed -i -e &#x27;/mirrors.cloud.aliyuncs.com/d&#x27; -e &#x27;/mirrors.aliyuncs.com/d&#x27; /etc/yum.repos.d/CentOS-Base.repo</span><br><span class="line"></span><br><span class="line">(4)生成本地缓存</span><br><span class="line">yum makecache</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">温馨提示:</span><br><span class="line">　　上述的sed命令是可选操作，因为非阿里云ECS用户会出现&quot;Could not resolve host: mirrors.cloud.aliyuncs.com; Unknown error&quot;信息，不影响使用。</span><br><span class="line"></span><br><span class="line">参考链接: 　　</span><br><span class="line">　　https://developer.aliyun.com/mirror/centos</span><br></pre></td></tr></table></figure>



<h2 id="6-配置docker-ce的软件源-也称为”存储库”"><a href="#6-配置docker-ce的软件源-也称为”存储库”" class="headerlink" title="6.配置docker-ce的软件源(也称为”存储库”)"></a>6.配置docker-ce的软件源(也称为”存储库”)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(1)添加docker-ce的软件源</span><br><span class="line">	yum -y install yum-utils</span><br><span class="line">	yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line">	</span><br><span class="line">(2)官方软件源默认启用了最新的软件，您可以通过编辑软件源的方式获取各个版本的软件包。例如官方并没有将测试版本的软件源置为可用，您可以通过以下方式开启。同理可以开启各种测试版本等。</span><br><span class="line">	yum-config-manager --enable docker-ce-test  # 可选操作，若不启用并不影响安装docker-ce。</span><br><span class="line">	yum-config-manager --enable docker-ce-nightly  # 可选操作</span><br><span class="line"></span><br><span class="line">(3)如果您启用了多个Docker存储库，则在未在yum installor yum update命令中指定版本的情况下进行安装或更新将始终安装可能的最高版本，这可能不适合您的稳定性需求，这个时候我们也可以来禁用最新的软件源哟~</span><br><span class="line">	yum-config-manager --disable docker-ce-test</span><br><span class="line">	yum-config-manager --disable docker-ce-nightly</span><br><span class="line">	</span><br><span class="line">参考链接:</span><br><span class="line">　　https://developer.aliyun.com/mirror/docker-ce</span><br><span class="line">　　https://docs.docker.com/engine/install/centos/</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="7-安装Docker-Engine和容器"><a href="#7-安装Docker-Engine和容器" class="headerlink" title="7.安装Docker Engine和容器"></a>7.安装Docker Engine和容器</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(1)若不指定安装的docker版本，则默认安装最新版本的Docker Engine和容器</span><br><span class="line">	yum -y install docker-ce docker-ce-cli containerd.io</span><br><span class="line"></span><br><span class="line">(2)要安装特定版本的Docker Engine，请在存储库中列出可用版本，然后选择并安装。返回的列表取决于启用的存储库，并且特定于您的CentOS版本（.el7此示例中的后缀表示）</span><br><span class="line">	yum list docker-ce --showduplicates | sort -r</span><br><span class="line">	</span><br><span class="line">(3)通过其完全合格的软件包名称安装特定版本，该软件包名称是软件包名称（docker-ce）加上版本字符串（第二列），从第一个冒号（:）一直到第一个连字符，并用连字符（-）分隔。其语法格式如下所示。</span><br><span class="line">	yum install docker-ce-&lt;VERSION_STRING&gt; docker-ce-cli-&lt;VERSION_STRING&gt; containerd.io  # 安装特定docker版本的语法格式，下面有对应的案例哟~</span><br><span class="line">	yum install docker-ce-20.10.7 docker-ce-cli-20.10.7 containerd.io</span><br><span class="line">	</span><br><span class="line">温馨提示:</span><br><span class="line">	(1)此处我安装了指定的版本，我们可以将&quot;/etc/yum.conf&quot;的&quot;keepcache&quot;进行缓存即可。</span><br><span class="line">	(2)将rpm包进行打包下发到其他节点</span><br><span class="line">        [root@docker201.oldboyedu.com ~]# mkdir docker_rpm_20.10</span><br><span class="line">        [root@docker201.oldboyedu.com ~]# </span><br><span class="line">        [root@docker201.oldboyedu.com ~]# find /var/cache/yum/ -type f -name &quot;*.rpm&quot; | xargs mv -t docker_rpm_20.10</span><br><span class="line">        [root@docker201.oldboyedu.com ~]# </span><br><span class="line">        [root@docker201.oldboyedu.com ~]# </span><br><span class="line">        [root@docker201.oldboyedu.com ~]# tar zcf docker_rpm_20.10.tar.gz docker_rpm_20.10</span><br><span class="line">        [root@docker201.oldboyedu.com ~]# </span><br><span class="line">        [root@docker201.oldboyedu.com ~]# ll -h</span><br><span class="line">        总用量 109M</span><br><span class="line">        drwxr-xr-x. 2 root root 4.0K 6月   9 21:00 docker_rpm_20.10</span><br><span class="line">        -rw-r--r--. 1 root root 109M 6月   9 21:01 docker_rpm_20.10.tar.gz</span><br><span class="line">        [root@docker201.oldboyedu.com ~]# </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="8-启动docker守护进程并设置开机自启动"><a href="#8-启动docker守护进程并设置开机自启动" class="headerlink" title="8.启动docker守护进程并设置开机自启动"></a>8.启动docker守护进程并设置开机自启动</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@docker201.oldboyedu.com ~]# systemctl start docker</span><br><span class="line">[root@docker201.oldboyedu.com ~]# </span><br><span class="line">[root@docker201.oldboyedu.com ~]# systemctl enable docker</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="9-查看docker的概要信息"><a href="#9-查看docker的概要信息" class="headerlink" title="9.查看docker的概要信息"></a>9.查看docker的概要信息</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@docker201.oldboyedu.com ~]# docker info</span><br></pre></td></tr></table></figure>

<p><img src="%25E7%25AC%2594%25E8%25AE%25B0/04-%25E8%2580%2581%25E7%2594%25B7%25E5%25AD%25A9%25E6%2595%2599%25E8%2582%25B2-Docker%25E7%259A%2584%25E6%259E%25B6%25E6%259E%2584%25E4%25BB%258B%25E7%25BB%258D%25E5%258F%258A%25E9%2583%25A8%25E7%25BD%25B2%25E5%25AE%259E%25E6%2588%2598.assets/image-20210609004903141.png" alt="image-20210609004903141"></p>
<h2 id="10-修改docker-engine的默认Registry，建议使用国内的镜像仓库，国外的源网络会延迟较大"><a href="#10-修改docker-engine的默认Registry，建议使用国内的镜像仓库，国外的源网络会延迟较大" class="headerlink" title="10.修改docker engine的默认Registry，建议使用国内的镜像仓库，国外的源网络会延迟较大"></a>10.修改docker engine的默认Registry，建议使用国内的镜像仓库，国外的源网络会延迟较大</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@docker201.oldboyedu.com ~]# tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;&gt; &#123;&gt; &quot;registry-mirrors&quot;: [&quot;https://tuv7rqqq.mirror.aliyuncs.com&quot;]&gt; &#125;&gt; EOF&#123;&quot;registry-mirrors&quot;: [&quot;https://tuv7rqqq.mirror.aliyuncs.com&quot;]&#125;[root@docker201.oldboyedu.com ~]# [root@docker201.oldboyedu.com ~]# [root@docker201.oldboyedu.com ~]# cat /etc/docker/daemon.json &#123;&quot;registry-mirrors&quot;: [&quot;https://tuv7rqqq.mirror.aliyuncs.com&quot;]&#125;[root@docker201.oldboyedu.com ~]# [root@docker201.oldboyedu.com ~]# systemctl daemon-reload[root@docker201.oldboyedu.com ~]# [root@docker201.oldboyedu.com ~]# systemctl restart docker[root@docker201.oldboyedu.com ~]# 参考链接:　　https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors</span><br></pre></td></tr></table></figure>

<p><img src="%25E7%25AC%2594%25E8%25AE%25B0/04-%25E8%2580%2581%25E7%2594%25B7%25E5%25AD%25A9%25E6%2595%2599%25E8%2582%25B2-Docker%25E7%259A%2584%25E6%259E%25B6%25E6%259E%2584%25E4%25BB%258B%25E7%25BB%258D%25E5%258F%258A%25E9%2583%25A8%25E7%25BD%25B2%25E5%25AE%259E%25E6%2588%2598.assets/image-20210609005632041.png" alt="image-20210609005632041"></p>
<h1 id="三-dockers命令自动补全-新手必备"><a href="#三-dockers命令自动补全-新手必备" class="headerlink" title="三.dockers命令自动补全(新手必备)"></a>三.dockers命令自动补全(新手必备)</h1><h2 id="1-为啥能自动补全"><a href="#1-为啥能自动补全" class="headerlink" title="1.为啥能自动补全"></a>1.为啥能自动补全</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Linux系统许多命令都会提供该命令自身的命令补齐脚本，在安装命令时会自动安装自动补齐脚本，如果有的话，该机制在Linux中被称为bash-complete。	如下图所示，在/usr/share/bash-completion/completions/ 目录下有许多命令自动补齐的脚本，我们已经安装了docker环境。	</span><br></pre></td></tr></table></figure>

<p><img src="%25E7%25AC%2594%25E8%25AE%25B0/04-%25E8%2580%2581%25E7%2594%25B7%25E5%25AD%25A9%25E6%2595%2599%25E8%2582%25B2-Docker%25E7%259A%2584%25E6%259E%25B6%25E6%259E%2584%25E4%25BB%258B%25E7%25BB%258D%25E5%258F%258A%25E9%2583%25A8%25E7%25BD%25B2%25E5%25AE%259E%25E6%2588%2598.assets/image-20210609230730489.png" alt="image-20210609230730489"></p>
<h2 id="2-安装相关依赖包"><a href="#2-安装相关依赖包" class="headerlink" title="2.安装相关依赖包"></a>2.安装相关依赖包</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum -y install bash-completionsource /usr/share/bash-completion/bash_completion</span><br></pre></td></tr></table></figure>



<h2 id="3-验证补全功能"><a href="#3-验证补全功能" class="headerlink" title="3.验证补全功能"></a>3.验证补全功能</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如下图所示，当我们输入子命令不知道该如何是好的时候，就可以连续按两下&quot;tab&quot;键即可。</span><br></pre></td></tr></table></figure>

<p><img src="04-%E8%80%81%E7%94%B7%E5%AD%A9%E6%95%99%E8%82%B2-Docker%E7%9A%84%E6%9E%B6%E6%9E%84%E4%BB%8B%E7%BB%8D%E5%8F%8A%E9%83%A8%E7%BD%B2%E5%AE%9E%E6%88%98.assets/image-20210609231114594.png" alt="image-20210609231114594"></p>
]]></content>
      <categories>
        <category>云计算</category>
      </categories>
      <tags>
        <tag>虚拟化</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux磁盘管理</title>
    <url>/Linux%E5%9F%BA%E7%A1%80/Linux%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="Linux磁盘管理"><a href="#Linux磁盘管理" class="headerlink" title="Linux磁盘管理"></a>Linux磁盘管理</h1><h2 id="磁盘的分类及特点"><a href="#磁盘的分类及特点" class="headerlink" title="磁盘的分类及特点"></a>磁盘的分类及特点</h2><h3 id="磁盘的分类"><a href="#磁盘的分类" class="headerlink" title="磁盘的分类"></a>磁盘的分类</h3><ul>
<li>机械硬盘hdd—容量大，价格便宜速度慢 ；</li>
<li>固态硬盘sdd—容量小，价格较贵速度快；</li>
</ul>
<h3 id="磁盘接口"><a href="#磁盘接口" class="headerlink" title="磁盘接口"></a>磁盘接口</h3><ul>
<li><p>IDE（Integrated Drive Electronics）</p>
<p><img src="https://exp-picture.cdn.bcebos.com/e9a4f2eeadbcbe2fb5bfecad54dae43b3a867865.jpg?x-bce-process=image/resize,m_lfit,w_500,limit_1/format,f_jpg/quality,q_80" alt="硬盘的接口种类"></p>
<ul>
<li>本意是指把“硬盘控制器”与“盘体”集成在一起的硬盘驱动器；</li>
<li>优点：价格低廉兼容性好；</li>
</ul>
</li>
<li><p>SCSI（Small Computer System Interface ）</p>
<p><img src="https://exp-picture.cdn.bcebos.com/edafb3bcbe2f4770b5d7756f6f3b3b8603217965.jpg?x-bce-process=image/resize,m_lfit,w_500,limit_1/format,f_jpg/quality,q_80" alt="硬盘的接口种类"></p>
<ul>
<li>不是专门为硬盘设计的，而是一种总线型的系统接口；</li>
<li>优点：适应面广高性能同时具备内、外置；</li>
</ul>
</li>
<li><p>FC（Fibre Channel ）</p>
<p><img src="https://exp-picture.cdn.bcebos.com/51cd85cec7f88a772f0d22f96e4a2f27e6eff865.jpg?x-bce-process=image/resize,m_lfit,w_500,limit_1/format,f_jpg/quality,q_80" alt="硬盘的接口种类"></p>
<ul>
<li>FC最初是专门为网络系统设计的随着存储系统对速度的需求，逐渐应用到硬盘系统中；</li>
<li>优点：带宽高、连接距离长、连接设备数量大；</li>
</ul>
</li>
<li><p>SATA（Serial ATA ）</p>
<p><img src="http://www.dnpz.net/uploads/allimg/180122/983-1P1221054295Z.jpg" alt="电脑硬件知识：带你了解硬盘的各种接口类型"></p>
<ul>
<li>是一种完全不同于并行ATA的新型硬盘接口类型，由于采用串行方式传输数据而得名；</li>
<li>优点：一对一连接，独享带宽、支持热插拔、低电压信号、带宽升级潜力大；</li>
</ul>
</li>
<li><p>SAS（Serial Attached SCSI ） </p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/4101dfdf9cf599b1de7b5314b0861421.png" alt="image"></p>
<ul>
<li><p>即串行连接SCSI，是新一代的SCSI技术，和SATA相同，都是采用串行技术以获得更高的传输速度，并通过缩短连接线改善内部空间 </p>
</li>
<li><p>优点：兼容性好、数据传输率高；</p>
</li>
</ul>
<p>搭配方式：</p>
<p>SSD+SAS==》土豪</p>
<p>SSD+SATA==》常规，对速度有特殊要求</p>
<p>机械+SAS==》常规，对速度要求一般，比较核心业务使用</p>
<p>机械+SATA==》公司内部服务</p>
</li>
</ul>
<h3 id="磁盘性能指标"><a href="#磁盘性能指标" class="headerlink" title="磁盘性能指标"></a>磁盘性能指标</h3><ul>
<li>容量<ul>
<li>家用：1T、2T……</li>
<li>企业: 300G、600G、900G……</li>
</ul>
</li>
<li>转速<ul>
<li>家用：4.5k\7.2krpm</li>
<li>企业：7.2k、10k、15k</li>
</ul>
</li>
<li>缓存</li>
</ul>
<h3 id="磁盘组成"><a href="#磁盘组成" class="headerlink" title="磁盘组成"></a>磁盘组成</h3><table>
<thead>
<tr>
<th align="center">磁盘知识点</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">磁头 header</td>
<td align="center">读取或写入数据,移动只能是径向方法,磁头是从0开始,磁头数==盘面数</td>
</tr>
<tr>
<td align="center">磁道tracker</td>
<td align="center">当磁盘旋转时，磁头若保持在一个位置上，则每个磁头都会在磁盘表面划出一个圆形轨迹，这些圆形轨迹就叫做磁道。</td>
</tr>
<tr>
<td align="center">扇区sector</td>
<td align="center">扇区，是指磁盘上划分的区域。磁盘上的每个磁道被等分为若干个弧段，这些弧段便是磁盘的扇区，硬盘的读写以扇区为基本单位，从1开始</td>
</tr>
<tr>
<td align="center">柱面cylinder</td>
<td align="center">硬盘通常由重叠的一组盘片构成，每个盘面都被划分为数目相等的磁道，并从外缘的“0”开始编号，具有相同编号的磁道形成一个圆柱，称之为磁盘的柱面</td>
</tr>
</tbody></table>
<ul>
<li><p>扇区（512KB）是磁盘读取的基本单位</p>
</li>
<li><p>block（4KB）是系统层面上面读写数据的单位 </p>
</li>
</ul>
<p><img src="../AppData/Roaming/Typora/typora-user-images/image-20210330201437498.png" alt="image-20210330201437498"></p>
<h2 id="RAID独立冗余磁盘阵列"><a href="#RAID独立冗余磁盘阵列" class="headerlink" title="RAID独立冗余磁盘阵列"></a>RAID独立冗余磁盘阵列</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>简单的说，RAID是一种把多块独立的硬盘（物理硬盘）按不同的方式组 合起来形成一个硬盘组（逻辑硬盘），从而提高存储性能和容错功能。</p>
<h3 id="raid级别"><a href="#raid级别" class="headerlink" title="raid级别"></a>raid级别</h3><ul>
<li><p><em>raid0</em></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">容量：N块盘合在一起的容量；</span><br><span class="line">性能：理论上是N块盘合在一起的读写速度，实际上是略低一些；</span><br><span class="line">冗余性：不允许坏任何一块硬盘，一块坏，全部gg;</span><br><span class="line">场合：追求读写性能，但对数据安全性无要求；</span><br><span class="line">特点:追求速度，不考虑数据安全；</span><br><span class="line">ps:可以考虑用集群服务器</span><br></pre></td></tr></table></figure></li>
<li><p><em>raid1</em></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">至少2快盘</span><br><span class="line">容量：一块盘的容量</span><br><span class="line">性能：几乎就是一块盘的读写速度</span><br><span class="line">冗余性：可以坏一块盘，另外一块盘有完整的数据；一块存数据，一块备份数据（备份过）</span><br><span class="line">场合：对数据安全性有要求，对读写速度没有要求</span><br><span class="line">特点:追求数据安全，不考虑速度</span><br><span class="line">ps:主要用于服务器的系统盘</span><br></pre></td></tr></table></figure></li>
<li><p><em>raid5</em>(结余raid0与raid1之间，是一种折中的方案)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">至少三块盘，两两之间做奇偶校验，相同结果为0，不同结果为1</span><br><span class="line">容量：以三快盘为例，只有两块容量可用，一块作为校验</span><br><span class="line">性能：读写速度低于raid0，高于raid1</span><br><span class="line">冗余性：可以坏一块盘，其余两块可通过奇偶校验推导出坏盘的数据</span><br><span class="line">场合：一般场合都可使用</span><br><span class="line">ps:兼顾了速度和安全性</span><br></pre></td></tr></table></figure></li>
<li><p><em>raid10</em>(raid1和raid0整合的产物，兼顾了raid1的数据安全性和raid0的性能，成本高)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">至少4块</span><br><span class="line">容量：所有容量的一半</span><br><span class="line">性能：读写速度很快</span><br><span class="line">冗余性：可以损坏一半，但损毁的的不能再一组</span><br><span class="line">场合：</span><br><span class="line">ps:性能和冗余很好的业务。数据库主库和存储的主节点</span><br></pre></td></tr></table></figure></li>
<li><p>冗余 raid1 raid10 raid5 raid0</p>
</li>
<li><p>读写性能 raid0 raid10 raid5 raid1</p>
</li>
<li><p>成本 raid0、raid5、raid1、raid10</p>
</li>
</ul>
<h2 id="磁盘分区"><a href="#磁盘分区" class="headerlink" title="磁盘分区"></a>磁盘分区</h2><p><strong>1.分区表</strong></p>
<ul>
<li>MBR</li>
</ul>
<p>磁盘主引导记录 0磁头0磁道1扇区 大小512k</p>
<p>磁盘分区表结构：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">446bytes:</span><br><span class="line">	主引导记录MBR所在地址；</span><br><span class="line">64bytes:</span><br><span class="line">	磁盘分区信息 DPT，磁盘分区表；</span><br><span class="line">2bytes:</span><br><span class="line">	55AA,分区信息结束 DPT 磁盘分区表；</span><br></pre></td></tr></table></figure>

<ul>
<li><p>GPT</p>
<ul>
<li>mbr升级版</li>
<li>主分区足够用</li>
<li>可支持大容量硬盘</li>
</ul>
<p>区别:</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">gpt</th>
<th align="center">mbr</th>
</tr>
</thead>
<tbody><tr>
<td align="center">主分区数量不限</td>
<td align="center">主分区最多4个扩展分区1个</td>
</tr>
<tr>
<td align="center">可额外支持大容量2tb以上硬盘</td>
<td align="center">mbr只支持2tb以内的硬盘</td>
</tr>
</tbody></table>
<ul>
<li>主分区p：存放数据，必须拥有；</li>
<li>扩展分区e：用来给逻辑分区创造空间；</li>
<li>逻辑分区l：在扩展分区下面，进行创建，使用扩展分区空间；</li>
</ul>
<p><em><strong>2.询磁盘信息</strong></em></p>
<p>一般查询磁盘信息主要查看这三个指标</p>
<ul>
<li>使用率</li>
<li>当前读写速度</li>
<li>其它信息</li>
</ul>
<p>1.df命令 ： 查看当前磁盘容量使用率（不用参数以k为单位）；</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">df -i #查看inode使用情况</span><br><span class="line">df -h #以人性化方式显示</span><br><span class="line">df -T  #查看磁盘分区类型（文件系统类型）</span><br><span class="line"></span><br><span class="line">[root@yum_server_100 /]# df -i</span><br><span class="line">Filesystem                Inodes IUsed    IFree IUse% Mounted on</span><br><span class="line">devtmpfs                  121457   393   121064    1% /dev</span><br><span class="line">tmpfs                     124460     1   124459    1% /dev/shm</span><br><span class="line">tmpfs                     124460   765   123695    1% /run</span><br><span class="line">tmpfs                     124460    16   124444    1% /sys/fs/cgroup</span><br><span class="line">/dev/mapper/centos-root 26214400 47406 26166994    1% /</span><br><span class="line">/dev/mapper/centos-home 24637440    13 24637427    1% /home</span><br><span class="line">/dev/sde1                 524288   326   523962    1% /boot</span><br><span class="line">tmpfs                     124460     1   124459    1% /run/user/0</span><br><span class="line">[root@yum_server_100 /]# </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">root@yum_server_100 /]# df -h</span><br><span class="line">Filesystem               Size  Used Avail Use% Mounted on</span><br><span class="line">devtmpfs                 475M     0  475M   0% /dev</span><br><span class="line">tmpfs                    487M     0  487M   0% /dev/shm</span><br><span class="line">tmpfs                    487M  7.6M  479M   2% /run</span><br><span class="line">tmpfs                    487M     0  487M   0% /sys/fs/cgroup</span><br><span class="line">/dev/mapper/centos-root   50G   14G   37G  27% /</span><br><span class="line">/dev/mapper/centos-home   47G   33M   47G   1% /home</span><br><span class="line">/dev/sde1               1014M  137M  878M  14% /boot</span><br><span class="line">tmpfs                     98M     0   98M   0% /run/user/0</span><br><span class="line"></span><br><span class="line">[root@yum_server_100 /]# df -T</span><br><span class="line">Filesystem              Type     1K-blocks     Used Available Use% Mounted on</span><br><span class="line">devtmpfs                devtmpfs    485828        0    485828   0% /dev</span><br><span class="line">tmpfs                   tmpfs       497840        0    497840   0% /dev/shm</span><br><span class="line">tmpfs                   tmpfs       497840     7768    490072   2% /run</span><br><span class="line">tmpfs                   tmpfs       497840        0    497840   0% /sys/fs/cgroup</span><br><span class="line">/dev/mapper/centos-root xfs       52403200 13739376  38663824  27% /</span><br><span class="line">/dev/mapper/centos-home xfs       49250820    33044  49217776   1% /home</span><br><span class="line">/dev/sde1               xfs        1038336   140076    898260  14% /boot</span><br><span class="line">tmpfs                   tmpfs        99572        0     99572   0% /run/user/0</span><br></pre></td></tr></table></figure>

<p>2.使用lsblk查看分区情况</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@yum_server_100 /]# lsblk</span><br><span class="line">NAME            MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sda               8:0    0    1G  0 disk </span><br><span class="line">sdb               8:16   0    1G  0 disk </span><br><span class="line">└─sdb1            8:17   0  100M  0 part </span><br><span class="line">sdc               8:32   0    1G  0 disk </span><br><span class="line">sdd               8:48   0    3T  0 disk </span><br><span class="line">sde               8:64   0  100G  0 disk </span><br><span class="line">├─sde1            8:65   0    1G  0 part /boot</span><br><span class="line">└─sde2            8:66   0   99G  0 part </span><br><span class="line">  ├─centos-root 253:0    0   50G  0 lvm  /</span><br><span class="line">  ├─centos-swap 253:1    0    2G  0 lvm  [SWAP]</span><br><span class="line">  └─centos-home 253:2    0   47G  0 lvm  /home</span><br><span class="line">sr0              11:0    1  3.7G  0 rom  </span><br><span class="line">sr1              11:1    1  4.5G  0 rom  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3.使用du命令查看目录或者文件容量，不参加以k为单位</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">du -sh #人性化输出显示大小</span><br><span class="line">-s :summary 总结，汇总列出总和</span><br><span class="line">-h:人性化显示容量信息，人类可读 </span><br></pre></td></tr></table></figure>

<p>4.iotop  显示当前硬盘读取速度</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iotop #显示磁盘io</span><br><span class="line">iotop -o 只显示进行读写进程信息</span><br><span class="line">dd if=/dev/zero  of=/tmp/big    bs=1k  count=10000000</span><br></pre></td></tr></table></figure>

<h3 id="fdisk-分区"><a href="#fdisk-分区" class="headerlink" title="fdisk 分区"></a>fdisk 分区</h3><ul>
<li><p>fdisk :这个命令是磁盘分区表操作工具，fdisk能将磁盘分区，同时也能为每个分区指定分区类型，总的来说，fdisk就是磁盘工具。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">fdisk -l	#查看硬盘分区表</span><br><span class="line"><span class="meta">#</span><span class="bash"> fdisk -l</span></span><br><span class="line">  Device Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/sdb1            2048      206847      102400   83  Linux</span><br><span class="line">/dev/sdb2          206848      616447      204800   83  Linux</span><br><span class="line">/dev/sdb3          616448     1230847      307200    5  Extended</span><br><span class="line">/dev/sdb5          618496      638975       10240   83  Linux</span><br><span class="line">/dev/sdb6          641024      661503       10240   83  Linux</span><br><span class="line">/dev/sdb7          663552      684031       10240   83  Linux</span><br><span class="line">/dev/sdb8          686080      890879      102400    c  W95 FAT32 (LBA)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>fdisk /dev/sdb 分区</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@yum_server_100 /]# fdisk /dev/sdb</span><br><span class="line"><span class="meta">#</span><span class="bash">进入Command 分区命令行；如果输入错误用ctrl+u进行删除重新输入命令</span></span><br><span class="line">Welcome to fdisk (util-linux 2.23.2).</span><br><span class="line"></span><br><span class="line">Changes will remain in memory only, until you decide to write them.</span><br><span class="line">Be careful before using the write command.</span><br><span class="line"></span><br><span class="line">Device does not contain a recognized partition table</span><br><span class="line">Building a new DOS disklabel with disk identifier 0xe42d9531.</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> p -- 展示指定硬盘已有分区（目前没有增加分区）</span></span><br><span class="line">Command (m for help): p</span><br><span class="line">Disk /dev/sdc: 1073 MB, 1073741824 bytes, 2097152 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disk label type: dos</span><br><span class="line">Disk identifier: 0xe42d9531</span><br><span class="line"></span><br><span class="line">   Device Boot      Start         End      Blocks   Id  System</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> n--在硬盘中新增一个主分区</span></span><br><span class="line">Command (m for help): n</span><br><span class="line"><span class="meta">#</span><span class="bash"> 会有选p主分区 e扩展分区 默认空白是p主分区</span> </span><br><span class="line">Partition type:</span><br><span class="line">   p   primary (0 primary, 0 extended, 4 free)</span><br><span class="line">   e   extended</span><br><span class="line">Select (default p): p</span><br><span class="line">Partition number (1-4, default 1): 1  #分区编号默认编号1</span><br><span class="line">First sector (2048-2097151, default 2048): #选择分区开始位置这里忽略只在意结束位置（大小）</span><br><span class="line">Using default value 2048</span><br><span class="line">Last sector, +sectors or +size&#123;K,M,G&#125; (2048-2097151, default 2097151): +100M #指定分区大小</span><br><span class="line">Partition 1 of type Linux and of size 100 MiB is set  #成功！！！</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">分区后 p展示分区信息</span></span><br><span class="line">Command (m for help): p</span><br><span class="line">  Device Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/sdc1            2048      206847      102400   83  Linux</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#同理要想建立扩展分区 在n之后选择e即可 扩展分区建立后 才能建立逻辑分区</span></span> </span><br><span class="line"></span><br><span class="line">d 删除分区</span><br><span class="line">t 将分区换类型</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="parted分区"><a href="#parted分区" class="headerlink" title="parted分区"></a>parted分区</h3><p><strong>一.parted的用用途及说明：</strong></p>
<ul>
<li>parted ：parted分区是fdisk分区升级版本，可以划分多个主分，支持2TB以上的磁盘分区，并且允许调整分区的大小。</li>
<li>parted是一个用于硬盘分区或调整分区大小的工具。使用它你可以创建、清除、调整、移动和复制ext2、ext3、linux-swap、FAT、FAT32和reiserfs分区；也能创建、调整和移动苹果系统的HFS分区；还能检测jfs、ntfs、ufs和xfs分区。该工具常用于为新安装的操作系统创建空间，重新分配硬盘使用情况，在将数据拷贝到新硬盘的时候也常常使用。</li>
</ul>
<p><strong>二.parted的使用方法及步骤</strong></p>
<p>1.对磁盘进行分区</p>
<p>(1) 命令方式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">parted /dev/sdb mklabel gpt mkpart 1 ext3 1 1T</span><br></pre></td></tr></table></figure>

<p>(2)交互式：</p>
<ul>
<li>命令：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">p (print) 	    #显示磁盘分区信息</span><br><span class="line">mktable 	#创建磁盘分区表 gpt/msdos</span><br><span class="line">mkpart 		#创建磁盘分区 mkpart primary 0 100</span><br><span class="line">rm 			#删除磁盘分区</span><br><span class="line">q 			#quit</span><br></pre></td></tr></table></figure>

<ul>
<li>分区步骤:</li>
</ul>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left">#parted  /dev/sdb</td>
<td align="left">对/dev/sdb进行分区或管理操作</td>
</tr>
<tr>
<td align="left">GNU Parted 3.1<br/>Using /dev/sda<br/>Welcome to GNU Parted! Type ‘help’ to view a list of commands.</td>
<td align="left">系统返回值</td>
</tr>
<tr>
<td align="left">(parted)   mklabel  gpt</td>
<td align="left">定义分区表格式常用的有msdos和gpt分区表格式，msdos不支持2TB以上（常用的有msdos和gpt分区表格式，msdos不支持2TB以上容量的磁盘，所以大于2TB的磁盘选gpt分区表格式）</td>
</tr>
<tr>
<td align="left">(parted) mkpart p1</td>
<td align="left">创建第1个分区，名称为p1</td>
</tr>
<tr>
<td align="left">File system type?  [ext2]?</td>
<td align="left">定义分区格式（不支持ext4，想分ext4格式分区，可以通过mkfs.ext4格式化ext4格式）</td>
</tr>
<tr>
<td align="left">Start？  1</td>
<td align="left">定义分区的起始位置（单位支持K,M,G,T）</td>
</tr>
<tr>
<td align="left">End？  1G</td>
<td align="left">定义分区的结束位置（单位支持K,M,G,T）</td>
</tr>
<tr>
<td align="left">(parted)   print</td>
<td align="left">查看当前分区情况</td>
</tr>
<tr>
<td align="left">Model: VMware, VMware Virtual S (scsi)<br/>Disk /dev/sda: 1074MB<br/>Sector size (logical/physical): 512B/512B<br/>Partition Table: gpt<br/>Disk Flags: <br/><br/>Number  Start   End     Size    File    system  Name  Flags<br/> 1      1049kB  1073MB      1072MB</td>
<td align="left">系统返回值</td>
</tr>
</tbody></table>
<ul>
<li>删除分区步骤：</li>
</ul>
<table>
<thead>
<tr>
<th>(parted)   rm</th>
<th>rm删除命令(删除前必须检查是否挂载)</th>
</tr>
</thead>
<tbody><tr>
<td>Partition number？ 1</td>
<td>删除第一个分区</td>
</tr>
<tr>
<td>(parted)   print</td>
<td>查看当前分区情况</td>
</tr>
<tr>
<td>(parted)   print</td>
<td>查看当前分区情况</td>
</tr>
<tr>
<td>Model:   ATA VBOX HARDDISK (scsibr/Disk   /dev/sda: 21.5GB<br/><br/>Sector   size (logical/physical): 512B/512B<br/><br/>Partition   Table: msdos<br/><br/>Number  Start     End   Size  File system  Name  Flags<br/></td>
<td>系统返回值</td>
</tr>
</tbody></table>
<h2 id="挂载与格式化"><a href="#挂载与格式化" class="headerlink" title="挂载与格式化"></a>挂载与格式化</h2><p><strong>挂载三部曲：</strong></p>
<ul>
<li>磁盘分区：fdisk、parted、gdisk；</li>
<li>格式化：创建文件系统（使磁盘可以存储文件）；</li>
<li>挂载：设置设备入口，给用户访问·。</li>
</ul>
<h3 id="第一部—创建磁盘分区"><a href="#第一部—创建磁盘分区" class="headerlink" title="第一部—创建磁盘分区"></a>第一部—创建磁盘分区</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">fdisk  </span><br><span class="line">n</span><br><span class="line">Disk /dev/sdb: 1073 MB, 1073741824 bytes, 2097152 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disk label type: dos</span><br><span class="line">Disk identifier: 0xc2483040</span><br><span class="line">   Device Boot     Start         End     Blocks   Id </span><br><span class="line">System</span><br><span class="line">/dev/sdb1            2048     2097151     1047552   83 </span><br><span class="line">Linux</span><br></pre></td></tr></table></figure>

<h3 id="第二部—格式化创建文件系统"><a href="#第二部—格式化创建文件系统" class="headerlink" title="第二部—格式化创建文件系统"></a>第二部—格式化创建文件系统</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> mkf.xfs /dev/sdb1</span> </span><br><span class="line">meta-data=/dev/sdb1              isize=512    agcount=4, </span><br><span class="line">agsize=65472 blks</span><br><span class="line">         =                       sectsz=512   attr=2, </span><br><span class="line">projid32bit=1</span><br><span class="line">         =                       crc=1        finobt=0, </span><br><span class="line">sparse=0</span><br><span class="line">data     =                       bsize=4096   </span><br><span class="line">blocks=261888, imaxpct=25</span><br><span class="line">         =                       sunit=0      swidth=0</span><br><span class="line">blks</span><br><span class="line">naming   =version 2              bsize=4096   ascii-ci=0</span><br><span class="line">ftype=1</span><br><span class="line">log      =internal log           bsize=4096   blocks=855, </span><br><span class="line">version=2</span><br><span class="line">         =                       sectsz=512   sunit=0</span><br><span class="line">blks, lazy-count=1</span><br><span class="line">realtime =none                   extsz=4096   blocks=0, </span><br><span class="line">rtextents=0</span><br></pre></td></tr></table></figure>

<h3 id="第三部—挂载"><a href="#第三部—挂载" class="headerlink" title="第三部—挂载"></a>第三部—挂载</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mount 设备 入口</span><br><span class="line">mount /d v/sdb1   /mnt  </span><br><span class="line">[root@oldboyedu ~]# mount /de/sdb1 /mnt/</span><br><span class="line">[root@oldboyedu ~]# df -h</span><br><span class="line">Filesystem               Size Used Avail Use% Mounted on</span><br><span class="line">devtmpfs                 475M     0 475M   0% /dev</span><br><span class="line">tmpfs                   487M     0 487M   0% /dev/shm</span><br><span class="line">tmpfs                   487M  7.7M 479M   2% /run</span><br><span class="line">tmpfs                   487M     0 487M   0% </span><br><span class="line">/sys/fs/cgroup</span><br><span class="line">/dev/mapper/centos-root   37G   16G   22G  43% /</span><br><span class="line">/dev/sda1               1014M 137M 878M  14% /boot</span><br><span class="line">tmpfs                     98M     0   98M   0% </span><br><span class="line">/run/user/0</span><br><span class="line">/dev/sdb1               1020M   33M 988M   4% /mnt</span><br></pre></td></tr></table></figure>

<h3 id="永久挂载"><a href="#永久挂载" class="headerlink" title="永久挂载"></a>永久挂载</h3><p>上述挂载方式为临时挂载方式接下来介绍两种永久挂载方式：</p>
<ul>
<li>方法一：通用写法，把挂载命令写到开机执行，开机启动文件 /etc/rc.d/rc.loacl</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/rc.d/rc.local</span><br><span class="line">把挂载命令写到开机执行文件上</span><br><span class="line">mount /dev/sdb /mount</span><br><span class="line">chmod +x /etc/rc.d/rc.local</span><br></pre></td></tr></table></figure>

<ul>
<li>方法二：专业写法，开机开机自动挂载信息表    /etc/fstab</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/etc/fstab文件内容格式说明</span><br><span class="line">/dev/mapper/centos-root /                       xfs     defaults        0 0</span><br><span class="line">UUID=0b6d9742-6dc9-434e-acb3-88d46bc5210c /boot                   xfs     defaults        0 0</span><br><span class="line">/dev/mapper/centos-home /home                   xfs     defaults        0 0</span><br><span class="line">/dev/mapper/centos-swap swap                    swap    defaults        0 0</span><br><span class="line"></span><br><span class="line">弟1列：备名称、uuid</span><br><span class="line">第2列：挂载点</span><br><span class="line">第3列：文件系统类型</span><br><span class="line">第4列：挂载选项</span><br><span class="line">第5列：是否备份</span><br><span class="line">第6列：是否开机检查</span><br></pre></td></tr></table></figure>

<h2 id="SWAP"><a href="#SWAP" class="headerlink" title="SWAP"></a>SWAP</h2><ul>
<li>swap 交换分区，内存不足时将物理内存充当临时内存。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">通过创建文件增加swap</span><br><span class="line">1）创建文件 dd  if=/dev/zero  of=/tmp/swap  bs=1M count=500</span><br><span class="line">2)转换为swap 	 mkswap /tmp/swap</span><br><span class="line">3)激活 		 swapon /tmp/swap</span><br><span class="line"></span><br><span class="line">free -h 查看系统内存情况</span><br><span class="line">swapon -s 查看当前系统swap组成</span><br></pre></td></tr></table></figure>

<ul>
<li><p>永久生效</p>
<ul>
<li>swapon /tmp/swap 命令写到 /etc/rc.local</li>
<li>将swap分区属性写到 /etc/fstab</li>
</ul>
</li>
<li><p>umount /mnt 卸载</p>
</li>
<li><p>umount -lf 强制卸载</p>
</li>
</ul>
<script src='https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/mouse_snow.min.js'></script>

















]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
      <tags>
        <tag>磁盘</tag>
      </tags>
  </entry>
</search>
